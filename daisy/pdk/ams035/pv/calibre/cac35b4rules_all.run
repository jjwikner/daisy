////////////////////////////////////////////////////
// Owner: austriamicrosystems AG                  //
//        Business Unit Silicon Foundry           //
//================================================//
//        HIT-Kit: Digital                        //
////////////////////////////////////////////////////
// 3-Aug-2006 checked for release 2006.2
///////////////////////////////////////////////////////////////////////
//
// DRC/LVS/PEX header for process c35b4/c35b3
//
TITLE "DRC/LVS 0.35 U CMOS C35B4/C35B3 REV5 polycide 3V/5V (last modified 15-Jul-08)"
//
///////////////////////////////////////////////////////////////////////
//
// ATTENTION : flag for definition of processes
//
// use c35b4 4 metal process
//--------------------------
//
#DEFINE fourmetal // global switch
// 
// use c35b3 3 metal process
//--------------------------
//
//#UNDEFINE fourmetal
//
// use relaxed c35 rules for converted csx layouts
//--------------------------------------------------
//
//#DEFINE csxswitch
// 
// do not use relaxed c35 rules for converted csx layouts
//--------------------------------------------------------
//
#UNDEFINE csxswitch
//
// pexswitch only for XRC with rf devices
//----------------------------------------
// note : rfdef layer is used as parasitic resistor/cap blocking layer for poly1/met1
//        (met2 cvar only) since parasitic res and caps are already included
//        in the device model
//        activate this switch only for calibre -xrc if rf devices are used
//
// default is undefine
//
// #DEFINE PEXSWITCH
// #UNDEFINE PEXSWITCH
//
///////////////////////////////////////////////////////////////////////
//
//            detailed process definition( module check)
//
///////////////////////////////////////////////////////////////////////
//
// this section allows to select a  more detailed processe( with/without
// poly2, hres, midox ..). See DRC document for definitions 
//
// If "process_switch" is not used, all modules are checked, only met3/met4
// is can be selected by "fourmetal" switch 
//
// module check flags unsupported layers as DRC errors
// module check disables unsupported devices in LVS
//
//
// select one process
//---------------------
// photo diode 
//#DEFINE process_C35B4O1 // core, poly2, midox, met4
//#DEFINE process_C35B3O1 // core, poly2, midox
//
//#DEFINE process_C35A3B0 // core
//#DEFINE process_C35B3C0 // core, poly2
//#DEFINE process_C35B3C1 // core, poly2, midox
//#DEFINE process_C35B3C3 // core, poly2, midox, hres
//#DEFINE process_C35B3L3 // core, poly2, midox, hres , lvtdef
//#DEFINE process_C35B4C0 // core, poly2,              met4
//#DEFINE process_C35B4C3 // core, poly2, midox, hres, met4
//#DEFINE process_C35A4L5 // core, midox, lvtdef, cmim, met4
//#DEFINE process_C35B4M6 // core, poly2, hres, cmim, met4
//#DEFINE process_C35B4L7 // core, poly2, midox, hres, lvtdef, cmim, met4
//
//
// thick top metal not implemented yet
//#DEFINE process_C35B4M3 // core poly2, thick met4, cmim
//
// dummy square for process DRC output 
//
   bound_cent = EXTENTS  substrate_all CENTERS 1.0
//
// default setting is check for all layers
//-----------------------------------------
//
#DEFINE layer_devdefopto
#DEFINE layer_lvtdef
#DEFINE layer_poly2
#DEFINE layer_midox
#DEFINE layer_hres
#DEFINE layer_metcap
// set flag for default checks
#UNDEFINE process_found_flag
//
// set layers for processes
//-------------------------
//
// c35a3b0
//
#IFDEF process_C35A3B0
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #UNDEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35A3B0 { @ INFO : DRC checked with c35a3b0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c0
//
#IFDEF process_C35B3C0
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C0 { @ INFO : DRC checked with c35b3c0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c1
//
#IFDEF process_C35B3C1
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C1 { @ INFO : DRC checked with c35b3c1
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c3
//
#IFDEF process_C35B3C3
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C3 { @ INFO : DRC checked with c35b3c3
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3l3
//
#IFDEF process_C35B3L3
  #UNDEFINE layer_devdefopto
  #DEFINE layer_lvtdef  
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3L3 { @ INFO : DRC checked with c35b3l3
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4c0
//
#IFDEF process_C35B4C0
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #DEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4C0 { @ INFO : DRC checked with c35b4c0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4c3
//
#IFDEF process_C35B4C3
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #DEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4C3 { @ INFO : DRC checked with c35b4c3
       FLATTEN bound_cent
  }
#ENDIF
//
// c35a4l5
//
#IFDEF process_C35A4L5
  #UNDEFINE layer_devdefopto
  #DEFINE layer_lvtdef
  #UNDEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE layer_metcap
  #DEFINE process_found_flag
  INFO_PROCESS_C35A4L5 { @ INFO : DRC checked with c35a4l5
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4l7
//
#IFDEF process_C35B4L7
  #UNDEFINE layer_devdefopto
  #DEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE layer_metcap
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4L7 { @ INFO : DRC checked with c35b4l7
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4m6
//
#IFDEF process_C35B4M6
  #UNDEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #DEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE process_found_flag
  #DEFINE layer_metcap
  INFO_PROCESS_C35B4M6 { @ INFO : DRC checked with c35b4m6
       FLATTEN bound_cent
  }
#ENDIF
//
//-----------------------------------------------------------------------
// c35b4o1
// photo diode
//
#IFDEF process_C35B4O1
  #DEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #DEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4O1 { @ INFO : DRC checked with c35b4o1
       FLATTEN bound_cent
  }
#ENDIF
//
#IFDEF process_C35B3O1
  #DEFINE layer_devdefopto
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3O1 { @ INFO : DRC checked with c35b3o1
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4m3
//
// thick metal not implemented yet
//
//#IFDEF process_C35B4M3
//  #UNDEFINE layer_lvtdef
//  #DEFINE layer_poly2
//  #DEFINE layer_midox
//  #DEFINE layer_hres
//  #DEFINE layer_metcap
//  #UNDEFINE fourmetal
//  // not available yet
//  #DEFINE fourmetal_thick
//  #DEFINE process_found_flag
//  INFO_PROCESS_C35B4M3 { @ INFO : DRC checked with c35b4m3
//       FLATTEN bound_cent
//  }
//#ENDIF
//
//
// do standard met3/met4 check if not set
//-----------------------------------------
//
#IFNDEF process_found_flag
#IFDEF fourmetal
  INFO_PROCESS_C35B4 { @ INFO : DRC checked with c35b4 ( 4 metal all modules)
       FLATTEN bound_cent
  }
#ELSE
  INFO_PROCESS_C35B3 { @ INFO : DRC checked with c35b3 ( 3 metal all modules)
       FLATTEN bound_cent
  }
#ENDIF
#ENDIF
//
// output of unsupported layer for modules
//-------------------------------------------
//
#IFNDEF layer_devdefopto
  ILL_DEVDEFOPTO_UNAVAILABLE { @ Process Modules : DEVDEFOPTO not available
         COPY OPTDEF
  }
#ENDIF
#IFNDEF layer_hres
  ILL_HRES_UNAVAILABLE { @ Process Modules : HRES not available
         COPY HRES
  }
#ENDIF
#IFNDEF layer_poly2
  ILL_POLY2_UNAVAILABLE { @ Process Modules : POLY2 not available
         COPY POLY2
  }
#ENDIF
#IFNDEF layer_midox
  ILL_MIDOX_UNAVAILABLE { @ Process Modules : MIDOX not available
         COPY MIDOX
  }
#ENDIF
#IFNDEF layer_lvtdef
  ILL_LVTDEF_UNAVAILABLE { @ Process Modules : LVTDEF not available
         COPY LVTDEF
  }
#ENDIF
#IFNDEF fourmetal
  ILL_MET4_UNAVAILABLE { @ Process Modules : MET4 not available
         COPY MET4
  }
  ILL_VIA3_UNAVAILABLE { @ Process Modules : VIA3 not available
         COPY VIA3
  }
#ENDIF
//
#IFNDEF layer_metcap
  ILL_METCAP_UNAVAILABLE { @ Process Modules : METCAP not available
         COPY METCAP
  }
#ENDIF
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
///////////////////////////////////////////////////////////////////////
//
//   C A L I B R E  R U L E   F I L E  S T A N D A R D   H E A D E R
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
//               Define options for stand alone environment 
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
//               I n p u t   d a t a   d e f i n i t i o n s
//
////////////////////////////////////////////////////////////////////////////////////
//
//  layout
//--------------
//
   LAYOUT SYSTEM GDSII
   LAYOUT PATH  "XXX_gds2_filename"
   LAYOUT PRIMARY "XXX_gds2_topcell" 
   LAYOUT DEPTH ALL // PRIMARY
//
//
   MASK SVDB DIRECTORY "svdb" XRC
// MASK SVDB DIRECTORY "svdb" QUERY
//
// check GDSII and terminate
   LAYOUT ERROR ON INPUT YES  // no
// only for SPICE netlist : node , subckt, model
// default is no
// LAYOUT CASE NO // YES 
// LAYOUT INJECTION FACTOR 4
// cut all outside
// LAYOUT WINDEL xlow ylow xhigh yhigh LAYOUT WINDOW CLIP YES
// get all inside
// LAYOUT WINDOW xlow ylow xhigh yhigh LAYOUT WINDOW CLIP YES
//
// EXCLUDE CELL name1 name2 name3
// LAYOUT SYSTEM CNET 
// LAYOUT PATH  "./cnet.l"
//
//  drc
//--------------
//
   DRC SUMMARY REPORT XXX_report REPLACE HIER
   DRC RESULTS DATABASE XXX_gds2_drcout ASCII
// DRC TOLERANCE FACTOR .01
// gds allows 200 vertices
// DRC MAXIMUM VERTEX 199
   DRC MAXIMUM VERTEX 20
//   DRC MAXIMUM RESULTS 10000
   DRC MAXIMUM RESULTS ALL   
   DRC KEEP EMPTY NO
// DRC CHECK MAP width_diffusion 30                 
// DRC CHECK MAP spacing_diffusion 30                 
// FLAG ACUTE YES
// FLAG SKEW YES
// FLAG OFFGRID YES
//
// netlist for lvs
//-------------------
//
// SOURCE CASE NO // YES
//
// SOURCE PATH "netlist.hspi"
// SOURCE PRIMARY "netlist_top"
// SOURCE SYSTEM SPICE
//
////////////////////////////////////////////////////////////////////////////////////
//
//   L V S   o p t i o n s                
//
////////////////////////////////////////////////////////////////////////////////////
//
// substrate and bulk pins have little importance for comparison
// soft does not mean "soft connected"
// creates extra report section
   LVS SOFT SUBSTRATE PINS YES // NO
// 
// write netlist from layout and source before gate building with
// device and net coordinates
//
// LVS WRITE LAYOUT NETLIST "layout.spi"
// LVS WRITE SOURCE NETLIST "source.spi"
//
// LVS ISOLATE SHORTS YES BY LAYER     
// for hierarchical lvs use cell and name option :
//
// shorts in top level cell between all names OR between
// the specified names in all cells
// LVS ISOLATE SHORTS YES CELL PRIMARY || NAME "VCC?" "VSS?"
//
// shorts in all cells only between spicified names
// LVS ISOLATE SHORTS YES CELL ALL && NAME "VCC?" "VSS?"
//
// primary only between all names (default)
// LVS ISOLATE SHORTS YES CELL PRIMARY
//
// all shorts in all cells
// LVS ISOLATE SHORTS YES CELL ALL    
//
// rename layout text on GDSII with regex 
// LAYOUT RENAME TEXT #VDD_BANG#VDD#g
// LAYOUT RENAME TEXT #gnd_bang#VSS#g
//
   LVS REPORT XXX_lvsreport
// report all
   LVS REPORT MAXIMUM ALL
// reduce info generally, LVS tries to report the most informative discrepancies first 
// LVS REPORT MAXIMUM 50
// options may cause large output
// options : A .... detailed instance connections on incorrect nets (no shorts and opens)
//           B .... detailed instance connections on short and opens
//           C .... detailed instance connections on missing net and no similar net
//           D .... detailed instance connections on missing instance and missing gate
//           E .... ignore missing properties
//           F .... disable missing smashed mosfet
//           G .....report detailed instance connections
//           H .....disable cell correspondence names
//           I .....disable isolated nets warning
//           N .....report layout names missing in source
//           V .....report virtuell connect
//
//  LVS REPORT OPTION A B C D
//
// LVS COMPARE CASE NO // default, all comparisons are case INsensitive
// LVS COMPARE CASE YES // all comparison are case sensitive
// LVS COMPARE CASE NAMES  // net instance and port names
// LVS COMPARE CASE TYPES // component type comparison is case sensitive
// LVS COMPARE CASE SUBTYPES // component subtype comparisons are case sensitive
//
// remove empty cell from SPICE and/or layout
// LVS BOX SOURCE calla cellb cellc
// LVS BOX cella cellb cellc
//
   LVS IGNORE PORTS YES //NO
   LVS REDUCE SERIES RESISTORS no
   LVS REDUCE PARALLEL RESISTORS no
   LVS ISOLATE SHORTS YES BY LAYER
// LVS ISOLATE SHORTS YES
// MASK RESULTS DATABASE "maskdb"
   MASK RESULTS DATABASE NONE
//
// LVS FILTER D OPEN  // remove diodes from check
// LVS FILTER mp  w > 3 < 5 OPEN LAYOUT
// LVS FILTER C OPEN  // remove C from check
// LVS FILTER r(x) instapr(r) ==0 SHORT SOURCE // short all 0 res in SPICE
//
// LVS FILTER UNUSED MOS NO
// LVS FILTER UNUSED DIODES NO
// LVS FILTER UNUSED CAPACITORS NO
// LVS FILTER UNUSED BIPOLAR YES
// LVS FILTER UNUSED OPTION AB AC AD AE B C D ZD 
// 20 options, see manual
//  ab ... filter mos devices with source,drain,and gate pims tied together
//  ac ... filter mos devices with floating gate pin and source,drain pins tied to power
//
// LVS FILTER NAND3 OPEN SOURCE LAYOUT
//
// How to short 2 nets in netlist :
// add line in netlist : R net1 net2 $.MODEL=rshort $w=1 $l=1
//
   LVS FILTER R(RP) SHORT
   LVS FILTER R(RESISTOR) SHORT
   LVS FILTER C(CP) OPEN
   LVS FILTER C(CAPACITOR) OPEN
//
// abort if any problem with power/ground
// LVS ABORT ON SUPPLY ERROR YES
// for logic gate recognition, filtering
// attention : if set, gate building is CMOS, this may be an advantage for digital circuits
//             names must match on layout and source sides
//
   LVS POWER NAME "?VCC?" "?VDD?"
   LVS GROUND NAME "?VSS?" "?GND?"
//
// drop mismatch in pin count
   LVS DISCARD PINS BY DEVICE YES
//
//
// LVS ALL CAPACITOR PINS SWAPPABLE YES/NO
// LVS REDUCE PARALLEL MOS YES/NO  // default YES
//
// we do not allow any different L !!!
//
   LVS REDUCE PARALLEL MOS YES [TOLERANCE L 0]  // default YES
//
// LVS REDUCE SPLIT GATES YES/NO
// LVS REDUCE SPLIT GATES SEMI ALSO
// LVS REDUCE PARALLEL BIPOLAR YES/NO  // default YES
// LVS REDUCE SERIES CAPACITORS YES/NO // default YES
// LVS REDUCE PARALLEL CAPACITORS YES/NO // default YES
// LVS REDUCE SERIES RESISTORS YES/NO // defaul YES
// LVS REDUCE PARALLEL RESISTORS YES/NO  // default YES
// LVS REDUCE PARALLEL DIODES YES/NO // default YES
//
// creates AOI and OAI and seriell/parallel SPxxx structures
// ALL    : lvs_recognice_gates = TRUE
//          lvs_recognice_simple_gates = FALSE
// SIMPLE : lvs_recognice_gates = TRUE
//          lvs_recognice_simple_gates = TRUE
// NONE   : lvs_recognice_gates = FALSE
//          lvs_recognice_simple_gates = FALSE
// 
// LVS RECOGNIZE GATES ALL/SIMPLE/NONE  // default is all
// build gates with different model names 
// LVS RECOGNIZE GATES ALL/SIMPLE/NONE MIX SUBTYPES // default is all
//
// LVS COMPONENT TYPE PROPERTY lvs_device spicemodel
// LVS COMPONENT SUBTYPE PROPERTY mdl_prim
// LVS PIN NAME PROPERTY phy_pin
// LVS HEAP DIRECTORY /scratch/tmp   // limit is 2 Gb
// LVS PROPERTY RESOLUTION MAXIMUM 200 // max size of ambiguity groups
// LVS PROPERTY RESOLUTION MAXIMUM ALL // max size of ambiguity groups
// for LVS neighborhood
// LVS SIGNATURE MAXIMUM 10 // see doc
// LVS SIGNATURE MAXIMUM ALL
// LVS SPLIT GATE RATIO MP W 10   // see doc
// LVS REVERSE WL YES // see doc
//
// connect nets by colon :
//  only nets with colon are connected
//  text after colon is stripped off
//  bar: bar:x bar:abc are connected  to bar
//  xyz and zyz: are not connected
//  vdd: and vdd: are connected
//  xyz: in layout and zyz in schem are initial correspondence points
// VIRTUAL CONNECT COLON YES
//
// example : 4 nets :  vss vss vss: vss:x 
// VIRTUAL CONNECT COLON NO  
// VIRTUAL CONNECT NAME "VSS"  // vss: and vss:x stay
// VIRTUAL CONNECT COLON YES 
// VIRTUAL CONNECT NAME "VSS"  // 4 nets connected
// VIRTUAL CONNECT NAME "VSS" "VDD" "VSSA" "VDDA" "vdd_bang" "gnd_bang"
//
// connect all equal names and report 
   VIRTUAL CONNECT NAME '?'
   VIRTUAL CONNECT REPORT YES
// 
// lvs device parameters
//-----------------------
//
// check for 1 %

// syntax : trace Property type(model) source_prop layout_prop tolerance
//
// mos
//
   TRACE PROPERTY mn(nmosrf) W W 1
   TRACE PROPERTY mn(nmosrf) L L 1
   TRACE PROPERTY mn(nmosrf) NG NG 1
   TRACE PROPERTY mp(pmosrf) W W 1
   TRACE PROPERTY mp(pmosrf) L L 1
   TRACE PROPERTY mp(pmosrf) NG NG 1
//
   TRACE PROPERTY mn W W 1
   TRACE PROPERTY mp W W 1
   TRACE PROPERTY mn L L 1
   TRACE PROPERTY mp L L 1
//
   TRACE PROPERTY m(cvar) W W 1 // IC-Station
   TRACE PROPERTY m(cvar) L L 1 // IC-Station
//
   TRACE PROPERTY lddn W W 1
   TRACE PROPERTY lddn L L 1
// TRACE PROPERTY lddp W W 1
// TRACE PROPERTY lddp L L 1
//
// resistors
   TRACE PROPERTY r  W W 1
   TRACE PROPERTY r  L L 1

// bipolar
// IC_Station :TRACE PROPERTY Q(pnplat2) a a 1  
   TRACE PROPERTY Q(pnplat) a a 1  
   TRACE PROPERTY Q(pnpvert10) a a 1  

// jfet
// TRACE PROPERTY J(njfet4) w w 1  
// TRACE PROPERTY J(njfet4) l l 1  

// cap
//
   TRACE PROPERTY C(cpolyrf) w w 1
   TRACE PROPERTY C(cpolyrf) l l 1
//
   TRACE PROPERTY C "area" a  1  
   TRACE PROPERTY C "perimeter" p  1  
//
//
   TRACE PROPERTY D a a 1
//
// photo diode
//
   TRACE PROPERTY PHD(phdnwa850) w w 1
   TRACE PROPERTY PHD(phdnwa850) l l 1
//
////////////////////////////////////////////////////////////////////////////////////
//
//   N e t l i s t   e x t r a c t i o n
//
////////////////////////////////////////////////////////////////////////////////////
//
// Attention : Usage of these options corresponds to switches of
// phdb/pdb/fmt options
//
// netlist and parasitic extraction for CALIBRE-XRC
//-------------------------------------------------
// attention : exclude supply nets, use correct supply nets
//
// reduce geometries of nearbody caps to speed up run and reduce disk space
//  PEX LAYER routingpoly WINDOW 2.0 
//  PEX LAYER routingmet1 WINDOW 2.0 
//  PEX LAYER routingmet2 WINDOW 2.0 
//  PEX LAYER routingmet3 WINDOW 2.0 
//
// extract simple netlist 
//------------------------
//      output : SPICE LSIM
// PEX NETLIST SIMPLE XXX_netout SPICE LAYOUT
// PEX NETLIST SIMPLE "netout.spi" HSPICE LAYOUT
// PEX NETLIST SIMPLE "netout.spi" HSPICE SOURCE LOCATION SEPARATOR "_" MAXLENGTH 20
//
// PEX BACKANNOTATION SIMPLE "ascii.ba" ASCII
// obsolate
//   PEX BACKANNOTATION SIMPLE NONE
//   PEX BACKANNOTATION LUMPED NONE
//   PEX BACKANNOTATION DISTRIBUTED NONE
//
// extract lumped netlist :
//--------------------------
//   PEX NETLIST LUMPED "netout_lumped.spi" HSPICE LAYOUT MASK
//     extract lumped netlist with source names :
//     ground vss : ground node, if not given :0 
//     location : device loc as comment
//     separator : net name hierarchy, default is / 
//     output format : SPICE , LSIM
//     maxlength : MAXLENGTH number : replace long names
// PEX NETLIST LUMPED "netout_lumped.spi" SPICE SOURCE GROUND VSS SEPARATOR "_" LOCATION MASK
// PEX NETLIST LUMPED "netout_lumped.spi" SPECTRE LAYOUT GROUND VSS SEPARATOR "_" LOCATION MASK
 PEX NETLIST LUMPED "netout_lumped.spi" HSPICE LAYOUT GROUND VSS SEPARATOR "_" LOCATION MASK
//     lump all caps (crossover, nearbody) to ground
// PEX REDUCE LUMPED C < 100000
// PEX REPORT LUMPED "pexrep_lumped.spi" LAYOUT 
   PEX REPORT LUMPED NONE
//     only for this nets, must be layout names
//   PEX INCLUDE LUMPED net1 net2 net3 
//     remove nets
   PEX EXCLUDE LUMPED VDD VSS        
//
// extract distributed rc or rcc netlist :
//-----------------------------------------
//     location : rlocation = res loc 
//     loop : do not suppress parallel branches
//     source : LAYOUT SOURCE  output format : HSPICE SPF SPEF LSIM
// PEX NETLIST DISTRIBUTED "netout_distr.spi" HSPICE LAYOUT MASK
// PEX NETLIST DISTRIBUTED "netout_distr.spi" HSPICE SOURCE GROUND VSS LOOP LOCATION RLOCATION    SEPARATOR "/"   MASK
// PEX NETLIST DISTRIBUTED "netout_distr.spi" SPECTRE LAYOUT GROUND GND0 LOOP LOCATION RLOCATION RWIDTH RLAYER SEPARATOR "_" MASK
 PEX NETLIST DISTRIBUTED "netout_distr.spi" HSPICE LAYOUT GROUND GND0 LOOP LOCATION RLOCATION RWIDTH RLAYER SEPARATOR "_" MASK
//
   PEX REPORT DISTRIBUTED NONE
//     remove res < value (ohm)
// PEX REDUCE DISTRIBUTED R 5 BRANCH
//    R, D, C  : res, delay, cap : set thresholds constrains on RC - nets
// PEX THRESHOLD R < 10 C < 10
//     pex report distributed is very large : source = LAYOUT SOURCE type = ASII LSIM SDF 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" ASCII LAYOUT 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" ASCII SOURCE 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" SDF SOURCE    
//     only for this nets, must be layout names
//   PEX INCLUDE DISTRIBUTED net1 net2 net3 
//     select nets ( needs -select option)
//   PEX INCLUDE DISTRIBUTED "mynet"        
//     remove nets
   PEX EXCLUDE DISTRIBUTED VDD VSS        
// PEX EXCLUDE DISTRIBUTED "VDD?" "VSS?" "VD33?"
//
// TICER reduction algorithmus ( see MENTOR Doc)
//
   // PEX REDUCE DISTRIBUTED TICER 40e9
   // PEX REDUCE DISTRIBUTED TICER 20e9
//
// PEX COUPLED DISTRIBUTED YES/NO
// PEX DELAY PENFIELD 0.7
// PEX DELAY ELMORE 0.7
// PEX DELAY NONE        
//
////////////////////////////////////////////////////////////////////////////////////
//
//   T e x t   d e f i n i t i o n
//
////////////////////////////////////////////////////////////////////////////////////
//
// define free floating text used from gds2 database
// attention : for soft checking you have to use the same layer number
// for EXPAND TEXT !!!!
//
//  TEXT LAYER 59          
//  text_vdd = (EXPAND TEXT ?VDD? 59 BY 0.1) OR (EXPAND TEXT ?VCC? 59 BY 0.1)
//  text_vss = (EXPAND TEXT ?VSS? 59 BY 0.1) OR (EXPAND TEXT ?GND? 59 BY 0.1)
//  LABEL ORDER MET3 MET2 MET1
//
// ATTACH 59 MET1 MASK
// ATTACH 59 MET2 MASK
// ATTACH 59 MET3 MASK
// 
// define text directly in rule file :
//
//      name                       x (u)        y(U)     layer number (35=met1,37=met2)
//
// text A1                        137.000      121.400   35                    
// text AA                         75.800       67.600   35                    
// text VDDA                       51.200       95.400   35                    
// text VDDA                      100.000      220.800   35                    
// text VDDA                      141.200      306.600   35                    
// text VDDH                      180.800      381.200   35                    
// text VSS                        98.200      309.200   35                    
// text VSS                       166.600       -7.800   35                    
// text VSS                       180.600      390.800   35                    
// text VSS                       293.200      131.400   35                    
//
// include path
// INCLUDE "textfile"
//
// read text from ports
//
// cell number 3 name : BU4
//
//   LAYOUT TEXT A 1.15 16.95 137  BU4
//   LAYOUT TEXT Q 5.75 20.45 137  BU4
//
// cell number 4 name : IN4
//
//   LAYOUT TEXT Q 1.15 16.75 137  IN4
//   LAYOUT TEXT A 5.75 16.75 137  IN4
//
// cell number 5 name : NO2
//
//   LAYOUT TEXT A 1.15 16.55 137  NO2
//   LAYOUT TEXT Q 5.75 16.55 137  NO2
//   LAYOUT TEXT B 3.45 17.65 137  NO2
//
// PORT LAYER TEXT 137
// TEXT LAYER 137
// ATTACH 137 MET2     
// 
///////////////////////////////////////////////////////////////////////
//
//                 end of standard header   
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////
// Owner: austriamicrosystems AG                  //
//        CONCERTO! Business Unit Silicon Foundry //
//================================================//
//        HIT-Kit: Digital                        //
////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  R U L E S   F I L E   F O R   P R O C E S S   C 3 5 
//
//       _rules_title (standalone options)
//
//       Document: ENG-326                      Revision: 1.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//   1.0           14-Jan-2002       aob      Created
//                                            new layer table with
//                                            datatypes/texttypes
//                  6-Feb-2002       aob      bipolar added
//                 22-Feb-2002       aob      port layer text for padpin added
//                  5-Apr-2002       aob      layer definition extend
//                 10-Apr-2002       aob      routingmetal added
//                  2-May-2002       aob      mxnet layer number fixed
//                 12-Jun-2002       aob      layer definition for generated 
//                                            layers extended
//                  5-Jul-2002       aob      text_vdd/vss for ERC modified
//                  2-Aug-2002       aob      layer mapping changed due to
//                                            IC station numbers
//                                            61 = 600, 62 = 700, 63 = 800
//                 20-Aug-2002       aob      primary only for EXPAND txt for ERC
//                 22-Aug-2002       aob      layout:reduced needs text type map
//                                            resdef_text added
//                 27-Sep-2002       aob      inddef_text added
//                 18-Nov-2002       aob      m1pinshape added to mask out floating net
//                  6-Mar-2003       aob      attach met1 routingmet1 ...added
//                 12-Mar-2003       aob      direct connects added
//                 19-May-2003       aob      layer map inddef text to 722
//                 14-Jan-2003       aob      add vbat and vsub to supply text
//                 13-Jul-2004       aob      poly1 pins added
//                 21-Jul-2005       aob      lvt layers added
//                 17-Aug-2005       aob      lvt layer mapping changed
//                 17-Aug-2006       aob      bipolar layer lpplus added to filter info diff
//                                            without impl
//                  9-Feb-2007       aob      add metres extract
//                                            add IPDEF/KEPOUT checks
//                 14-Feb-2007       aob      add photo diode
//                 17-Aug-2007       aob      add HVDEF forn nmos30m
//                 10-Sep-2007       aob      add FIDEF 62 datatype 29 for nmos30m  
//                 
///////////////////////////////////////////////////////////////////////

// List of layers that are defined for the c35 process:
// These layers are original layers with reserved names that cant be
// changed !
// Use the layer number definition for rule file use in standalone mode
//
// Trench isolation layer
   LAYER TRENCH 3
//
// NTUB ... ntub mask (nwell)
   LAYER NTUB 5
// PTUB ... ptub in ntub mask (pwell)
   LAYER PTUB 7
// DIFF ... field mask (diffusion)
   LAYER DIFF 10
// MIDOX 
   LAYER MIDOX 14
// POLY1 ... poly1 mask
   LAYER POLY1 20
// NPLUS ... n+ implant mask
   LAYER NPLUS 23
// PPLUS ... p+ implant mask
   LAYER PPLUS 24
// HRES ... high resistive mask
   LAYER HRES 29
// POLY2 ... poly2 mask
   LAYER POLY2 30
// CONT ... contact mask
   LAYER CONT 34
// MET1 ... metal1 mask
   LAYER MET1 35
// VIA ... via mask
   LAYER VIA 36
// MET2 ... metal2 mask
   LAYER MET2 37
// VIA2 ... via2 mask
   LAYER VIA2 38
// MET3 ... metal3 mask
   LAYER MET3 39
// PAD ... pad mask
   LAYER PAD 40
//===============================
//
   LAYER ESD  31
   LAYER SALEX 32
//
// met4
//-------
   LAYER VIA3 41
//#IFDEF fourmetal
   LAYER MET4 42
//#ENDIF
//
// generated layers
//
// FIMP ... field implant mask
   LAYER FIMP 8
// standard nldd implant
   LAYER NLDD 21
// 5 Volt nldd implant
   LAYER NLDD50 53
//
   LAYER MAP 35 DATATYPE 1 201
   LAYER M1HOLE 201 
//
   LAYER MAP 37 DATATYPE 1 202
   LAYER M2HOLE 202 
//
   LAYER MAP 39 DATATYPE 1 203
   LAYER M3HOLE 203 
//
#IFDEF fourmetal
   LAYER MAP 42 DATATYPE 1 204
   LAYER M4HOLE 204 
#ENDIF
//
// bipolar layers
//-------------------
//
// n+ buried layer
   LAYER NBUR 1
// p+ buried layer
   LAYER PBUDEF  2
// bipolar ntub
   LAYER BNTUB 15
// bipolar ntub2
   LAYER BNTUB2 16
// p+ base poly layer
   LAYER BPOLY 28
// emitter layer
   LAYER EMITT 26
// collector layer
   LAYER COLL  11  
// bipolar hbt open mask
   LAYER HBT 25
// capacitor layer
   LAYER CAPLAY 27
// emitter poly
   LAYER EPOLY 33
// metal cap definition
   LAYER METCAP	55
//
// layer for pldmos
   LAYER LPPLUS 45
//
// hv layers
//------------
//
   LAYER HVDEF 13
//
// LVT layers
//-------------
//
   LAYER MAP 62 DATATYPE 28  728
   LAYER LVTDEF  728
//
// LVTA
   LAYER LVTA  46
//
// LVPTUB
   LAYER LVPTUB  47
// 
// definition layers
//--------------------
//
// cell box outline
   LAYER MAP 62 DATATYPE 1  701
   LAYER CELBOX  701 
// standard family cell definition
   LAYER MAP 62 DATATYPE 2  702
   LAYER SFCDEF  702 
// GND substrate definition layer
   LAYER MAP 62 DATATYPE 3  703
   LAYER SUBDEF  703
// hottub definition layer
   LAYER MAP 62 DATATYPE 4  704
   LAYER HOTTUB  704
// nofill with fill pattern
   LAYER MAP 62 DATATYPE 5  705
   LAYER NOFILL  705
//
// ipdef
   LAYER MAP 62 DATATYPE 6  706
   LAYER IPDEF   706
// kepout
   LAYER MAP 62 DATATYPE 7  707
   LAYER KEPOUT  707
// zener diode
//
// zener diode
   LAYER MAP 62 DATATYPE 10  710
   LAYER ZENER  710
// diode
   LAYER MAP 62 DATATYPE 11  711
   LAYER DIODE  711
// ntub resistor definition
   LAYER MAP 62 DATATYPE 12  712
   LAYER TUBDEF  712
// resistor definition
   LAYER MAP 62 DATATYPE 13  713
   LAYER RESDEF  713
// resistor terminal
   LAYER MAP 62 DATATYPE 14  714
   LAYER RESTRM  714
// met resistor definition
   LAYER MAP 62 DATATYPE 15  715
   LAYER METRES  715
// sandwich cap definition
   LAYER MAP 62 DATATYPE 20  720
   LAYER CAPDEF  720
// varactor definition layer
   LAYER MAP 62 DATATYPE 21  721
   LAYER VARDUM  721
// Inductor definition layer
   LAYER MAP 62 DATATYPE 22  722
   LAYER INDDEF  722
// hall definition layer
   LAYER MAP 62 DATATYPE 24  724
   LAYER HALLDEF  724
// diffusion cut
   LAYER MAP 62 DATATYPE 30  730
   LAYER DIFCUT  730
// poly1 cut
   LAYER MAP 62 DATATYPE 31  731
   LAYER PO1CUT  731
// poly2 cut
   LAYER MAP 62 DATATYPE 32  732
   LAYER PO2CUT  732
// base poly cut
   LAYER MAP 62 DATATYPE 33  733
   LAYER BPCUT  733
// tub cut
   LAYER MAP 62 DATATYPE 34  734
   LAYER TUBCUT  734
// RF definition layer
   LAYER MAP 62 DATATYPE 26  726
   LAYER RFDEF  726
// probe pad definition
   LAYER MAP 62 DATATYPE 27  727
   LAYER PROBE  727
//
// photo def layer layer
   LAYER MAP 62 DATATYPE 40  740
   LAYER OPTDEF  740
// definition layer for fimp in nmos30m
   LAYER MAP 62 DATATYPE 29  741
   LAYER FIDEF  741
//
// text layer       
//-------------
//
// for hv  definition
   LAYER MAP 13 TEXTTYPE 0 13
   LAYER HVDEF_TEXT 13
//
// light pin of photo diode
//
   TEXT LAYER OPTDEF_TEXT
   PORT LAYER TEXT OPTDEF_TEXT
   ATTACH OPTDEF_TEXT OPTDEF  MASK
//
   LAYER MAP 61 TEXTTYPE 1  601
   LAYER P1PIN  601
   TEXT LAYER P1PIN
   PORT LAYER TEXT P1PIN
   ATTACH P1PIN routingpoly MASK
//
// GDT debug
   // LAYER MAP 60 TEXTTYPE 0  602
   LAYER MAP 61 TEXTTYPE 2  602
   LAYER M1PIN  602
   TEXT LAYER M1PIN
   PORT LAYER TEXT M1PIN
   ATTACH M1PIN routingmet1 MASK
   ATTACH M1PIN MET1 DIRECT
//
   LAYER MAP 61 TEXTTYPE 3  603
   LAYER M2PIN  603
   TEXT LAYER M2PIN
   PORT LAYER TEXT M2PIN
   ATTACH M2PIN routingmet2 MASK
   ATTACH M2PIN MET2 DIRECT     
//
   LAYER MAP 61 TEXTTYPE 4  604
   LAYER M3PIN  604
   TEXT LAYER M3PIN
   PORT LAYER TEXT M3PIN
   ATTACH M3PIN routingmet3 MASK
   ATTACH M3PIN MET3 DIRECT
//
   LAYER MAP 61 TEXTTYPE 10  610
   LAYER PADPIN  610
   PORT LAYER TEXT PADPIN
   TEXT LAYER PADPIN
//
#IFDEF fourmetal
// 4 metal attach to met4
   LAYER MAP 61 TEXTTYPE 5  605
   LAYER M4PIN  605
   TEXT LAYER M4PIN
   PORT LAYER TEXT M4PIN
   ATTACH M4PIN routingmet4 MASK
   ATTACH PADPIN routingmet4 MASK
   ATTACH M4PIN MET4 DIRECT     
   ATTACH PADPIN MET4 DIRECT     
#ELSE
// 3 metal attach to met3
   ATTACH PADPIN routingmet3 MASK
   ATTACH PADPIN MET3 DIRECT      
#ENDIF
//
// this is used for soft checks ERC
// make sure only text on top cell is used to avoid any problems with text in cell
//
// VDD net (vdd,vcc,vbat)
//
   text_vdd_a = (EXPAND TEXT "?VDD?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VCC?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VBAT?" M1PIN  BY 0.1 PRIMARY ONLY))
   text_vdd_b = (EXPAND TEXT "?VDD?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VCC?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VBAT?" M2PIN  BY 0.1 PRIMARY ONLY))
   text_vdd_c = (EXPAND TEXT "?VDD?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VCC?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VBAT?" M3PIN  BY 0.1 PRIMARY ONLY))
   text_vdd = ( text_vdd_a OR text_vdd_b ) OR text_vdd_c
//
// VSS (vss,gnd,vee,vsub, no agnd)
//
   text_vss_a = (EXPAND TEXT "?VSS?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VEE?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VSUB?" M1PIN  BY 0.1 PRIMARY ONLY)))
   text_vss_b = (EXPAND TEXT "?VSS?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VEE?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VSUB?" M2PIN  BY 0.1 PRIMARY ONLY)))
   text_vss_c = (EXPAND TEXT "?VSS?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?VEE?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VSUB?" M3PIN  BY 0.1 PRIMARY ONLY)))
// remove agnd
   text_agnd = (EXPAND TEXT "AGND" M1PIN BY 0.1 PRIMARY ONLY) OR
               ((EXPAND TEXT "AGND" M2PIN BY 0.1 PRIMARY ONLY) OR
               (EXPAND TEXT "AGND" M3PIN BY 0.1 PRIMARY ONLY))
   text_vss = (( text_vss_a OR text_vss_b ) OR text_vss_c) NOT text_agnd
//
   LAYER MAP 61 TEXTTYPE 21  621
   LAYER P1NET  621
//
   LAYER MAP 61 TEXTTYPE 22  622
   LAYER M1NET  622
   TEXT LAYER M1NET
   ATTACH M1NET routingmet1 MASK
   ATTACH M1NET MET1 DIRECT     
//
   LAYER MAP 61 TEXTTYPE 23  623
   LAYER M2NET  623
   TEXT LAYER M2NET
   ATTACH M2NET routingmet2 MASK
   ATTACH M2NET MET2 DIRECT      
//
   LAYER MAP 61 TEXTTYPE 24  624
   LAYER M3NET  624
   TEXT LAYER M3NET
   ATTACH M3NET routingmet3 MASK
   ATTACH M3NET MET3 DIRECT      
//
#IFDEF fourmetal
   LAYER MAP 61 TEXTTYPE 25  625
   LAYER M4NET  625
   TEXT LAYER M4NET
   ATTACH M4NET routingmet4 MASK
   ATTACH M4NET MET4 DIRECT     
#ENDIF
//
   LAYER MAP 61 TEXTTYPE 30  630
   LAYER PADNET  630
   LAYER MAP 61 TEXTTYPE 31  631
   LAYER COMMEN  631
//
   LAYER MAP 63 TEXTTYPE 1  801
   LAYER CESIG1  801
   LAYER MAP 63 TEXTTYPE 2  802
   LAYER CESIG2  802
   LAYER MAP 63 TEXTTYPE 3  803
   LAYER CESIG3  803
   LAYER MAP 63 TEXTTYPE 4  804
   LAYER CESIG4  804
//
   LAYER MAP 63 TEXTTYPE 21  821
   LAYER CEPWR1  821
   LAYER MAP 63 TEXTTYPE 22  822
   LAYER CEPWR2  822
   LAYER MAP 63 TEXTTYPE 23  823
   LAYER CEPWR3  823
   LAYER MAP 63 TEXTTYPE 24  824
   LAYER CEPWR4  824
//
   LAYER MAP 62 TEXTTYPE 13  913
   LAYER RESDEF_TEXT  913
//
// for spiral recognition
// Inductor definition layer
//
   LAYER MAP 62 TEXTTYPE 22  722
   LAYER INDDEF_TEXT  722
//
// for hall definition
   LAYER MAP 62 TEXTTYPE 24  724
   LAYER HALLDEF_TEXT  724
//
// for rfpad recognition
   LAYER MAP 62 TEXTTYPE 26  726
   LAYER RFDEF_TEXT  726
//
   LAYER MAP 62 TEXTTYPE 40  1740
   LAYER OPTDEF_TEXT 1740
//
// mask out floating met1 
   LAYER MAP 61 DATATYPE 2  923
   LAYER M1PINSHAPE 923
//
//
   ATTACH MET1 routingmet1 MASK //ghe
   ATTACH MET2 routingmet2 MASK //ghe
   ATTACH MET3 routingmet3 MASK //ghe
#IFDEF fourmetal
   ATTACH MET4 routingmet4 MASK //ghe
#ENDIF
//
// for text debugging use following DRC :
//
// check if any text is on mapped textype
//
// M1PIN_TEXT  { EXPAND TEXT "?" M1PIN BY 0.1  }
// M2PIN_TEXT  { EXPAND TEXT "?" M2PIN BY 0.1  }
// M3PIN_TEXT  { EXPAND TEXT "?" M3PIN BY 0.1  }
// PADPIN_TEXT { EXPAND TEXT "?" PADPIN BY 0.1 }
//
// M3PIN_VDD { EXPAND TEXT "VDD" M3PIN BY 0.1 }
// NWELL_VDD { NET routingnwell "VDD" }
// M3PINP_VDD { routingmet3 WITH TEXT "VDD" M3PIN }
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////
// Owner: Austria Mikro Systeme   //
// HIT-Kit: Digital               //
////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
//       _rules_title
//
//       Document: ENG-326                      Revision: 1.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
//                 17-Jan-2002       aob      used for c35b4        
//                 28-Jan-2002       aob      rpolyhcon is poly2con
//                                            met4 connectivity added
//                  7-Feb-2002       aob      rpolyh added
//                 19-Feb-2002       aob      cvar added
//                 26-Mar-2002       aob      slot checks added
//                 10-Apr-2002       aob      spirals added
//                                            routingmetal added, 
//                                            connectivity changed
//                 16-Apr-2002       aob      unused parts removed
//                 25-Apr-2002       aob      rpolyh without resdef 
//                                            vert15 removed
//                                            nwd = AND
//                 13-Mai-2002       aob      ndiode/pdiode not s/d diff
//                 21-May-2002       aob      slot check modified for AMC2
//                 24-May-2002       aob      rec017 added
//                                            only slots < 4 U width checked
//                 13-Jun-2002       aob      cvar extract changed
//                 22-Jul-2002       aob      ndiffcon/pdiffcon used   
//                 27-Sep-2002       aob      spirals met3/met4 added
//                 30-Sep-2002       aob      do not allow layer under spiral 
//                 17-Oct-2002       aob      pnpvert10 sizing reduced
//                 13-Jan-2003       aob      aux layer DIFF nmos4/pmos4 changed
//                  6-Mar-2003       aob      nwdiode shield added
//                 11-Mar-2003       aob      trans_shield added
//                 14-May-2003       aob      isolated layout nets LVS spirals
//                                            terminals fixed
//                 16-Jun-2003       aob      hall element added
//                 17-Jun-2003       aob      z diode with 0.2 U impl ovlp only
//                 15-Jul-2003       aob      element rules added, pnplat2 changed
//                                            devswitch added
//                 21-Aug-2003       aob      allow rpoly2 over rnwell
//
//                 12-May-2004  aob   RFDEF added,cpolyrf,nmosrf,pmosrf,rpoly2rf
//                                    Attention : device layer is RFDEF
//                                    enclosing device ( for XRC )
//                                    property split up, m Factor for mos
//                                    Important : cap/rpoly2 rules must be
//                                    checked for rf also..
//                                    Element rules added
//                                    rfpad, probepad added
//                   ATTENTION : rf pad is extracted, but DRC error give, not supported yet
//                                    cvar must have RFDEF layer (DRC error)
//
//                 16-Jul-2004  aob   70 x 70 U is bond pad
//                 22-Jul-2004  aob   non standard cvar is extracted as single
//                                    device with w/l and DRC Warning
//                 15-Jun-2005  aob   rpolyhrf added
//                 20-Jul-2005  aob   rblocking for pex rf devices added 
//                                    c35b3l3 lvt devcices added
//                  9-Aug-2005  aob   nmoshl4, nmosmhl4 added
//                  2-Dec-2005  aob   vert10 rectangle added
//                 16-Mar-2005  aob   rpoly1 added(dev extract, DRC ...)
//                                    rfpad extract modified (same as s35)
//                 30-May-2006  aob   cmim added ( c35A4l5 , c35B4M6)
//                  3-Aug-2006  aob   polynet fixed
//                  8-Feb-2007  aob   Doc rev 6 implemented
//                                    metres, ipdef, kepout
//                 13-Feb-2007  aob   photo diode added (phdnwa850)
//                                    c35b4o1/c35b3o1 process options and 
//                                    nwell shield added
//                 10-Sep-2007  aob   add nmos30m/nmos30t device
//                 15-Jul-2008  aob   filter nmosh with HVDEF to avoid false extract ZMLA
//
///////////////////////////////////////////////////////////////////////
//
//   Structure of this technology file:
//---------------------------------------------------------------------
//
//   1.) Header and version control
//   2.) ICverify options
//   3.) Boolean operations and derived layers
//   4.) Interconnect section
//     
//       Including files for:
//
//   5.) Device recognition
//   6.) Design rules
//   7.) Parasitic extraction
//   8.) Standalone options
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
//   Derived Layers are defined to find the following devices
//---------------------------------------------------------------------
//
//   EX 1 - metres, metrpoly1, rpoly2, rpoly2rf, rpolyh, rpolyhrf, rdiffn, rdiffp, rnwell
//   EX 2 - pnpvert, pnplat2
//   EX 3 - nmosh, nmos4, pmos4
//   EX 4 - cpoly, cpolyrf, cvar, cmim
//   EX 5 - nd, pd, nwd, zdiode, photo
//   EX 6 - nmos30m/nmos30t
//          spirals
//          rf devices
//          lvt devices ( 6 )
//
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
//                         ICVERIFY OPTIONS                          //
///////////////////////////////////////////////////////////////////////


   PRECISION 1000
   RESOLUTION 50

   UNIT RESISTANCE ohm
   UNIT CAPACITANCE ff

   DRC TOLERANCE FACTOR 0.005

//=====================================================================

///////////////////////////////////////////////////////////////////////
//                       DEFINE BOOLEAN LAYERS                       //
///////////////////////////////////////////////////////////////////////
//
// write device seed layer to DRC output for debugging
//
// #DEFINE DEVSWITCH
#UNDEFINE DEVSWITCH

#IFDEF fourmetal
   LAYOUT TOP LAYER MET4 VIA3 MET3 VIA2 MET2 VIA MET1
#ELSE
   LAYOUT TOP LAYER MET3 VIA2 MET2 VIA MET1
#ENDIF
//
// MENTOR recommendation
//
   LAYOUT BASE LAYER NTUB DIFF NPLUS PPLUS HRES MIDOX POLY1 POLY2 CONT
//
//=====================================================================
// create layers to find substrate

// for test purposes
// POLYGON -10.0 -10.0 221.0 240.0 SUBDEF
// cut nwell if subdef edge cuts ntub, but do
// not cut substrate below ntub
// create a small area of subdef

   subdef_ring    = SUBDEF NOT (SIZE SUBDEF BY -0.05)
   substrate_all  = EXTENT

   ntub_subdefcut = NTUB NOT subdef_ring
   substrate      = (substrate_all NOT subdef_ring) OR (subdef_ring AND NTUB)

   psub           = substrate NOT NTUB

//=====================================================================
// remove cut layer areas

   diff_cut         = DIFF NOT DIFCUT
   poly1_cut        = POLY1 NOT PO1CUT
   poly2_cut        = POLY2 NOT PO2CUT


//=====================================================================
// get contacts

// poly1 and poly2 contacts

   poly1_n_poly2    = poly1_cut NOT poly2_cut
   poly1con_all     = CONT AND poly1_n_poly2
   con_n_p1         = CONT NOT poly1con_all
   poly2con_all     = CONT AND poly2_cut   

// other contacts
// rpolyh is poly2
//
   rpolyhcon        = poly2con_all AND HRES
   diffcon_all      = CONT AND diff_cut
//
// for ERC
//
   via_cont         = VIA OR CONT
   via2_via         = VIA2 OR VIA
#IFDEF fourmetal
   via3_via2        = VIA3 OR VIA2
#ELSE
   via3_via2        = COPY VIA2
#ENDIF


//=====================================================================
// create layers to find ndiff and pdiff structures

   ndiff_1          = diff_cut AND NPLUS
   pdiff_1          = diff_cut AND PPLUS


//=====================================================================
// EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  
//=====================================================================
// create layers to find rpoly1, poly2, polyh, ndiff, pdiff and nwell resistors

   poly1_poly2      = POLY1 AND POLY2
//
// poly1 resistor

   pres1_1           = (poly1_cut AND RESDEF) NOT HRES
   pres1_2           = pres1_1 NOT poly1_poly2
   pres1             = pres1_2 NOT RESTRM

// poly2 resistor

   pres_1           = (poly2_cut AND RESDEF) NOT HRES
   pres_2           = pres_1 NOT poly1_poly2
   pres             = pres_2 NOT RESTRM

// rf device
   pres_rf_device   = RFDEF ENCLOSE pres
//
   pres_norf        = pres   NOT RFDEF

// hrespoly resistor with resdef, no restrm

   presh_1          = poly2_cut AND HRES
// presh            = (presh_1 NOT PPLUS) AND RESDEF
   presh            = presh_1 NOT PPLUS
   preshterm        = presh_1 AND PPLUS
//
   presh_norf       = presh NOT RFDEF
   presh_rf_device  = RFDEF ENCLOSE presh

// pdiff resistor
 
   pdres_1          = pdiff_1 AND RESDEF
   pdres_2          = pdres_1 NOT INTERACT pres
   pdres            = pdres_2 NOT RESTRM

// ndiff resistor

   ndres_1          = ndiff_1 AND RESDEF
   ndres_2          = ndres_1 NOT INTERACT pres
   ndres            = ndres_2 NOT RESTRM

// nwell resistor

   nwres_1          = NTUB AND TUBDEF
   nwres_2          = nwres_1 NOT INTERACT pdres
   nwres_3          = nwres_2 NOT INTERACT ndres
   nwres            = nwres_3 NOT RESTRM

#IFDEF DEVSWITCH
  xrpoly1 { COPY pres1 }
  xrpoly2   { COPY pres_norf }
  xrpoly2rf { COPY pres_rf_device }
  xrpolyh { COPY presh_norf }
  xrpolyhrf  { COPY presh_rf_device }
  xrdiffp { COPY pdres }
  xrdiffn { COPY ndres }
  xrnwell { COPY nwres }
#ENDIF

//=====================================================================
// create layers to find poly1, poly2 and nwell structures not belonging
// to a resistor

   routingpoly_all  = poly1_cut NOT pres1
   routingpoly2_1   = poly2_cut NOT pres
   routingpoly2_all = routingpoly2_1 NOT presh
//
// cut ntub if subdef crosses ntub
// remove isolated ntub stripes in spirals 
// and cut nwell in hall element
//
   routingnwell  = ((ntub_subdefcut NOT nwres) NOT INDDEF) NOT halldef_cut

//=====================================================================
// create layers to find ndiff and pdiff structures not belonging
// to a resistor or any gate structure

   ndiff_2          = ndiff_1 NOT routingpoly_all
   ndiff            = ndiff_2 NOT ndres

   pdiff_2          = pdiff_1 NOT routingpoly_all
   pdiff            = pdiff_2 NOT pdres


//=====================================================================
// create layers to find gate structures of n- and p- low voltage 
// devices and nmosh (NTUB version)

   trans            = diff_cut AND routingpoly_all
// for XCALI 
   trans_shield     = SIZE trans BY 0.01
   ngate            = trans NOT NTUB
   pgate            = trans AND NTUB
   gate             = ngate OR pgate
//
// filter zmla nmos30m/nmos30t
//
   ndev             = (ngate AND NPLUS) NOT HVDEF
   pdev             = pgate AND PPLUS


//=====================================================================
// EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  
//=====================================================================
// create layers to find pnpvert and pnplat2 bipolar transistors

// pnpvert (vert10 - pnp vertical bipolar transistor - 10um * 10um)

   pnpvert_1        = HOLES pdiff < 1000.0
// filter too large holes
   pnpvert_2        = NTUB INSIDE pnpvert_1
   pnpvert_3        = ndiff AND pnpvert_2
   pnpvert_4        = HOLES pnpvert_3
   pnpvert_5        = pdiff INSIDE pnpvert_4
   pnpvert10_e_1    = PERIMETER pnpvert_5 >39.9 < 40.1
// get rid of emi ni square
   pnpvert10_e      = RECTANGLE pnpvert10_e_1 > 9  BY > 9
   pnpvert10        = SIZE pnpvert10_e BY 2.0

// pnplat2 (pnp lateral bipolar transistors)
// lat2 has emitter area 2*2
 
   pnplat           = HOLES pdev < 10.0
//
// pnplat2_e        = PERIMETER pnplat >7.95 <8.05
//
// allow poly1 biasing
   pnplat2_e        = PERIMETER pnplat >7.5 <8.05
   pnplat2_c        = (pdiff TOUCH pnplat2_g) NOT pnplat2_e
   pnplat2_g        = pdev TOUCH pnplat2_e

#IFDEF DEVSWITCH
   xpnplat    { COPY pnplat2_e }
   xpnpvert10 { COPY pnpvert10 }
#ENDIF
//=====================================================================
// create layers to find nwells belonging to illegal hv transistors
// illegal is : ntub touches exactly trans
//              ntub ovlp != 1.6

   nwell_ill        = NTUB TOUCH trans 
   nwell_hv_trans   = NTUB CUT trans
   nwell_hvmos_good = INT nwell_hv_trans trans == 1.6 OPPOSITE PARA ONLY REGION
   ill_hvmos_nwell  = nwell_ill OR (nwell_hv_trans NOT INTERACT nwell_hvmos_good)
   nwell_n_hvmos    = NTUB NOT INTERACT nwell_hvmos_good

//=====================================================================
// EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  
//=====================================================================
// create layers to find mos transistors (pmos, nmos, nmosh)
// midox and lvt devices

   routp_n_trans    = routingpoly_all NOT trans

// pmos transistors
 
   pmos_1           = pdev NOT pnplat2_g
   pmos_2           = pmos_1 TOUCH routp_n_trans
   pmos_3           = pmos_2 TOUCH pdiff == 2
//
   pmos_4           = (pmos_3 NOT MIDOX) NOT LVTDEF
   pmos_midox       = (pmos_3 AND MIDOX) NOT LVTDEF
//
//
   pmos_lvt         = (pmos_3 NOT MIDOX) AND LVTDEF
   pmos_mlvt        = (pmos_3 AND MIDOX) AND LVTDEF
//
   pmos             = pmos_4 NOT RFDEF
   pmosrf_trans     = pmos_4 AND RFDEF
   pmosrf_device_layer = RFDEF ENCLOSE pmosrf_trans
//
// nmosh transistors
// check for touching or ovlp of ntub
//
// filter zmla
//
   nmosh_1          = ((trans TOUCH NTUB) OR (trans CUT NTUB)) NOT HVDEF
   nmosh            = nmosh_1 INTERACT ndev
// 
// avoid false extract   
   nmoshall         = nmosh_1 AND (trans AND NPLUS)
   nmosh_d          = ndiff AND (NTUB INTERACT nmoshall)
   nmosh_d_fill     = EXT nmosh_d nmosh < 6.00 OPPOSITE PARA ONLY
                      REGION
   nmosh_d_term_1   = nmosh_d OR nmosh_d_fill
   nmosh_d_term     = nmosh_d_term_1 TOUCH nmosh

   // nmosmh { COPY nmosmh }
   // nmosh { COPY nmosh_nomidox }
//
   nmosh_nomidox    = (nmosh NOT INTERACT MIDOX) NOT LVTDEF
   nmosmh           = (nmosh INTERACT MIDOX) NOT LVTDEF
//
   nmosh_nomidox_lvt  = (nmosh NOT INTERACT MIDOX) AND LVTDEF
   nmosmh_lvt         = (nmosh INTERACT MIDOX) AND LVTDEF
//

// nmos transistors with and without midox

   nmos_1           = ndev NOT nmosh
   nmos_2           = nmos_1 NOT INTERACT ill_hvmos_nwell
   nmos_3           = nmos_2 TOUCH routp_n_trans
   nmos_4           = nmos_3 TOUCH ndiff == 2
//
   nmos_5           = (nmos_4 NOT MIDOX) NOT LVTDEF
   nmos_midox       = (nmos_4 AND MIDOX) NOT LVTDEF
//
   nmos_lvt         = (nmos_4 NOT MIDOX) AND LVTDEF
   nmos_mlvt        = (nmos_4 AND MIDOX) AND LVTDEF
//
   nmos             = nmos_5 NOT RFDEF
   nmosrf_trans     = nmos_5 AND RFDEF
   nmosrf_device_layer = RFDEF ENCLOSE nmosrf_trans
//
#IFDEF DEVSWITCH
   xnmosh { COPY nmosh_nomidox }
   xnmosmh { COPY nmosmh }
//
   xnmoshl4 { COPY nmosh_nomidox_lvt }
   xnmosmhl4 { COPY nmosmh_lvt }
//
   xnmos { COPY nmos }
   xnmosm { COPY nmos_midox }
   xpmos { COPY pmos }
   xpmosm { COPY pmos_midox }
//
   xnmosrf { COPY nmosrf_device_layer }
   xpmosrf { COPY pmosrf_device_layer }
//
   xnmosl4 { COPY nmos_lvt }
   xnmosml4 { COPY nmos_mlvt   }
   xpmosl4 { COPY pmos_lvt }
   xpmosml4 { COPY pmos_mlvt }
//
#ENDIF

//=====================================================================
// EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  
//=====================================================================
// create layers to find capacitors (poly1-poly2 and cvar)

// poly1-poly2 (cpoly) capacitor

   cpoly_1          = routingpoly_all NOT HRES
   cpoly            = cpoly_1 AND poly2_cut
//
   cpoly_rf_device = RFDEF ENCLOSE cpoly
   cpoly_norf      = cpoly NOT RFDEF
//
#IFDEF DEVSWITCH
  xcpolyrf { COPY cpoly_rf_device }
  xcpoly   { COPY cpoly_norf }
#ENDIF
//
// cvar device is nmos transistor in nwell arranged in 2 dimensional array
// all diff and poly is connected by metal
//
// one device should be : w = 6.6 l = 0.65  col spacing 1.0 row spacing 1.6
//
// get device element
//
// filter nmos30m/t and nmosh
   cvar_ele_0 = (pgate AND NPLUS) NOT INTERACT (nmosh OR HVDEF) 
//
// only small trans is ok, exact value is checked in element part
//
   cvar_ele   = INT cvar_ele_0 < 3 REGION
//
// this is unsupported device
//
   cvar_unsupp_device = cvar_ele_0 NOT cvar_ele
//
   CVAR_CAP_UNSUPPORTED_ELE { @ Device Warning : This ngate in nwell is extracted as single gate cap
                              @ Device Warning : unsupported device, no standard size
        COPY cvar_unsupp_device
   }
//
// get diff polygon and close gaps
   cvar_ndiff = ndiff_1 ENCLOSE cvar_ele
   cvar_ndiff_gap = EXT cvar_ndiff < 1.8 OPPOSITE PARA ONLY REGION
   cvar_ndiff_closed = cvar_ndiff OR cvar_ndiff_gap
// get poly/ndiff intersections
   cvar_ndiff_cross1 = INSIDE EDGE cvar_ndiff_closed (routingpoly_all INTERACT cvar_ele)
   cvar_ndiff_cross = EXPAND EDGE cvar_ndiff_cross1  INSIDE BY 0.1
// cvar_ndiff_cross { COPY cvar_ndiff_cross }

   cvar_device_layer = COPY cvar_ndiff_closed
//
// cvar must have RFDEF for assura RCX
// ok for CALIBRE LVS
//
   CVAR_OLD_VERSION_NO_RFDEF_ELE { @ Device Warning : old version of CVAR
                                   @ new version of CVAR must have RFDEF
                                   @ for correct parasitic extraction
     cvar_device_layer NOT RFDEF
   }
//
#IFDEF DEVSWITCH
   xcvar { COPY cvar_device_layer }
#ENDIF
//=====================================================================
// EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  
//=====================================================================
// create layers to find diodes
// attention : all diodes are created by AND !!!

// nd (ndiff over substrate, no sd of device)

   ndiode_1       = (ndiff NOT NTUB) NOT INTERACT trans
   ndiode         = ndiode_1 AND DIODE
//   ndiode       = ndiode_2 ENCLOSE ndiode_1

// pd (pdiff over nwell, no sd of device)

   pdiode_1       = (pdiff AND NTUB) NOT INTERACT trans
   pdiode         = pdiode_1 AND DIODE
//   pdiode       = pdiode_2 ENCLOSE pdiode_1

// nwd (nwell over substrate0 and photo diode

   nwdiode        = NTUB AND DIODE
//   nwdiode      = nwdiode_1 ENCLOSE NTUB
   nwdiode_shield = SIZE ( nwdiode OR diode_phdnwa850 ) BY 0.1 //ghe
//
///////////////////////////////////////////////////////////////////////

// zdiode (ndiff interact pdiff not belonging to the same net)

   zdiode_1       = pdiff COINCIDENT OUTSIDE EDGE ndiff
   zdiode_2       = zdiode_1 EXPAND EDGE OUTSIDE BY 0.1
   zdiode_3       = pdiff AND ndiff
   zdiode_4       = zdiode_2 OR zdiode_3
   zdiode_5       = pdiff INTERACT zdiode_4
   zdiode_6       = ndiff INTERACT zdiode_4
   zdiode_7       = zdiode_5 OR zdiode_6
   zdiode_8       = zdiode_7 AND ZENER
   zdiode_9       = zdiode_8 ENCLOSE zdiode_7
   zdiode_all     = zdiode_4 AND zdiode_9

// this are all possibe z diodes, but we allow only 0.2 U ovlp
//
   zdiode_02_1 = INT zdiode_all == 0.2 OPPOSITE PARA ONLY REGION
   zdiode_02   = zdiode_all INTERACT zdiode_02_1
   zdiode = COPY zdiode_02_1
//
   ILL_ZDIODE_UNDEFINED { @ Zener diode must have 0.2 implant ovlp
            zdiode_all NOT zdiode_02 
   }
//=====================================================================
//                         photo diode
//=====================================================================
//
// C35B4O1
// CMOS core. cap, 5 Volt, ARC = anti reflecting coating
// diode_phdnwa850 with ARC
// diode_phdnw850 no ARC
//
    diode_phdnwa850 = (NTUB AND ndiff) AND OPTDEF
//
//
#IFDEF DEVSWITCH
   xphdnwa850 { COPY diode_phdnwa850 }
   xndiode  { COPY ndiode }
   xpdiode  { COPY pdiode }
   xnwdiode { COPY nwdiode }
   xzdiode  { COPY zdiode }
#ENDIF

//=====================================================================
//                        nmos30m/nmos30t
//=====================================================================
// ATTENTION : FIMP AND NLDD are NOT drawn on device
//             HVDEF and FIDEF on device
//             FIDEF is identical to FIMP generated in laygen
//
// device description : 2 sources, drain in center
// drain : isolated ndiff in nldd
// gate  : surrounds circular
// source for nmos30 : ndiff polygon building gate ndiff
// bulk : pdiff separated to drain diff
// substrate : any pdiff outside, not attached to device
//
   ndiff_nldd = COPY ndiff 
   nmos30_1 = ( HOLES routingpoly INNER ) ENCLOSE ndiff_nldd
   nmos30_2 = routingpoly TOUCH nmos30_1
//
// gate intersects FIDEF
//
   ndevx    = ngate AND NPLUS
   nmos30_3 = ( ndevx INTERACT nmos30_2 ) CUT FIDEF
//
// extend gate to drain
//
   nmos30_ndiff = ndiff_nldd INSIDE nmos30_1
   nmos30_d_fill = EXT nmos30_ndiff nmos30_3 < 2.5 OPPOSITE PARA ONLY REGION
//
// check if drain found, this is the device
   nmos30_4 = ( nmos30_3 TOUCH nmos30_d_fill) OR nmos30_d_fill
   nmos30_combidiff = nmos30_4 OR (ndiff_nldd TOUCH nmos30_4)
// for l
//
   nmos30_fimp = FIDEF CUT nmos30_combidiff
   nmos30_gate_l = nmos30_3 NOT nmos30_fimp
//
//   nmos30_gate_l { COPY nmos30_gate_l }
//   nmos30_4 { COPY nmos30_4 }
//   nmos30_1 { COPY nmos30_1 }
//   nmos30_3 { COPY nmos30_3 }
//   nmos30_d_fill { COPY nmos30_d_fill }
//
// gate must be enclosed by midox/hvox !!
//
   nmos30_4g = nmos30_4 AND DIFF
   //nmos30h  = nmos30_4 INTERACT (nmos30_4g INSIDE HVOX)
   nmos30m  = nmos30_4 INTERACT (nmos30_4g INSIDE MIDOX)
   //nmos30t   = (nmos30_4 NOT nmos30h) NOT nmos30m
   nmos30t  = nmos30_4 NOT nmos30m
//
// use double device
// device layer is area between 2 sources !!!
//
   nmos30_drain    =  nmos30_ndiff TOUCH nmos30_4
   //nmos30h_double  =  nmos30h OR (nmos30_drain TOUCH nmos30h)
   nmos30m_double  =  nmos30m OR (nmos30_drain TOUCH nmos30m)
   nmos30t_double   =  nmos30t  OR (nmos30_drain TOUCH nmos30t)
//
// use ntub stripes and do gap cloure for ad/pd 
// spacing is 1.6
   nmos30_ntub = SIZE( NTUB INTERACT nmos30_4) BY 0.9 OVERUNDER
//
#IFDEF DEVSWITCH
   //xnmos30h { COPY nmos30th_double }
   xnmos30m { COPY nmos30m_double }
   xnmos30t { COPY nmos30t_double }
#ENDIF
//
//=====================================================================
//=====================================================================
//=====================================================================
// create layers to separate n- and p-diffusion contacts

   ndiffcon       = ndiff_1 AND CONT
   pdiffcon       = pdiff_1 AND CONT

//=====================================================================
// create layers to seperate zdiode nplus and pplus areas from other
// nplus and pplus areas

   nplus_n_zener    = NPLUS NOT ZENER
   pplus_n_zener    = PPLUS NOT ZENER

//=====================================================================
// create layers to find diffusion outside zdiodes and illegal zdiodes

   diff_n_zener     = DIFF NOT ZENER
   ndiff_n_zener    = ndiff NOT ZENER
   pdiff_n_zener    = pdiff NOT ZENER


//=====================================================================
// create layers to find gate structures not belonging to a device

   ncap             = ngate NOT ndev
   pcap             = pgate NOT pdev

//=====================================================================
// create layers to separate test and probe pads (smaller 70*70 U)
// from bond pads - needed for drc
// 70 x 70 is still bondpad
//
   te_pro_pad       = PAD AREA < 4761
   bondpad          = PAD NOT te_pro_pad
   m1_not_bondpad   = routingmet1 NOT ENCLOSE bondpad
   m2_not_bondpad   = routingmet2 NOT ENCLOSE bondpad
   m3_not_bondpad   = routingmet3 NOT ENCLOSE bondpad
#IFDEF fourmetal
   m4_not_bondpad   = routingmet4 NOT ENCLOSE bondpad
#ENDIF
   p1_not_bondpad   = POLY1 NOT ENCLOSE bondpad

//=====================================================================
// create layers needed to check length to width ratio of poly1, nwell
// and hrespoly resistors

// poly1 resistors

   pres1_w           = pres1 COINCIDENT EDGE RESTRM
   pres1_l           = pres1 NOT COINCIDENT EDGE RESTRM
   pres1_wexp        = pres1_w EXPAND EDGE OUTSIDE BY 0.1
   pres1_lexp        = pres1_l EXPAND EDGE OUTSIDE BY 0.1
   pres1_exp         = SIZE pres1 BY 0.1
   pres1_exp_net     = COPY pres1_exp
   CONNECT pres1_exp_net 
   //pres1_exp_net     = POLYNET pres1_exp
   pres1_wexp_net    = STAMP pres1_wexp BY pres1_exp_net
   pres1_lexp_net    = STAMP pres1_lexp BY pres1_exp_net

// poly2 resistors

   pres_w           = pres COINCIDENT EDGE RESTRM
   pres_l           = pres NOT COINCIDENT EDGE RESTRM
   pres_wexp        = pres_w EXPAND EDGE OUTSIDE BY 0.1
   pres_lexp        = pres_l EXPAND EDGE OUTSIDE BY 0.1
   pres_exp         = SIZE pres BY 0.1
   pres_exp_net     = COPY    pres_exp
   CONNECT pres_exp_net
   //pres_exp_net     = POLYNET pres_exp
   pres_wexp_net    = STAMP pres_wexp BY pres_exp_net
   pres_lexp_net    = STAMP pres_lexp BY pres_exp_net

// nwell resistors

   nwres_w          = nwres COINCIDENT EDGE RESTRM
   nwres_l          = nwres NOT COINCIDENT EDGE RESTRM
   nwres_wexp       = nwres_w EXPAND EDGE OUTSIDE BY 0.1
   nwres_lexp       = nwres_l EXPAND EDGE OUTSIDE BY 0.1
   nwres_exp        = SIZE nwres BY 0.1
   nwres_exp_net    = COPY nwres_exp
   CONNECT nwres_exp_net
   //nwres_exp_net    = POLYNET nwres_exp
   nwres_wexp_net   = STAMP nwres_wexp BY nwres_exp_net
   nwres_lexp_net   = STAMP nwres_lexp BY nwres_exp_net

// hrespoly resistors

   presh_w          = presh COINCIDENT EDGE preshterm
   presh_l          = presh NOT COINCIDENT EDGE preshterm
   presh_wexp       = presh_w EXPAND EDGE OUTSIDE BY 0.1
   presh_lexp       = presh_l EXPAND EDGE OUTSIDE BY 0.1
   presh_exp        = SIZE presh BY 0.1
   presh_exp_net    = COPY presh_exp
   CONNECT presh_exp_net 
   //presh_exp_net    = POLYNET presh_exp
   presh_wexp_net   = STAMP presh_wexp BY presh_exp_net
   presh_lexp_net   = STAMP presh_lexp BY presh_exp_net


//=====================================================================
// create layers to separate resistors with 45 and 90 degree corners

// poly1 resistors

   pres145_1         = ANGLE pres1 == 45
   pres145           = pres145_1 EXPAND EDGE INSIDE BY 0.1

// poly2 resistors

   pres45_1         = ANGLE pres == 45
   pres45           = pres45_1 EXPAND EDGE INSIDE BY 0.1

// hrespoly resistors

   presh45_1        = ANGLE presh == 45
   presh45          = presh45_1 EXPAND EDGE INSIDE BY 0.1

// ndiff resistors

   ndres45_1        = ANGLE ndres == 45
   ndres45          = ndres45_1 EXPAND EDGE INSIDE BY 0.1

// pdiff resistors

   pdres45_1        = ANGLE pdres == 45
   pdres45          = pdres45_1 EXPAND EDGE INSIDE BY 0.1

// nwell resistors

   nwres45_1         = ANGLE nwres == 45
   nwres45           = nwres45_1 EXPAND EDGE INSIDE BY 0.1


//=====================================================================
// create layers for single layer space notch checks

   poly1check      = POLY1 NOT COINCIDENT EDGE pres145

   poly2check      = POLY2 NOT COINCIDENT EDGE pres45
   poly2hcheck     = presh_1 NOT COINCIDENT EDGE presh45

   diffcheck_1      = DIFF INTERACT RESDEF
   diffcheck_2      = diffcheck_1 NOT RESDEF
   diffcheck_3      = DIFF NOT diffcheck_2
   diffcheck_4      = diffcheck_3 NOT COINCIDENT EDGE ndres45
   diffcheck        = diffcheck_4 NOT COINCIDENT EDGE pdres45

   ntubcheck        = NTUB NOT COINCIDENT EDGE nwres45

//=====================================================================
// create layers for ndiff - nwell checks

// filter ZMLA
//
   ndiff_n_nmosh    = ndiff_1 NOT INTERACT (nmosh OR HVDEF)

//=====================================================================
// create layers for slot rule checks

   met1_withslots  = MET1 NOT M1HOLE
   met2_withslots  = MET2 NOT M2HOLE
   met3_withslots  = MET3 NOT M3HOLE
#IFDEF fourmetal
   met4_withslots  = MET4 NOT M4HOLE
#ENDIF

//=====================================================================
// extract metal resistors and remove from connectivity
//
// RMET1
//
   rmet1_1 = met1_withslots AND METRES
   rmet1_trm =  ((SIZE rmet1_1 BY 0.1) NOT rmet1_1) AND met1_withslots
   rmet1_2 = RECTANGLE rmet1_1
   //rmet1_2 = RECTANGLE rmet1_1 ASPECT == 1
   RMET1_NO_SQUARE_INFO { @ Info : MET1 resistors (shorts) preferred to be square
      rmet1_1 NOT rmet1_2
   }
// does not cut met correctly
   RMET1_BAD_METRES_SHAPE { @ Error: MET1 bad resistors def layer
       rmet1_2 TOUCH rmet1_trm !=2
       NOT RECTANGLE rmet1_1
   }
   rmet1_device =  rmet1_2 TOUCH rmet1_trm ==2
//
// RMET2
//
   rmet2_1 = met2_withslots AND METRES
   rmet2_trm =  ((SIZE rmet2_1 BY 0.1) NOT rmet2_1) AND met2_withslots
   rmet2_2 = RECTANGLE rmet2_1
   //rmet2_2 = RECTANGLE rmet2_1 ASPECT == 1
   RMET2_NO_SQUARE_INFO { @ Info : MET2 resistors (shorts) preferred to be square
      rmet2_1 NOT rmet2_2
   }
// does not cut met correctly
   RMET2_BAD_METRES_SHAPE { @ Error: MET2 bad resistors def layer
       rmet2_2 TOUCH rmet2_trm !=2
       NOT RECTANGLE rmet2_1
   }
   rmet2_device =  rmet2_2 TOUCH rmet2_trm ==2
//
// RMET3
//
   rmet3_1 = met3_withslots AND METRES
   rmet3_trm =  ((SIZE rmet3_1 BY 0.1) NOT rmet3_1) AND met3_withslots
   rmet3_2 = RECTANGLE rmet3_1
   //rmet3_2 = RECTANGLE rmet3_1 ASPECT == 1
   RMET3_NO_SQUARE_INFO { @ Info : MET3 resistors (shorts) preferred to be square
      rmet3_1 NOT rmet3_2
   }
// does not cut met correctly
   RMET3_BAD_METRES_SHAPE { @ Error: MET3 bad resistors def layer
       rmet3_2 TOUCH rmet3_trm !=2
       NOT RECTANGLE rmet3_1
   }
   rmet3_device =  rmet3_2 TOUCH rmet3_trm ==2
//
#IFDEF fourmetal
//
// RMET4
//
   rmet4_1 = met4_withslots AND METRES
   rmet4_trm =  ((SIZE rmet4_1 BY 0.1) NOT rmet4_1) AND met4_withslots
   rmet4_2 = RECTANGLE rmet4_1
   //rmet4_2 = RECTANGLE rmet4_1 ASPECT == 1
   RMET4_NO_SQUARE_INFO { @ Info : MET4 resistors (shorts) preferred to be square
      rmet4_1 NOT rmet4_2
   }
// does not cut met correctly
   RMET4_BAD_METRES_SHAPE { @ Error: MET4 bad resistors def layer
       rmet4_2 TOUCH rmet4_trm !=2
       NOT RECTANGLE rmet4_1
   }
   rmet4_device =  rmet4_2 TOUCH rmet4_trm ==2
//
#IFDEF DEVSWITCH
   rmet4_device { COPY rmet4_device }
#ENDIF
#ENDIF
//
#IFDEF DEVSWITCH
   rmet1_device { COPY rmet1_device }
   rmet2_device { COPY rmet2_device }
   rmet3_device { COPY rmet3_device }
#ENDIF

//=====================================================================
// create other layers needed for drc and connectivity

// for erc

   p1_or_p2         = POLY1 OR POLY2
   diff_or_poly     = DIFF OR p1_or_p2
   implant          = NPLUS OR PPLUS

// substrate taps

   welltap          = ndiff AND routingnwell
   subtap           = pdiff NOT routingnwell

//=====================================================================
//                            RFPAD
//=====================================================================
//
// ATTENTION : NOT SUPPORTED FOR C35 YET
//
// rf pad has 8 verices and  2 diodes left and right, all is covered by rfdef layer
// left is vdd connection, right is vss connection
// text on layer RFDEF
// following model names are availible, but only 2 pad are
// extracted : vddpad and vsspad
//
// RF13_GND_P         RFPADS_4M / padvss als device extrahieren
// RF13_VDD_P         RFPADS_4M / padvdd
// RF26_GND_P
// RF26_VDD_P
// RF40_GND_P
// RF40_VDD_P
// RF52_GND_P
// RF52_VDD_P
// RF13_GND_P_3B      RFPADS_3B_4M / padvss als device extrahieren
// RF13_VDD_P_3B      RFPADS_3B_4M / padvdd
// RF26_GND_P_3B
// RF26_VDD_P_3B
// RF40_GND_P_3B
// RF40_VDD_P_3B
// RF52_GND_P_3B
// RF52_VDD_P_3B
// RF13_GND_C_3B      RFPADSC_3B_4M / padvss als device extrahieren
// RF13_VDD_C_3B      RFPADSC_3B_4M / padvdd
// RF26_GND_C_3B
// RF26_VDD_C_3B
// RF40_GND_C_3B
// RF40_VDD_C_3B
// RF52_GND_C_3B
// RF52_VDD_C_3B
//
   bondpad8 = NOT DONUT( VERTEX bondpad == 8 )
//
   rfpad_good = bondpad8 INSIDE RFDEF
//
// ATTENTION : NOT SUPPORTED FOR C35 YET
//
   ILL_RFPAD_UNSUPPORTED { @ Device Error : RF PAD is not supported yet for this process 
        COPY rfpad_good
   }
//
// old or test rf pad
//
   rfpad_bad = bondpad8 NOT INSIDE RFDEF
//
// use RFDEF layer to get device
   rfpad_device = RFDEF ENCLOSE rfpad_good
//
   rfpad_gnd = rfpad_device INTERACT ( EXPAND TEXT "?_GND_?" RFDEF_TEXT BY 2)
   rfpad_vdd = rfpad_device INTERACT ( EXPAND TEXT "?_VDD_?" RFDEF_TEXT BY 2)
//
//  rfpad_gnd { COPY rfpad_gnd }
//  rfpad_vdd { COPY rfpad_vdd }
//
   rfpad_ndiff = ndiff INSIDE rfpad_device
   rfpad_pdiff = pdiff INSIDE rfpad_device
//
// ndiff and pdiff is connected to pad window
//
   //rfpad_vdd_term_1 = NET AREA RATIO rfpad_pdiff PAD > 0
   //rfpad_vss_term_1 = NET AREA RATIO rfpad_ndiff PAD > 0
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//  remove NAR by polygon tracing
// hier
//
// met 3 connection width is 6 U for rf13 and 26 for rf50
//
   rfpad_met3 =  met3_withslots INTERACT rfpad_device
   rfpad_met3_left_right = INT rfpad_met3 < 26.0 opposite para REGION
//   rfpad_met3_left_right  { FLATTEN rfpad_met3_left_right }
//
   rfpad_met2_lr  = met2_withslots INSIDE rfpad_met3_left_right
   rfpad_met3_vdd = rfpad_met3_left_right ENCLOSE rfpad_met2_lr == 1
   rfpad_met3_vss = rfpad_met3_left_right ENCLOSE rfpad_met2_lr == 2
//
   rfpad_met2_vdd = rfpad_met2_lr INTERACT rfpad_met3_vdd
   rfpad_met2_vss = rfpad_met2_lr INTERACT rfpad_met3_vss
//
//   rfpad_met3_vdd { FLATTEN rfpad_met3_vdd }
//   rfpad_met3_vss { FLATTEN rfpad_met3_vss }
//   rfpad_met2_vdd { FLATTEN  rfpad_met2_vdd }
//   rfpad_met2_vss { FLATTEN  rfpad_met2_vss }
//
// get ndiff/pdiff connected to node outside rfdef
// vdd term is connected with ndiff, vss term with pdiff
// this should have node info
//
   rfpad_vdd_term_1 = rfpad_pdiff INTERACT rfpad_met2_vdd
   rfpad_vss_term_1 = rfpad_ndiff INTERACT rfpad_met2_vss
//
//   rfpad_vdd_term_1 { FLATTEN rfpad_vdd_term_1 }
//   rfpad_vss_term_1 { FLATTEN rfpad_vss_term_1 }
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
//  rfpad_vdd_term { COPY rfpad_vdd_term }
//  rfpad_vss_term { COPY rfpad_vss_term }
//
// get ndiff/pdiff connected to node outside rfdef
// vdd term is connected with ndiff, vss term with pdiff
// this should have node info
//
// ndiff/pdiff spacing
   rfpad_vdd_term_spac = EXT rfpad_vdd_term_1 ndiff < 1.0 PARALLEL OPPOSITE REGION
   rfpad_vdd_term = ndiff INTERACT (rfpad_vdd_term_spac SIZE BY 0.1)
//
   rfpad_vss_term_spac = EXT rfpad_vss_term_1 pdiff < 1.0 PARALLEL OPPOSITE REGION
   rfpad_vss_term = pdiff INTERACT (rfpad_vss_term_spac SIZE BY 0.1)
//
   //rfpad_vdd_term_spac { COPY rfpad_vdd_term_spac }
   //rfpad_vss_term_spac { COPY rfpad_vss_term_spac }
//
#IFDEF DEVSWITCH
   xrfpad_vdd { COPY rfpad_vdd }
   xrfpad_vss { COPY rfpad_gnd }
#ENDIF

//=====================================================================
//                             SPIRALS 
//=====================================================================
//
// Definition : consist of met2/met3/met4 parts, connected by via2/via3
//              INDDEF layer encloses whole spiral
//              model name is text on INDDEF layer
//              RESTRM layer defines connection, must have text P1/P2 !!!
//              if no name is found, but spiral definition is ok, then
//              model name is unknown
//              there are some checks, if spiral is shorted or bad (open)
//              by external metal
// text convention : text is on m3pin for 3 met spirals, on met4 on 4 met spirals
//                   text is placed in restrm rectangle
//
// ATTENTION : 3 met spirals are not allowed in 4 met process
//             met3/met2 is used in c35b3
//             met4/met3 is used in c35b4
//
//  check text on restrms
//
#IFDEF fourmetal
// for text on met4
   spiral_term11 = RESTRM INTERACT (EXPAND TEXT "P1" M4PIN BY 2)
   spiral_term22 = RESTRM INTERACT (EXPAND TEXT "P2" M4PIN BY 2)
#ELSE
// text p1/p2 in m3pin 
   spiral_term11 = RESTRM INTERACT (EXPAND TEXT "P1" M3PIN BY 2)
   spiral_term22 = RESTRM INTERACT (EXPAND TEXT "P2" M3PIN BY 2)
#ENDIF
//
// get spiral terms
//
// metal inside spiral may be met2/3/4
#IFDEF fourmetal
   spiral_met_all = ((MET2 AND INDDEF) OR (MET3 AND INDDEF)) OR (MET4 AND INDDEF)
#ELSE
   spiral_met_all = (MET2 AND INDDEF) OR (MET3 AND INDDEF)
#ENDIF
//
// metal for terminal only met2/3
   spiral_term = ((spiral_term11 OR spiral_term22) AND INDDEF) INTERACT spiral_met_all  
// spiral_inddef
   spiral_inddef = INDDEF INTERACT spiral_term == 2
   spiral_body = spiral_inddef AND spiral_met_all
// spiral_body { COPY spiral_body }
//
   spiral_met3 = spiral_body AND MET3
   spiral_met2 = spiral_body AND MET2
   spiral_via2 = spiral_body AND VIA2
   CONNECT spiral_met3 spiral_met2 BY spiral_via2
#IFDEF fourmetal
   spiral_met4 = spiral_body AND MET4
   spiral_via3 = spiral_body AND VIA3
   CONNECT spiral_met4 spiral_met3 BY spiral_via3
#ENDIF
//
// check connectivity from term1 to term2
// terminal connected to met3 for c35b3 and met4 for c35b4
//
//   BAD_SPIRAL_OPEN_M2 {@ Warning : spiral met2 terminals not connected
//                    spiral_term11s = STAMP spiral_term11 BY spiral_met2
//                    spiral_term22s = STAMP spiral_term22 BY spiral_met2
//                    NET AREA RATIO spiral_term11s spiral_term22s == 0
//                   }
#IFDEF fourmetal
   BAD_SPIRAL_OPEN_M4 {@ Warning : spiral met4 terminals not connected
                    spiral_term11s = STAMP spiral_term11 BY spiral_met4
                    spiral_term22s = STAMP spiral_term22 BY spiral_met4
                    NET AREA RATIO spiral_term11s spiral_term22s == 0
                   }
#ELSE
   BAD_SPIRAL_OPEN_M3 {@ Warning : spiral met3 terminals not connected
                    spiral_term11s = STAMP spiral_term11 BY spiral_met3
                    spiral_term22s = STAMP spiral_term22 BY spiral_met3
                    NET AREA RATIO spiral_term11s spiral_term22s == 0
                   }
#ENDIF
//
// check if any metal creates internal shorts
// which are not found by DRC
//
   BAD_SPIRAL_MET3_INTSHORT {@ ERC Warning : internal spiral met3 short
              HOLES spiral_met3
              }
   BAD_SPIRAL_MET2_INTSHORT {@ ERC Warning : internal spiral met2 short
              HOLES spiral_met2
              }
#IFDEF fourmetal
   BAD_SPIRAL_MET4_INTSHORT {@ ERC Warning : internal spiral met4 short
              HOLES spiral_met4
              }
#ENDIF
//
// any met2/3/ routing metal crosses definition layer ( not on terminal)
//
   BAD_SPIRAL_MET2SHORT {@ ERC Warning : spiral may be shorted to external met2
                   drcerr = EXT spiral_met2 routingmet2 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
   BAD_SPIRAL_MET3SHORT {@ ERC Warning : spiral may be shorted to external met3
                   drcerr = EXT spiral_met3 routingmet3 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
#IFDEF fourmetal
   BAD_SPIRAL_MET4SHORT {@ ERC Warning : spiral may be shorted to external met4
                   drcerr = EXT spiral_met4 routingmet4 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
#ENDIF
//
// check for illegal layer under spiral
// only nwell allowed
//  
   bad_spirlay_1 = INDDEF AND POLY1 
   bad_spirlay_2 = INDDEF AND POLY2 
   bad_spirlay_3 = INDDEF AND DIFF  
   bad_spirlay_4 = INDDEF AND implant
   bad_spirlay_5 = INDDEF AND MET1
   bad_spirlay_6 = INDDEF AND via_cont
   bad_spirlay_all = bad_spirlay_1 OR (bad_spirlay_2 OR (bad_spirlay_3 OR (bad_spirlay_4 OR
                     (bad_spirlay_5 OR bad_spirlay_6))))
#IFDEF fourmetal
   BAD_SPIRAL_ILLEGAL_LAYER {@ ERC Warning : illegal layer below spiral
                             COPY bad_spirlay_all
                             INDDEF AND MET2
                            }
#ELSE
   BAD_SPIRAL_ILLEGAL_LAYER {@ ERC Warning : illegal layer below spiral
                             COPY bad_spirlay_all
                            }
#ENDIF
//
// split different types
//
#IFDEF fourmetal
//
// list of 29 metal4 spirals 
//
   spiral_body_SP014S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP014S300D" INDDEF_TEXT BY 2))
   spiral_body_SP018S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP018S300D" INDDEF_TEXT BY 2))
   spiral_body_SP020S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP020S180D" INDDEF_TEXT BY 2))
   spiral_body_SP023S200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP023S200D" INDDEF_TEXT BY 2))
   spiral_body_SP025C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP025C200D" INDDEF_TEXT BY 2))
   spiral_body_SP026S200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP026S200D" INDDEF_TEXT BY 2))
   spiral_body_SP028S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028S300D" INDDEF_TEXT BY 2))
   spiral_body_SP028C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028C200D" INDDEF_TEXT BY 2))
   spiral_body_SP030C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP030C200D" INDDEF_TEXT BY 2))
   spiral_body_SP037S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP037S180D" INDDEF_TEXT BY 2))
   spiral_body_SP038S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP038S300D" INDDEF_TEXT BY 2))
   spiral_body_SP040C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C200D" INDDEF_TEXT BY 2))
   spiral_body_SP040C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C300D" INDDEF_TEXT BY 2))
   spiral_body_SP045C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP045C200D" INDDEF_TEXT BY 2))
   spiral_body_SP047S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP047S180D" INDDEF_TEXT BY 2))
   spiral_body_SP050S155D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP050S155D" INDDEF_TEXT BY 2))
   spiral_body_SP051C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP051C300D" INDDEF_TEXT BY 2))
   spiral_body_SP068C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP068C300D" INDDEF_TEXT BY 2))
   spiral_body_SP090C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090C200D" INDDEF_TEXT BY 2))
   spiral_body_SP090S155D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090S155D" INDDEF_TEXT BY 2))
   spiral_body_SP112C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP112C300D" INDDEF_TEXT BY 2))
   spiral_body_SP140C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP140C200D" INDDEF_TEXT BY 2))
   spiral_body_SP200C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP200C200D" INDDEF_TEXT BY 2))
//
   spiral_body_SY014C165D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY014C165D" INDDEF_TEXT BY 2))
   spiral_body_SY015C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY015C200D" INDDEF_TEXT BY 2))
   spiral_body_SY016C180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY016C180D" INDDEF_TEXT BY 2))
   spiral_body_SY017C165D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY017C165D" INDDEF_TEXT BY 2))
   spiral_body_SY019C180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY019C180D" INDDEF_TEXT BY 2))
   spiral_body_SY028C160D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY028C160D" INDDEF_TEXT BY 2))
//
// get spiral without text
//
   spnamed_1 =
    spiral_body_SY014C165D     
   OR( spiral_body_SP014S300D    
   OR( spiral_body_SY015C200D    
   OR spiral_body_SY016C180D ))
   spnamed_2 =
    spiral_body_SY017C165D    
   OR( spiral_body_SP018S300D    
   OR( spiral_body_SY019C180D    
   OR( spiral_body_SP020S180D    
   OR spiral_body_SP023S200D )))
   spnamed_3 =
    spiral_body_SP025C200D    
   OR( spiral_body_SP026S200D    
   OR( spiral_body_SY028C160D    
   OR( spiral_body_SP028C200D    
   OR spiral_body_SP028S300D )))
   spnamed_4 =
    spiral_body_SP030C200D   
   OR( spiral_body_SP037S180D    
   OR( spiral_body_SP038S300D    
   OR( spiral_body_SP040C200D    
   OR spiral_body_SP040C300D )))
   spnamed_5 =
    spiral_body_SP045C200D    
   OR( spiral_body_SP047S180D    
   OR( spiral_body_SP050S155D    
   OR( spiral_body_SP051C300D    
   OR spiral_body_SP068C300D )))
   spnamed_6 =
    spiral_body_SP090C200D    
   OR( spiral_body_SP090S155D    
   OR( spiral_body_SP112C300D    
   OR( spiral_body_SP140C200D    
   OR spiral_body_SP200C200D )))
// 
   spiral_body_named = spnamed_1 OR (spnamed_2 OR (spnamed_3 OR (spnamed_4 OR (spnamed_5 OR spnamed_6))))
//
   spiral_body_unknown = spiral_body NOT spiral_body_named
   INFO_UNKNOWN_SPIRAL_NAME {@ ERC Warning : Name of Spiral not identified
                             INDDEF INTERACT spiral_body_unknown
                            }

#ELSE
//
// list of 29 metal3 spirals 
//
   spiral_body_SP014S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP014S300C" INDDEF_TEXT BY 2))
   spiral_body_SP018S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP018S300C" INDDEF_TEXT BY 2))
   spiral_body_SP020S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP020S180C" INDDEF_TEXT BY 2))
   spiral_body_SP023S200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP023S200C" INDDEF_TEXT BY 2))
   spiral_body_SP025C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP025C200C" INDDEF_TEXT BY 2))
   spiral_body_SP026S200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP026S200C" INDDEF_TEXT BY 2))
   spiral_body_SP028S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028S300C" INDDEF_TEXT BY 2))
   spiral_body_SP028C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028C200C" INDDEF_TEXT BY 2))
   spiral_body_SP030C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP030C200C" INDDEF_TEXT BY 2))
   spiral_body_SP037S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP037S180C" INDDEF_TEXT BY 2))
   spiral_body_SP038S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP038S300C" INDDEF_TEXT BY 2))
   spiral_body_SP040C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C200C" INDDEF_TEXT BY 2))
   spiral_body_SP040C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C300C" INDDEF_TEXT BY 2))
   spiral_body_SP045C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP045C200C" INDDEF_TEXT BY 2))
   spiral_body_SP047S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP047S180C" INDDEF_TEXT BY 2))
   spiral_body_SP050S155C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP050S155C" INDDEF_TEXT BY 2))
   spiral_body_SP051C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP051C300C" INDDEF_TEXT BY 2))
   spiral_body_SP068C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP068C300C" INDDEF_TEXT BY 2))
   spiral_body_SP090C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090C200C" INDDEF_TEXT BY 2))
   spiral_body_SP090S155C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090S155C" INDDEF_TEXT BY 2))
   spiral_body_SP112C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP112C300C" INDDEF_TEXT BY 2))
   spiral_body_SP140C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP140C200C" INDDEF_TEXT BY 2))
   spiral_body_SP200C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP200C200C" INDDEF_TEXT BY 2))
//
   spiral_body_SY014C165C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY014C165C" INDDEF_TEXT BY 2))
   spiral_body_SY015C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY015C200C" INDDEF_TEXT BY 2))
   spiral_body_SY016C180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY016C180C" INDDEF_TEXT BY 2))
   spiral_body_SY017C165C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY017C165C" INDDEF_TEXT BY 2))
   spiral_body_SY019C180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY019C180C" INDDEF_TEXT BY 2))
   spiral_body_SY028C160C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY028C160C" INDDEF_TEXT BY 2))
//
// get spiral without text
//
   spnamed_1 =
    spiral_body_SY014C165C     
   OR( spiral_body_SP014S300C    
   OR( spiral_body_SY015C200C    
   OR spiral_body_SY016C180C ))
   spnamed_2 =
    spiral_body_SY017C165C    
   OR( spiral_body_SP018S300C    
   OR( spiral_body_SY019C180C    
   OR( spiral_body_SP020S180C    
   OR spiral_body_SP023S200C )))
   spnamed_3 =
    spiral_body_SP025C200C    
   OR( spiral_body_SP026S200C    
   OR( spiral_body_SY028C160C    
   OR( spiral_body_SP028C200C    
   OR spiral_body_SP028S300C )))
   spnamed_4 =
    spiral_body_SP030C200C   
   OR( spiral_body_SP037S180C    
   OR( spiral_body_SP038S300C    
   OR( spiral_body_SP040C200C    
   OR spiral_body_SP040C300C )))
   spnamed_5 =
    spiral_body_SP045C200C    
   OR( spiral_body_SP047S180C    
   OR( spiral_body_SP050S155C    
   OR( spiral_body_SP051C300C    
   OR spiral_body_SP068C300C )))
   spnamed_6 =
    spiral_body_SP090C200C    
   OR( spiral_body_SP090S155C    
   OR( spiral_body_SP112C300C    
   OR( spiral_body_SP140C200C    
   OR spiral_body_SP200C200C )))
// 
   spiral_body_named = spnamed_1 OR (spnamed_2 OR (spnamed_3 OR (spnamed_4 OR (spnamed_5 OR spnamed_6))))
//
   spiral_body_unknown = spiral_body NOT spiral_body_named
   INFO_UNKNOWN_SPIRAL_NAME {@ ERC Warning : Name of Spiral not identified
                             INDDEF INTERACT spiral_body_unknown
                            }
//
#ENDIF
//
// find any inddef not extracting a correct spiral
// also possible if bad or missing terminal text, wrong process  
//
   BAD_SPIRAL_LAYOUT {@ ERC Warning : INDDEF does not define a correct spiral
                      @               check for name, pin text, process
                        INDDEF NOT INTERACT spiral_body_named
                     }
//
//
#IFDEF DEVSWITCH
//
#IFDEF fourmetal
// met4
//
   xsp014S300D  { INDDEF INTERACT spiral_body_SP014S300D }   
   xsp018S300D  { INDDEF INTERACT spiral_body_SP018S300D }   
   xsp020S180D  { INDDEF INTERACT spiral_body_SP020S180D }   
   xsp023S200D  { INDDEF INTERACT spiral_body_SP023S200D }
   xsp025C200D  { INDDEF INTERACT spiral_body_SP025C200D }   
   xsp026S200D  { INDDEF INTERACT spiral_body_SP026S200D }   
   xsp028C200D  { INDDEF INTERACT spiral_body_SP028C200D }   
   xsp028S300D  { INDDEF INTERACT spiral_body_SP028S300D }
   xsp030C200D  { INDDEF INTERACT spiral_body_SP030C200D }   
   xsp037S180D  { INDDEF INTERACT spiral_body_SP037S180D }   
   xsp038S300D  { INDDEF INTERACT spiral_body_SP038S300D }   
   xsp040C200D  { INDDEF INTERACT spiral_body_SP040C200D }   
   xsp040C300D  { INDDEF INTERACT spiral_body_SP040C300D }
   xsp045C200D  { INDDEF INTERACT spiral_body_SP045C200D }   
   xsp047S180D  { INDDEF INTERACT spiral_body_SP047S180D }   
   xsp050S155D  { INDDEF INTERACT spiral_body_SP050S155D }   
   xsp051C300D  { INDDEF INTERACT spiral_body_SP051C300D }   
   xsp068C300D  { INDDEF INTERACT spiral_body_SP068C300D }
   xsp090C200D  { INDDEF INTERACT spiral_body_SP090C200D }   
   xsp090S155D  { INDDEF INTERACT spiral_body_SP090S155D }   
   xsp112C300D  { INDDEF INTERACT spiral_body_SP112C300D }   
   xsp140C200D  { INDDEF INTERACT spiral_body_SP140C200D }   
   xsp200C200D  { INDDEF INTERACT spiral_body_SP200C200D }
//
   xsy014C165D  { INDDEF INTERACT spiral_body_SY014C165D }    
   xsy015C200D  { INDDEF INTERACT spiral_body_SY015C200D }   
   xsy016C180D  { INDDEF INTERACT spiral_body_SY016C180D }  
   xsy017C165D  { INDDEF INTERACT spiral_body_SY017C165D }   
   xsy019C180D  { INDDEF INTERACT spiral_body_SY019C180D }   
   xsy028C160D  { INDDEF INTERACT spiral_body_SY028C160D }   
#ELSE
//
// met3
//
   xsp014S300C  { INDDEF INTERACT spiral_body_SP014S300C }   
   xsp018S300C  { INDDEF INTERACT spiral_body_SP018S300C }   
   xsp020S180C  { INDDEF INTERACT spiral_body_SP020S180C }   
   xsp023S200C  { INDDEF INTERACT spiral_body_SP023S200C }
   xsp025C200C  { INDDEF INTERACT spiral_body_SP025C200C }   
   xsp026S200C  { INDDEF INTERACT spiral_body_SP026S200C }   
   xsp028C200C  { INDDEF INTERACT spiral_body_SP028C200C }   
   xsp028S300C  { INDDEF INTERACT spiral_body_SP028S300C }
   xsp030C200C  { INDDEF INTERACT spiral_body_SP030C200C }   
   xsp037S180C  { INDDEF INTERACT spiral_body_SP037S180C }   
   xsp038S300C  { INDDEF INTERACT spiral_body_SP038S300C }   
   xsp040C200C  { INDDEF INTERACT spiral_body_SP040C200C }   
   xsp040C300C  { INDDEF INTERACT spiral_body_SP040C300C }
   xsp045C200C  { INDDEF INTERACT spiral_body_SP045C200C }   
   xsp047S180C  { INDDEF INTERACT spiral_body_SP047S180C }   
   xsp050S155C  { INDDEF INTERACT spiral_body_SP050S155C }   
   xsp051C300C  { INDDEF INTERACT spiral_body_SP051C300C }   
   xsp068C300C  { INDDEF INTERACT spiral_body_SP068C300C }
   xsp090C200C  { INDDEF INTERACT spiral_body_SP090C200C }   
   xsp090S155C  { INDDEF INTERACT spiral_body_SP090S155C }   
   xsp112C300C  { INDDEF INTERACT spiral_body_SP112C300C }   
   xsp140C200C  { INDDEF INTERACT spiral_body_SP140C200C }   
   xsp200C200C  { INDDEF INTERACT spiral_body_SP200C200C }
//
   xsy014C165C  { INDDEF INTERACT spiral_body_SY014C165C }    
   xsy015C200C  { INDDEF INTERACT spiral_body_SY015C200C }   
   xsy016C180C  { INDDEF INTERACT spiral_body_SY016C180C }  
   xsy017C165C  { INDDEF INTERACT spiral_body_SY017C165C }   
   xsy019C180C  { INDDEF INTERACT spiral_body_SY019C180C }   
   xsy028C160C  { INDDEF INTERACT spiral_body_SY028C160C }   
#ENDIF

#ENDIF
//
//
//=====================================================================
//                               HALL
//=====================================================================
//
// define a cut layer to open nwell and spiral in hall element
//
// best value for hallc35
   halldef_cut    = SIZE HALLDEF BY -12.0
//
   hall_term_a  = (RESTRM INTERACT (EXPAND TEXT "A" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_b  = (RESTRM INTERACT (EXPAND TEXT "B" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_c  = (RESTRM INTERACT (EXPAND TEXT "C" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_d  = (RESTRM INTERACT (EXPAND TEXT "D" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_s  = (RESTRM INTERACT (EXPAND TEXT "S" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_p1 = (RESTRM INTERACT (EXPAND TEXT "P1" M2PIN BY 2)) INTERACT HALLDEF
   hall_term_p2 = (RESTRM INTERACT (EXPAND TEXT "P2" M2PIN BY 2)) INTERACT HALLDEF
//
   hall_body_HALLC35 = HALLDEF INTERACT (EXPAND TEXT "HALLC35" HALLDEF_TEXT BY 2)
//
#IFDEF DEVSWITCH
   xhallc35 { COPY hall_body_HALLC35 }
#ENDIF
//
//=====================================================================
//                             metcap
//=====================================================================
// rf not supported
//
   metcap_bottom_plate = MET2 ENCLOSE METCAP
   cmim = METCAP AND metcap_bottom_plate
   cmim_shield = MET2 INTERACT METCAP //ghe - shield routingmet2 against METCAP
//
// cmim must have RFDEF for assura RCX
// ok for CALIBRE LVS
//
// do not use rfdef in case of abutment and common bntub
//
   cmim_rf_device = (RFDEF ENCLOSE cmim) AND cmim
   cmim_norf      = cmim NOT RFDEF
//
#IFDEF DEVSWITCH
   xcmim { COPY cmim_norf }
   xcmimrf { COPY cmim_rf_device }
#ENDIF
//
//=====================================================================
//                         split layers
//=====================================================================
// remove spiral from interconnect
// normally spiral does not have met1
// connectivity metal does not have slots !!!
// remove hall spiral from interconnect
//
   routingmet1_all = met1_withslots NOT (spiral_body OR (halldef_cut OR rmet1_device))
   routingmet2_all = met2_withslots NOT (spiral_body OR (halldef_cut OR rmet2_device))
   routingmet3_all = met3_withslots NOT (spiral_body OR rmet3_device)
   routingvia_all  = (VIA  NOT spiral_body) NOT halldef_cut
   routingvia2_all = VIA2 NOT spiral_body
#IFDEF fourmetal
   routingmet4_all = met4_withslots NOT (spiral_body OR rmet4_device)
   routingvia3_all = VIA3 NOT spiral_body
#ENDIF
//
// routing layers which are already included in simulation model
//--------------------------------------------------------------
//
#IFDEF PEXSWITCH
//
// define region for cutting pex
//
   rblock_region  = COPY RFDEF
//
// do not cut met3/via3/met4
//
   rblock_region_cvar_only =  RFDEF INTERACT cvar_device_layer
//
// do not cut met3/via3/met4
// cut met2 only cvar
// cut all other layer
//
   empty_layer = AREA substrate_all == 0
   rblock_region_empty = COPY empty_layer
//
   routingpoly2       = routingpoly2_all NOT rblock_region
   routingpoly2_rblock  = routingpoly2_all AND rblock_region
//
   routingpoly       = routingpoly_all NOT rblock_region
   routingpoly_rblock  = routingpoly_all AND rblock_region
//
   poly1con       = poly1con_all NOT rblock_region
   poly1con_rblock  = poly1con_all AND rblock_region
//
   poly2con       = poly2con_all NOT rblock_region
   poly2con_rblock  = poly2con_all AND rblock_region
//
   routingmet1       = routingmet1_all NOT rblock_region
   routingmet1_rblock  = routingmet1_all AND rblock_region
//
   routingmet2       = routingmet2_all NOT rblock_region_cvar_only
   routingmet2_rblock  = routingmet2_all AND rblock_region_cvar_only
//
   routingmet3       = COPY routingmet3_all
//
   routingvia       = routingvia_all NOT rblock_region_cvar_only
   routingvia_rblock  = routingvia_all AND rblock_region_cvar_only
//
   routingvia2       = routingvia2_all NOT rblock_region_cvar_only
   routingvia2_rblock  = routingvia2_all AND rblock_region_cvar_only

   //routingvia2_rblock { COPY routingvia2_rblock }
//
   diffcon       = diffcon_all NOT rblock_region
   diffcon_rblock  = diffcon_all AND rblock_region
//
#IFDEF fourmetal
//
// disable rblock for met4/via3
//
   routingmet4       = COPY routingmet4_all
   routingvia3       = COPY routingvia3_all
//
#ENDIF
//
#ELSE // pexswitch
//
   routingpoly2 = COPY routingpoly2_all
   routingpoly  = COPY routingpoly_all
   poly1con     = COPY poly1con_all
   poly2con     = COPY poly2con_all
   routingmet1  = COPY routingmet1_all
   routingmet2  = COPY routingmet2_all
   routingmet3  = COPY routingmet3_all
   routingvia   = COPY routingvia_all
   routingvia2  = COPY routingvia2_all
   diffcon      = COPY diffcon_all
//
#IFDEF fourmetal
   routingmet4  = COPY routingmet4_all
   routingvia3  = COPY routingvia3_all
#ENDIF
#ENDIF // pexswitch
//
// use always
//
   metcap_all = COPY METCAP
   routingmetcap = COPY metcap_all
//
//
///////////////////////////////////////////////////////////////////////
//                       CONNECT STATEMENTS                          //
///////////////////////////////////////////////////////////////////////
//
// Create interconnects used in direct mode
//
   CONNECT MET3           MET2                       BY VIA2      DIRECT
   CONNECT MET2           MET1                       BY VIA       DIRECT
   CONNECT MET1           POLY2 POLY1 DIFF           BY CONT      DIRECT

// Create interconnects used in mask mode

#IFDEF fourmetal
   CONNECT MET4           MET3                       BY VIA3 DIRECT
   CONNECT routingmet4    routingmet3                BY routingvia3 MASK   
#ENDIF

// Create interconnects used in mask mode

   CONNECT routingmet3  routingmetcap routingmet2    BY routingvia2 MASK   
   CONNECT routingmet2    routingmet1                BY routingvia  MASK   
   CONNECT routingmet2    cmim_shield                               MASK  //ghe added
   CONNECT routingmet1    routingpoly2               BY poly2con    MASK
   CONNECT routingmet1    routingpoly                BY poly1con    MASK
   CONNECT routingmet1    ndiff                      BY ndiffcon    MASK
   CONNECT routingmet1    pdiff                      BY pdiffcon    MASK
   CONNECT pdiff          substrate                  BY subtap      MASK
   CONNECT ndiff          routingnwell               BY welltap     MASK
   CONNECT routingpoly    trans ncap pcap                           MASK
   CONNECT routingpoly2   preshterm                                 MASK
   CONNECT RESTRM         routingpoly2                              MASK
   CONNECT RESTRM         routingpoly                               MASK
   CONNECT RESTRM         ndiff                                     MASK
   CONNECT RESTRM         pdiff                                     MASK
   CONNECT ndiff          nmosh_d_term                              MASK
   CONNECT pdiff          pnpvert10_e pnplat2_e pnplat2_c           MASK
// for XCALI 
   CONNECT nwdiode_shield routingnwell                              MASK 
   CONNECT trans_shield routingpoly                                 MASK
//
// add connectivity for unrel met checks
//
   CONNECT routingmet3    PAD                                       MASK
// 
// connect spirals
//
#IFDEF fourmetal
// spiral connections for 4 met spirals
   CONNECT spiral_term11 routingmet4   MASK
   CONNECT spiral_term22 routingmet4   MASK
#ELSE
// spiral connections for 3 met spirals
   CONNECT spiral_term11 routingmet3   MASK
   CONNECT spiral_term22 routingmet3   MASK
#ENDIF
//
// remove isolated layout nets warning from LVS
// add connectivity to retrm on spiral terms
//
   CONNECT RESTRM spiral_term11 MASK
   CONNECT RESTRM spiral_term22 MASK
//
// connect hall terms
   CONNECT hall_term_a hall_term_b hall_term_c hall_term_d hall_term_s routingmet1 MASK
   CONNECT hall_term_p1 hall_term_p2 routingmet2 MASK
//
#IFDEF PEXSWITCH
//
// rblock connections
//--------------------
//
// attention : this is necessary because met3 is not blocked
//
   CONNECT routingmet3 routingmet2_rblock  BY routingvia2_rblock MASK
//
// rblock only cvar
   CONNECT routingmet2_rblock routingmet1_rblock   BY routingvia_rblock MASK
   CONNECT routingmet2        routingmet1_rblock   BY routingvia        MASK
//
   CONNECT routingmet1_rblock routingpoly_rblock   BY poly1con_rblock MASK
   CONNECT routingmet1_rblock routingpoly2_rblock  BY poly2con_rblock MASK
   CONNECT routingmet1_rblock  ndiff             BY diffcon_rblock  MASK
   CONNECT routingmet1_rblock  pdiff             BY diffcon_rblock  MASK
//
   CONNECT routingmet1 routingmet1_rblock MASK
   CONNECT routingmet2 routingmet2_rblock MASK
   CONNECT routingpoly routingpoly_rblock MASK
   CONNECT routingpoly2 routingpoly2_rblock MASK
//
// connect res
   CONNECT RESTRM  routingpoly2_rblock                           MASK
   CONNECT routingpoly2_rblock  preshterm                        MASK
//
#ENDIF  // pexswitch
//
//////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
//       _rules_title (DRC Section)
//
// Rules Document: ENG-326                     Revision: 1.0
// Tips  Document: ENG-182                      Revision: 5.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//
//                 16-Jan-2002       aob     new version for c35
//                 28-Jan-2002       aob     what has been done for c35b4 :
//                                           - TSMC DRC implemented ...ok
//                                           - met4 connectivity added
//                                           - RPOLYH (poly2) + HRES rules added
//                                           - slot checks not implemented
//                                           - ERC not modified
//                                           - device recognition not changed
//                 5-Feb-2002        aob     IFDEF form met4 added
//                12-Feb-2002        aob     via2 spac fixed
//                26-Feb-2002        aob     lat2/3 added
//                 6-Mar-2002        aob     additional fixes
//                13-Mar-2002        aob     E1IPP2 removed
//                21-Mar-2002        aob     csxswitch for relaxed csx rules added
//                25-Mar-2002        aob     first review 
//                10-Apr-2002        aob     holes check added
//                                           latchup guidelines improved
//                                           some poly2 checks changed
//                                           pad checks improved
//                                           top metal dummy structures checked
//                                           slotted metal checked for metal checks
//                18-Apr-2002        aob     isolated layout nets fixed
//                24-Apr-2002        aob     wide metal : TRUNCATE added
//                30-Apr-2002        aob     CBR1 fixed, m4 variables added
//                21-May-2002        aob     AMC2 : wide met1 changed
//                24-May-2002        aob     onlys slots with with < 4.0 checked
//                29-May-2002        aob     snap routingnwell removed from hot/cold
//                                           check
//                11-Jun-2002        aob     ill_via3_met4 added
//                                           rec004/rec005 also for spacing
//                                           ATTENTION : remove met4 width/spacing/ovlp
//                                                for b35xx usage
//                                           hot nwell checks changed , nwres removed
//                                           res body of nwres is hot
//                 5-Jul-2002        aob     some comments removed
//                23-Jul-2002        aob     false error latchup lat3 fixed
//                                           cbe1/2/3/4 max added, test/probe pad
//                                           info, top metal on test/probe pads 
//                20-Aug-2002        aob     soft conn ntrans/ptrans midox fixed
//                                           soft connected guards added
//                                           reduced cell added
//                13-Sep-2002        aob     met4 stress block bug fixed
//                                           stress block ERC fixed
//                17-Sep-2002        aob     AMTS3 modified
//                19-Sep-2002        aob     AMTS1 check for m3 and m4 modified   
//                                           false error if rects already placed
//                20-Sep-2002        aob     changes : OD2E midox inside diff ... drc error
//                                           AMW1    : SIZE BY -1.50
//                                           S1IPP2 improved
//                 7-Oct-2002        aob     changes : PPC5/NPC5 impl ovlp on poly
//                                           ODC3 add abut ==0
//                                           ODW1 add diff holes under gate
//                                           ODS2 : check for overlap also
//                16-Oct-2002        aob     add m4 switch for fill rect recognition
//                                           is 2x5 for c35b3/b4 and b35d3
//                                           is 2.5x5 for b35d4
//                21-Oct-2002        aob     AMW1 : size by 1.55
//                                           add recommendation for AMT guideline
//                18-Nov-2002        aob     m1pinshape layer used to mask ou
//                                           floating met1
//                 2-Dec-2002        aob     cbr1 changed to recommended only
//                                           to allow analogue pads
//                 4-Feb-2003        aob     group checks added 
//                                           agnd is no supply
//                24-Feb-2003        aob     LAT3 latchup check output improved
//                                           illegal rpoly2 resistor
//                 6-Mar-2003        aob     met drc region removed
//                19-May-2003        aob     cbe1 modified
//                22-May-2003        aob     ill floating well tubres fixed
//                22-Jul-2003        aob     COR1: csink definition changed
//                                           PO2R1: cstack removed
//                25-Jul-2003        aob     doc eng 183 rev 3.0 implemented
//                                           - REC00x names changed
//                                           - pad rules changed : use "tsmc_orig_drc"
//                                                   CBE6,8,10,12 disabled
//                                                   CBE1,2,3,4 max disabled 
//                                                   CBE1,2,3,4 outside also removed
//                                           - g01p1/go2p2 added( antenna check used)
//                                           - pad pitch check simplified
//                                           - R01CT/ R01VX added
//                                           - R01PA added
//                                           - CBR1 pad met must be connected
//                18-Aug-2003        aob     ill_out_m4hole fixed
//                17-Oct-2003        aob     vbat added to hot/cold checks
//                25-Nov-2003        aob     LAT3 guideline modified :
//                                             no nwell in subtap, change to REC
//                14-Jan-2004        aob     text for ERC checks connected by layer
//                                           to avoid short
//                                           add vbat/vsub to all node related checks
//                27-Jan-2004        aob     min met4/3/2 checks added as ERC for
//                                           via stacks (recommendations)  
//                11-Feb-2004        aob     unrel spacings to pad : measure all
//                                           option added
//                17-May-2004        aob     cbw1 for rf pads , rf pad info
//                                           odc2/odc3 skipped for s35
//                 2-Sep-2004        aob     drop erc warning for fill rectangles 2 x 5 U
//                10-Sep-2004        aob     shorted pads ERC group added 
//                18-Oct-2004        aob     amts4 set to 4 U to avoid errors from thick
//                                           metal fill
//                29-Nov-2004        aob     odc2/odc3 identical for c35/s35
//                 6-Dec-2004        aob     connect pad to met2 removed
//                18-Apr-2005        aob     erc met4 connect fixed
//                24-May-2005        aob     floating gate extended for net output
//                25-May-2005        aob     pad_c connected to met3 (i originally met2)
//                                           to allow met2 routing under SLM PAD
//                21-Jul-2005        aob     no diamond pad vias is info
//                 2-Sep-2005        aob     midox encl diff improved ( inside also)
//                16-Mar-2006        aob     rpoly1 added ( poly1 notch)
//                 3-Aug-2006        aob     polynet removed
//                                           diff spacing ODS1 added ( not only ndiff/pdiff spacing) 
//                                           e1hrp2 inside also
//                                           cbe1/2/3/4  overlap added
//                                           odc2 abut == 0
//                                           lpplus layer added to filter info diff without impl
//                20-Feb-2007        aob     add subdef check connected to vdd
//                27-Aug-2007        aob     filter false errors from nmos30 ntub stripes  with hvdef
//                                           ( nww2, nws1, odc2, odc3,  miss fimp, floating well )
//                15-Jul-2008        aob     filter nmosh with HVDEF to avoid false extract ZMLA
//
///////////////////////////////////////////////////////////////////////
//                     TOPOLOGICAL DESIGN RULES                      //
///////////////////////////////////////////////////////////////////////
//
// define some groups for unselection
// by default all checks are selected

// DRC SELECT CHECK ERC_CHECKS
// DRC SELECT CHECK RECOMMENDATIONS
// DRC SELECT CHECK INFO
// DRC SELECT CHECK COVERAGE
// DRC SELECT CHECK ELEMENTS
// DRC UNSELECT CHECK COVERAGE
// DRC UNSELECT CHECK SHORTED_PADS

  GROUP SHORTED_PADS ?_SERC
// end group

  GROUP ERC_CHECKS ?_ERC
// end group
//
  GROUP RECOMMENDATIONS ?_REC?
// end group
//
  GROUP INFO INFO_?
// end group
//
  GROUP ELEMENTS ?_ELEM
// end group
//
  GROUP COVERAGE ?_RATIO_P? ?_RATIO_M? 
// end group
//---------------------------------------------------------------------
//                           Offgrid Checks
//---------------------------------------------------------------------

// Original Layer Polygons must be on a 0.05 U grid
// Currently not checked
//
//   OFFGRID_VERTEX_REC001 {@ REC001 : Original Layer Polygons must be on a 0.05 U grid
//                   DRAWN OFFGRID
//   }

//---------------------------------------------------------------------
//                          Corner Checks
//---------------------------------------------------------------------
//
// corner checks are info, vias and cont must be square

// NTUB allowed angles 90/135 degree
   INFO_CORN_NTUB_REC002 {@ REC002: NTUB allowed angles 90/135 degree
              ANGLE NTUB >  0 < 45
              ANGLE NTUB > 45 < 90
   }
// DIFF allowed angles 90/135 degree
   INFO_CORN_DIFF_REC002 {@ REC002: DIFF allowed angles 90/135 degree
              ANGLE DIFF >  0 < 45
              ANGLE DIFF > 45 < 90
   }
// DIFF allowed angles 90/135 degree
   INFO_CORN_MIDOX_REC002 {@ REC002: MIDOX allowed angles 90/135 degree
              ANGLE MIDOX >  0 < 45
              ANGLE MIDOX > 45 < 90
   }
// POLY1 allowed angles 90/135 degree
   INFO_CORN_POLY1_REC002 {@ REC002: POLY1 allowed angles 90/135 degree
               ANGLE POLY1 >  0 < 45
               ANGLE POLY1 > 45 < 90
   }
// NPLUS allowed angles 90/135 degree
   INFO_CORN_NPLUS_REC002 {@ REC002: NPLUS allowed angles 90/135 degree
               ANGLE NPLUS >  0 < 45
               ANGLE NPLUS > 45 < 90
   }
// PPLUS allowed angles 90/135 degree
   INFO_CORN_PPLUS_REC002 {@ REC002: PPLUS allowed angles 90/135 degree
               ANGLE PPLUS >  0 < 45
               ANGLE PPLUS > 45 < 90 
  }
// HRES allowed angles 90/135 degree
   INFO_CORN_HRES_REC002 {@ REC002: HRES allowed angles 90/135 degree
              ANGLE HRES >  0 < 45
              ANGLE HRES > 45 < 90 
   }
// POLY2 allowed angles 90/135 degree
   INFO_CORN_POLY2_REC002 {@ REC002: POLY2 allowed angles 90/135 degree
               ANGLE POLY2 >  0 < 45
               ANGLE POLY2 > 45 < 90
   }
// CONT allowed angles 90 degree
   ILL_CORN_CONT_REC002 {@ REC002: CONT allowed angles 90 degree
              ANGLE CONT >  0 < 90
   }
// MET1 allowed angles 90/135 degree
   INFO_CORN_MET1_REC002 {@ REC002: MET1 allowed angles 90/135 degree
              ANGLE MET1 >  0 < 45
              ANGLE MET1 > 45 < 90
   }
// VIA allowed angles 90 degree
   ILL_CORN_VIA_REC002 {@ REC002: VIA allowed angles 90 degree
             ANGLE VIA >  0 < 90
   }
// MET2 allowed angles 90/135 degree
   INFO_CORN_MET2_REC002 {@ REC002: MET2 allowed angles 90/135 degree
              ANGLE MET2 >  0 < 45
              ANGLE MET2 > 45 < 90
   }
// VIA2 allowed angles 90 degree
   ILL_CORN_VIA2_REC002 {@ REC002: VIA2 allowed angles 90 degree
              ANGLE VIA2 >  0 < 90
   }
// MET3 allowed angles 90/135 degree
   INFO_CORN_MET3_REC002 {@ REC002: MET3 allowed angles 90/135 degree
              ANGLE MET3 >  0 < 45
              ANGLE MET3 > 45 < 90
   }
#IFDEF fourmetal
// VIA3 allowed angles 90 degree
   ILL_CORN_VIA3_REC002 {@ REC002: VIA3 allowed angles 90 degree
              ANGLE VIA3 >  0 < 90
   }
// MET4 allowed angles 90/135 degree
   INFO_CORN_MET4_REC002 {@ REC002: MET4 allowed angles 90/135 degree
              ANGLE MET4 >  0 < 45
              ANGLE MET4 > 45 < 90
   }
#ENDIF
// PAD allowed angles 90 degree
// rfpad 45 degrees
   INFO_CORN_PAD_REC002 {@ REC002: PAD allowed angles 90 degree
             ANGLE (PAD NOT rfpad_good) >  0 < 90
             ANGLE rfpad_good >  0 < 45
   }

//---------------------------------------------------------------------
//                           nwell rule
//---------------------------------------------------------------------

// hot/cold ntub-ndiff spacing checks
// hot ntub is ntub NOT connected to to the most positive VDD
// cold ntub is ntub connected to the most positive VDD
//
// remove snaps and nwell resistor terminals : 
// nwell of snaps is totally enclosed by diff
//
   routingnwell_snap = routingnwell INSIDE DIFF
   routingnwell_tubres = NTUB INTERACT nwres 
   routingnwell_nocheck = routingnwell_snap OR routingnwell_tubres
//
   routingnwell_check = routingnwell NOT INTERACT routingnwell_nocheck
//
// vbat added 
//
   nwell_cold = NET routingnwell_check  "?VDD?" "?vdd?" "?VBAT?" "?vbat?" 
//
// filter stripes in nmos30
//
   nwell_hot  = (routingnwell_check NOT nwell_cold) NOT HVDEF
//
   INFO_NWELL_HOT { @ INFO: this nwell is hot
         COPY nwell_hot
   }
//
// check all nwell for min width
// Minimum NTUB width = 1.7 
   WIDTH_NTUB_NWW1 {@ NW_W_1 Minimum NTUB width = 1.7  U
               INT nwell_cold < 1.7 ABUT<90 SINGULAR REGION
               INT routingnwell_nocheck < 1.7 ABUT<90 SINGULAR REGION
   }
// Minimum HOT_NTUB width = 3 
   WIDTH_NTUBHOT_NWW2 {@ NW_W_2 Minimum HOT_NTUB width = 3  U
               INT nwell_hot < 3 ABUT<90 SINGULAR REGION
   }
//
// filter stripes in nmos30
// Minimum spacing of NTUB with different potential = 3  
   SPAC_NTUB_UNCONN_NWS1 {@ NW_S_1 Minimum spacing of NTUB with different potential = 3  U
                    x = EXT routingnwell < 3 SPACE SINGULAR REGION
                                       NOT CONNECTED
                    x NOT HVDEF
   }
// Minimum spacing of NTUB with same potential = 1 
   SPAC_NTUB_CONN_NWS2 {@ NW_S_2 Minimum spacing of NTUB with same potential = 1  U
                    EXT routingnwell < 1 SPACE SINGULAR REGION
                                       CONNECTED
   }
// Minimum spacing of NTUB with same potential = 1  
// polygon with notch has always same potential
   SPAC_NTUB_NOTCH_NWS2 {@ NW_S_2 Minimum spacing of NTUB with same potential = 1  U
                    EXT ntubcheck < 1 NOTCH ABUT<90 REGION
   }
//
//---------------------------------------------------------------------
//                           thin oxide rules
//                           diffusion/od mask
//---------------------------------------------------------------------
//  
// Active width under GATE for N/PFET device Weff >= 0.4
   ngate_w = ngate COINCIDENT INSIDE EDGE POLY1
   pgate_w = pgate COINCIDENT INSIDE EDGE POLY1
// check for diff holes under gate
// Minimum DIFF width to define the width of NMOS/PMOS = 0.4 
   WIDTH_DIFF_ODW1 {@ OD_W_1 Minimum DIFF width to define the width of NMOS/PMOS = 0.4  U
       PATH LENGTH ngate_w < 0.4
       PATH LENGTH pgate_w < 0.4
       x = HOLES gate
       ENC x (DIFF OR x) < 0.4 SINGULAR REGION
   } 
// Active interconnect width >= 0.30
// Minimum DIFF width for interconnection (NDIFF or PDIFF) = 0.3 
   WIDTH_DIFF_ODW2 {@ OD_W_2 Minimum DIFF width for interconnection (NDIFF or PDIFF) = 0.3  U
       INT DIFF < 0.3 ABUT>0<90 SINGULAR REGION
   } 
//
// check for all diff
//
// Minimum DIFF spacing = 0.6      
   SPAC_DIFF_ODS1 {@ OD_S_1 Minimum DIFF spacing = 0.6  U
              EXT DIFF < 0.6 SPACE SINGULAR REGION
   }
//
// Minimum DIFF spacing = 0.6      
// P+ Active space >=0.60
   SPAC_PDIFF_ODS1P {@ OD_S_1 Minimum DIFF spacing = 0.6  U
              EXT pdiff_1 < 0.6 SPACE SINGULAR REGION
   }
// N+ Active space >=0.60
   SPAC_NDIFF_ODS1N {@ OD_S_1 Minimum DIFF spacing = 0.6  U
              EXT ndiff_1 < 0.6 SPACE SINGULAR REGION
   }
//
// check all notches, but no diff ressistors
   SPAC_DIFF_NOTCH_ODS1 {@ OD_S_1 Minimum DIFF spacing = 0.6  U
              EXT diffcheck < 0.6 NOTCH ABUT<90 REGION
   }
//
// NWELL enclosure of Nwell Tie >= 0.20
// Minimum NTUB enclosure of NDIFF = 0.2 
   OVLP_NTUB_NDIFF_ODC1 {@ OD_C_1  Minimum NTUB enclosure of NDIFF = 0.2  U
            // ENC ndiff_n_nmosh nwell_drc < _E1WNDN ABUT==0
            ENC ndiff_n_nmosh NTUB < 0.2 ABUT==0
            OVERLAP SINGULAR REGION
   }
//
// OD_C_2 : Minimum NDIFF to NTUB spacing = 1.2 
// OD_C_3 : Minimum NDIFF to HOT_NTUB spacing (no PTAP in between) = 2.6 
//
//  odc2 : check to any ntub ( not cold only)
//  odc3 : no valid if subtap between
//
// check for abutment/overlap ?
// abut == 0 added due to test layout
//
// COLD NWELL to N+ Active space >=1.20
// Minimum NDIFF to NTUB spacing = 1.2
// filter ntub stripes in nmos30
   SPAC_NDIFF_NTUB_ODC2 {@ OD_C_2 Minimum NDIFF to NTUB spacing = 1.2
      x = EXT routingnwell ndiff_n_nmosh < 1.2 ABUT == 0 SINGULAR REGION
      x NOT HVDEF
   }
//
// Minimum NDIFF to HOT_NTUB spacing (no PTAP in between) = 2.6
// create error : get region and check, if region is divided by subtap
//                in 2 parts
//
   spac_odc3_corn = EXT nwell_hot ndiff_n_nmosh < 2.6 REGION CORNER TO CORNER
   spac_odc3_nocorn = EXT nwell_hot ndiff_n_nmosh < 2.6 REGION NOT CORNER
   spac_odc_nocorn_check = spac_odc3_nocorn NOT ( nwell_hot OR (ndiff_n_nmosh OR subtap))
   spac_odc_corn_check = spac_odc3_corn NOT ( nwell_hot OR (ndiff_n_nmosh OR subtap))
//
// odc3_nocorn { COPY spac_odc_nocorn_check }
// odc3_corn { COPY spac_odc_corn_check }
//
   SPAC_NDIFF_NTUBHOT_ODC3 {@ OD_C_3 Minimum NDIFF to HOT_NTUB spacing (no PTAP in between) = 2.6
     x1 = spac_odc_corn_check TOUCH ndiff_n_nmosh
     x2 = spac_odc_nocorn_check TOUCH ndiff_n_nmosh
     x3 = x1 OR x2
     y1 = spac_odc_corn_check TOUCH nwell_hot
     y2 = spac_odc_nocorn_check TOUCH nwell_hot
     y3 = y1 OR y2
     x3 INTERACT y3
// check for abutment
     EXT nwell_hot ndiff_n_nmosh < 0.1 ABUT == 0 SINGULAR REGION
// check for resistor body ...
     EXT routingnwell_nocheck ndiff_n_nmosh < 2.6 SINGULAR REGION
   }
//
// NWELL enclosure of P Active >= 1.20
// Minimum NTUB enclosure of PDIFF = 1.2 
   OVLP_NTUB_PDIFF_ODC4 {@ OD_C_4 Minimum NTUB enclosure of PDIFF = 1.2 U
                    ENC pdiff_1 NTUB < 1.2 ABUT==0
                    OVERLAP SINGULAR REGION
   }
// NWELL to Pwell Tie space >= 0.20
// Minimum PDIFF to NTUB spacing = 0.2 
   SPAC_PDIFF_NTUB_ODC5 {@ OD_C_5 Minimum PDIFF to NTUB spacing = 0.2 U
                    EXT pdiff_1 NTUB < 0.2 ABUT==0
                    SINGULAR REGION
   }
//
// Pwell Contact to NGate space >= 0.45
// Minimum PDIFF to NGATE spacing = 0.45 
   OVLP_BUTTPDIFF_NGATE_ODC6A {@ OD_C_6a Minimum PDIFF to NGATE spacing = 0.45 
                        x = subtap COINCIDENT EDGE ndiff_1
                        EXT ngate x < 0.45 
                        PROJECTING OPPOSITE ABUT<90 REGION 
   }
//  Nwell Contact to PGate space >= 0.45
// Minimum NDIFF to PGATE spacing = 0.45 
   OVLP_BUTTNDIFF_PGATE_ODC6B {@ OD_C_6b Minimum NDIFF to PGATE spacing = 0.45 
                        x = welltap COINCIDENT EDGE pdiff_1
                        EXT pgate x < 0.45 
                        PROJECTING OPPOSITE ABUT<90 REGION 
   }
// P Active to N+ Active Non-butted diffusion space >= 0.60
// check for overlap also
// Minimum NDIFF to butting PDIFF spacing = 0 0
// Minimum NDIFF to non-butting PDIFF spacing = 0.6 0.6
   SPAC_PDIFF_NDIFF_ODS2B { @ OD_S_2B Minimum NDIFF to non-butting PDIFF spacing = 0.6 
        EXT pdiff_n_zener ndiff_n_zener < 0.6 OVERLAP ABUT>0<90 SINGULAR REGION
        pdiff_n_zener AND ndiff_n_zener
   }

// nplus and pplus ovlp warning
   ovlp_nplus_pplus = nplus_n_zener AND pplus_n_zener
   INFO_NPLUS_AND_PPLUS {@ INFO: nplus pplus overlap
             COPY ovlp_nplus_pplus
   }
//
// diff without implant is possible...warning
// remove bipolar diff
   INFO_DIFF_NOIMPL {@ INFO: Diffusion region missing nplus/pplus
             x = (diff_n_zener NOT implant) NOT INTERACT EMITT 
             x NOT LPPLUS
   }
//
// end of thin oxide rules
//
//---------------------------------------------------------------------
//                       thick oxide rules (midox)
//---------------------------------------------------------------------
// Minimum MIDOX width = 0.6 
   WIDTH_MIDOX_W1XM {@ W1XM Minimum MIDOX width = 0.6  U
       INT MIDOX < 0.6 ABUT<90 SINGULAR REGION
   } 
//
// inside also : do not allow any midox edge inside diff  
// flag midox touching diff but not enclosing also as error
// Minimum MIDOX enclosure of DIFF = 0.6 
   OVLP_MIDOX_DIFF_OD2E1 {@ OD2_E_1 Minimum MIDOX enclosure of DIFF = 0.6  U 
       ENC DIFF MIDOX < 0.6 ABUT < 90 INSIDE ALSO SINGULAR REGION
       (MIDOX INTERACT DIFF) NOT ENCLOSE DIFF
   }
//
// Minimum MIDOX spacing = 0.6 
   SPAC_MIDOX_OD2S1 {@ OD2_S_1 Minimum MIDOX spacing = 0.6 
       EXT MIDOX < 0.6  ABUT>0<90 SPACE SINGULAR REGION
   }
// Minimum MIDOX spacing = 0.6 
   SPAC_MIDOX_NOTCH_OD2S1 {@ OD2_S_1 Minimum MIDOX spacing = 0.6 
       EXT MIDOX < 0.6  ABUT>0<90 NOTCH SINGULAR REGION
   }
//
// Minimum MIDOX to DIFF spacing = 0.6 
   SPAC_MIDOX_DIFF_OD2C1 {@ OD2_C_1 Minimum MIDOX to DIFF spacing = 0.6      
       EXT MIDOX DIFF < 0.6 ABUT == 0 OVERLAP SINGULAR REGION 
   }
//
// MIDOX outside GATE is not allowed
   ILL_MIDOX_NOGATE_BAD1XM {@ BAD1XM MIDOX outside GATE is not allowed
       MIDOX NOT ENCLOSE gate
   }
//---------------------------------------------------------------------
//                           poly1 rule
//---------------------------------------------------------------------
//
   ngatem_w = (ngate AND MIDOX) COINCIDENT INSIDE EDGE POLY1
   pgatem_w = (pgate AND MIDOX) COINCIDENT INSIDE EDGE POLY1

// GATE length for PFET device Leff >=0.35
// Minimum GATE length of PMOS = 0.35 
   LENGTH_PGATE_POW1A {@ PO_W_1a Minimum GATE length of PMOS = 0.35 
       INT pgate_w < 0.35 ABUT>0<90
   }
// Minimum GATE length of PMOSM = 0.5 
   LENGTH_PGATE_POW1B {@ PO_W_1b Minimum GATE length of PMOSM = 0.5 
       INT pgatem_w < 0.5 ABUT>0<90
   }
//
// GATE length for NFET device Leff >=0.35
// Minimum GATE length of NMOS = 0.35 
   LENGTH_NGATE_POW2A {@ PO_W_2a Minimum GATE length of NMOS = 0.35 
       INT ngate_w < 0.35 ABUT>0<90
   }
// Minimum GATE length of NMOSM = 0.5 
   LENGTH_NGATE_POW2B {@ PO_W_2b Minimum GATE length of NMOSM = 0.5 
       INT ngatem_w < 0.5 ABUT>0<90
   }
//
// Poly (over field) interconnect width >= 0.35
// Minimum POLY1 width for interconnect = 0.35 
   poly1_field = POLY1 NOT gate
   WIDTH_POLY_POW3 {@ PO_W_3 Minimum POLY1 width for interconnect = 0.35
       INT poly1_field < 0.35 ABUT>0<90 SINGULAR REGION
   }
//
// POLY (over FOX or OD) space >= 0.45
// Minimum POLY1 spacing = 0.45 
   SPAC_POLY1_POS1 {@ PO_S_1 Minimum POLY1 spacing = 0.45 
       EXT POLY1 < 0.45 ABUT>0<90 SPACE SINGULAR REGION
   }
//
// Minimum POLY1 spacing = 0.45 
   SPAC_POLY1_NOTCH_POS1 {@ PO_S_1 Minimum POLY1 spacing = 0.45 
       EXT poly1check < 0.45 ABUT>0<90 NOTCH REGION
   }
//
// Poly (over field) to Active space >= 0.20
// Minimum POLY1 to DIFF spacing = 0.2 
   SPAC_DIFF_POLY_POC1 { @ PO_C_1 Minimum POLY1 to DIFF spacing = 0.2 
       EXT POLY1 DIFF < 0.2 ABUT<90 SINGULAR REGION 
   }
//
// Active extension beyond GATE >=0.50
// Minimum DIFF extension of GATE = 0.5 
   OVLP_DIFF_GATE_POC2 { @ PO_C_2 Minimum DIFF extension of GATE = 0.5 
       ENC POLY1 DIFF < 0.5 ABUT>0<90 SINGULAR REGION 
   }
//
// GATE extension beyond Active >=0.40
// Minimum POLY1 extension of GATE = 0.4 
   OVLP_POLY1_GATE_POO1 { @ PO_O_1 Minimum POLY1 extension of GATE = 0.4 
       ENC DIFF POLY1 < 0.4  ABUT<90 SINGULAR REGION
   }
//
// attention : chip is total area of all layers
// Minimum density of POLY1 area [%] = 14 
   ILL_POLY1_DIE_RATIO_POR1 {@ PO_R_1 Minimum density of POLY1 area [%] = 14 
       DENSITY POLY1 < 0.14 PRINT "ratio_poly1_die.txt"
   }
//---------------------------------------------------------------------
//                           poly2 rule
//---------------------------------------------------------------------
//
// (1) POLY2 on POLY1 as CAPACITOR TOP PLATE
//
// Capacitor Top Plate width >= 0.80
// Minimum CPOLY width = 0.8 
   WIDTH_POCAP_PO2W1 {@ PO2_W_1 Minimum CPOLY width = 0.8 
        INT cpoly < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// Capacitor Top Plate space >= 0.65
// Minimum CPOLY spacing = 0.65 
   SPAC_POCAP_PO2S1 {@ PO2_S_1 Minimum CPOLY spacing = 0.65 
        EXT cpoly < 0.65 ABUT>0<90 SINGULAR REGION 
   }
//
// POLY1 enclosure of Capacitor Top Plate >= 1.00
// Minimum POLY1 enclosure of CPOLY = 1 
   OVLP_POLY1_POLY2_PO2E1 {@ PO2_E_1 Minimum POLY1 enclosure of CPOLY = 1 
        ENC cpoly POLY1 < 1 ABUT<90 SINGULAR REGION
   }
//
// Capacitor Top Plate enclosure of Contact >= 0.60
// Minimum CPOLY enclosure of POLY2CON = 0.6 
   OVLP_POLY2_CONT_PO2E2 {@ PO2_E_2 Minimum CPOLY enclosure of POLY2CON = 0.6 
        ENC CONT cpoly < 0.6 ABUT<90 OVERLAP SINGULAR
   }
//
// Poly1 contact to Capacitor Top Plate space >= 1.20
// Minimum POLY1CON to CPOLY spacing = 1.2 
   SPAC_POLY2_P1CON_PO2C1 {@ PO2_C_1 Minimum POLY1CON to CPOLY spacing = 1.2 
        EXT poly1con cpoly < 1.2 ABUT<90 OVERLAP SINGULAR
   }
//
// (2) POLY2 on FOX as RESISTOR

// check all poly2

// Poly Resistor width >= 0.65
// Minimum POLY2 width = 0.65
   WIDTH_POLY2_PO2W2 { @ PO2_W_2 Minimum POLY2 width = 0.65 
        INT POLY2 < 0.65 ABUT>0<90 SINGULAR REGION
   }
//
//Poly Resistor space >= 0.50
// Minimum POLY2 spacing = 0.5 
   SPAC_POLY2_PO2S2 { @ PO2_S_2 Minimum POLY2 spacing = 0.5 
        EXT POLY2 < 0.5 SPACE ABUT>0<90 SINGULAR REGION
   }
//Poly Resistor space >= 0.50
// Minimum POLY2 spacing = 0.5 
   SPAC_POLY2_NOTCH_PO2S2 { @ PO2_S_2 Minimum POLY2 spacing = 0.5 
        EXT poly2check < 0.5 NOTCH ABUT>0<90 REGION
   }

//
// HIGH RESISTANCE POLY2
//
//Poly Resistor width >= 0.80
// Minimum RPOLYH width = 0.8 
   WIDTH_RPOLYH_PO2W3 { @ PO2_W_3 Minimum RPOLYH width = 0.8 
        INT presh < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// Poly Resistor space >= 0.75
// Minimum RPOLYH spacing = 0.75 
   SPAC_RPOLYH_PO2S3 { @ PO2_S_3 Minimum RPOLYH spacing = 0.75 
        EXT presh < 0.75 SPACE ABUT>0<90 SINGULAR REGION
   }
// Minimum RPOLYH spacing = 0.75 
   SPAC_RPOLYH_NOTCH_PO2S3 { @ PO2_S_3 Minimum RPOLYH spacing = 0.75 
        EXT poly2hcheck < 0.75 NOTCH ABUT>0<90 REGION
   }
//
// Poly Resistor to OD space >= 0.20
// SPAC_RPOLYH_DIFF_PO2C2 { @ PO2_C_2 Minimum DIFF to POLY2 spacing = 0.2 
// EXT DIFF presh < 0.2 ABUT<90 OVERLAP SINGULAR REGION 
// Minimum DIFF to POLY2 spacing = 0.2 
   SPAC_DIFF_POLY2_PO2C2 { @ PO2_C_2 Minimum DIFF to POLY2 spacing = 0.2 
        EXT DIFF POLY2 < 0.2 ABUT<90 OVERLAP SINGULAR REGION 
   }
//
// Poly Resistor to POLY space >= 0.65
// EXT POLY1 presh < 0.65 ABUT<90 OVERLAP SINGULAR  REGION
// Minimum POLY1 to POLY2 spacing = 0.65 
   SPAC_POLY1_POLY2_PO2C3 { @ PO2_C_3 Minimum POLY1 to POLY2 spacing = 0.65 
        EXT POLY1 POLY2 < 0.65 ABUT<90 OVERLAP SINGULAR  REGION
   }
//
// Poly Resistor enclosure of Contact >= 0.25
// ENC CONT (POLY2 INTERACT (pres OR presh)) < 0.25 ABUT<90 OVERLAP SINGULAR REGION
// Minimum POLY2 enclosure of POLY2CON = 0.25 
   OVLP_POLY2_CONT_PO2E3 { @ PO2_E_3 Minimum POLY2 enclosure of POLY2CON = 0.25 
        ENC CONT POLY2 < 0.25 ABUT<90 OVERLAP SINGULAR REGION
   }
//
// remove false errors cstack
// POLY2 on DIFF is not allowed 
   ILL_POLY2_DIFF_PO2R1 { @ PO2_R_1 POLY2 on DIFF is not allowed 
        (POLY2 AND DIFF) NOT cstack_for_drc
   }
//---------------------------------------------------------------------
//                           pplus rule
//---------------------------------------------------------------------
//
// Minimum PPLUS width = 0.6 
#IFDEF csxswitch
   WIDTH_PPLUS_PPW1_CSX { @ PP_W_1 Minimum PPLUS width = 0.6 
       INT PPLUS < 0.5  ABUT>0<90 SINGULAR REGION
   }
#ELSE
   WIDTH_PPLUS_PPW1 { @ PP_W_1 Minimum PPLUS width = 0.6 
       INT PPLUS < 0.6  ABUT>0<90 SINGULAR REGION
   }
#ENDIF
//
// Minimum PPLUS spacing = 0.6 
   SPAC_PPLUS_PPS1 { @ PP_S_1 Minimum PPLUS spacing = 0.6 
       EXT PPLUS < 0.6 ABUT>0<90 SPACE SINGULAR REGION
   }
//
// Minimum PPLUS spacing = 0.6 
   SPAC_PPLUS_NOTCH_PPS1 { @ PP_S_1 Minimum PPLUS spacing = 0.6 
       EXT PPLUS < 0.6 ABUT>0<90 NOTCH SINGULAR REGION
   }
// PP to Active space >= 0.35
// Minimum PPLUS to DIFF spacing = 0.35 
   SPAC_PPLUS_DIFF_PPC1 { @ PP_C_1 Minimum PPLUS to DIFF spacing = 0.35 
       EXT PPLUS DIFF < 0.35 ABUT<90 SINGULAR REGION
   }
// PP to Ngate space >= 0.45
// Minimum PPLUS to NGATE spacing = 0.45 
#IFNDEF csxswitch
   SPAC_PPLUS_NGATE_PPC2 { @ PP_C_2 Minimum PPLUS to NGATE spacing = 0.45   
       EXT PPLUS ngate < 0.45 ABUT>0<90 SINGULAR REGION
   }
#ENDIF
   gate_w = gate INSIDE EDGE DIFF
//  PP overlap of PGate
// Minimum PPLUS extension of PGATE = 0.45 
   OVLP_PPLUS_PGATE_PPC3 { @ PP_C_3 Minimum PPLUS extension of PGATE = 0.45 
       ENC gate_w PPLUS < 0.45 ABUT<90 OPPOSITE REGION
   }
// P active width (from PP to OD) >=0.45
// Minimum overlap of PPLUS and DIFF = 0.45 
   OVLP_PPLUS_DIFF_PPO1 { @ PP_O_1 Minimum overlap of PPLUS and DIFF = 0.45 
       INT PPLUS DIFF < 0.45 ABUT>0<90 SINGULAR MEASURE COINCIDENT 
   }
//
// P+ implant overlap of OD >=0.25
// Minimum PPLUS extension of DIFF = 0.25 
   OVLP_PPLUS_DIFF_PPE1 { @ PP_E_1 Minimum PPLUS extension of DIFF = 0.25 
       ENC DIFF PPLUS < 0.25 ABUT<90 SINGULAR REGION 
   }
//
// PNC5 Covers PPC5 and NPC5
//
// NP to PP space (on poly) >= 0.25
// Minimum PPLUS to NPLUS spacing on POLY1 = 0.25 0.25
// Minimum PPLUS to NPLUS spacing on POLY1 = 0.25 0.25
// check also if nplus and pplus overlaps on poly
#IFNDEF csxswitch
   SPAC_IMPL_POLY_PPC5_NPC5 { @ PP_C_5 NP_C_5 Minimum PPLUS to NPLUS spacing on POLY1 = 0.25 
       nppo = POLY1 AND NPLUS
       pppo = POLY1 AND PPLUS
       EXT nppo pppo < 0.25 ABUT<90 SINGULAR OVERLAP REGION
       nppo AND pppo
       ovlp_nplus_pplus INTERACT POLY1
   }
#ENDIF
//
// is a spacing allowed ?
// PP over OD with NP (for same potential diffusion) space == 0
// Minimum PPLUS to NPLUS spacing on DIFF with same potential = 0
   SPAC_PPLUS_NPLUS_DIFF_PPC6 {@ PP_C_6 Minimum PPLUS to NPLUS spacing on DIFF with same potential = 0 
       subtap AND (ndiff NOT routingnwell)
       // PTIE AND NACT 
   }
//---------------------------------------------------------------------
//                           nplus rule
//---------------------------------------------------------------------
//
// Minimum NPLUS width = 0.6 
#IFDEF csxswitch
   WIDTH_NPLUS_NPW1_CSX { @ NP_W_1 Minimum NPLUS width = 0.6 
       INT NPLUS < 0.5 ABUT>0<90 SINGULAR REGION
   }
#ELSE
   WIDTH_NPLUS_NPW1 { @ NP_W_1 Minimum NPLUS width = 0.6 
       INT NPLUS < 0.6  ABUT>0<90 SINGULAR REGION
   }
#ENDIF
//
// Minimum NPLUS spacing = 0.6 
   SPAC_NPLUS_NPS1 { @ NP_S_1 Minimum NPLUS spacing = 0.6 
       EXT NPLUS < 0.6 ABUT>0<90 SPACE SINGULAR REGION
   }
//
// Minimum NPLUS spacing = 0.6 
   SPAC_NPLUS_NOTCH_NPS1 { @ NP_S_1 Minimum NPLUS spacing = 0.6 
       EXT NPLUS < 0.6 ABUT>0<90 NOTCH SINGULAR REGION
   }
//
// Minimum NPLUS to DIFF spacing = 0.35 
   SPAC_NPLUS_DIFF_NPC1 { @ NP_C_1 Minimum NPLUS to DIFF spacing = 0.35 
       EXT NPLUS DIFF < 0.35 ABUT<90 SINGULAR REGION
   }
//
// Minimum NPLUS to PGATE spacing = 0.45 
#IFNDEF csxswitch
   SPAC_NPLUS_PGATE_NPC2 { @ NP_C_2 Minimum NPLUS to PGATE spacing = 0.45   
       EXT NPLUS pgate < 0.45 ABUT>0<90 SINGULAR REGION
   }
#ENDIF
//
// Minimum NPLUS extension of NGATE = 0.45 
   OVLP_NPLUS_NGATE_NPC3 { @ NP_C_3 Minimum NPLUS extension of NGATE = 0.45 
       ENC gate_w NPLUS < 0.45 ABUT<90 OPPOSITE REGION
   }
// Minimum overlap of NPLUS and DIFF = 0.45 
   OVLP_NPLUS_DIFF_NPO1 { @ NP_O_1 Minimum overlap of NPLUS and DIFF = 0.45 
       INT NPLUS DIFF < 0.45 ABUT>0<90 SINGULAR MEASURE COINCIDENT 
   }
//
// Minimum NPLUS extension of DIFF = 0.25 
   OVLP_NPLUS_DIFF_NPE1 { @ NP_E_1 Minimum NPLUS extension of DIFF = 0.25 
       ENC DIFF NPLUS < 0.25 ABUT<90 SINGULAR REGION 
   }
// NP over OD with PP (for same potential diffusion) space == 0
// is a spacing allowed ?
// Minimum NPLUS to PPLUS spacing on DIFF with same potential = 0 
   SPAC_PPLUS_NPLUS_DIFF_NPC6 {@ NP_C_6 Minimum NPLUS to PPLUS spacing on DIFF with same potential = 0 
       welltap AND (pdiff_n_zener AND routingnwell)
       // NTIE AND PACT
   }
//---------------------------------------------------------------------
//                          contact rules
//---------------------------------------------------------------------

//Contact width, length (must be square) == 0.40
// Fixed CONT width = 0.4 
   WIDTH_CONT_COW1 { @ CO_W_1 Fixed CONT width = 0.4 
      NOT RECTANGLE CONT == 0.4 BY == 0.4 
   }
//
// Contact space >= 0.40
// Minimum CONT spacing = 0.4 
   SPAC_CONT_COS1 { @ CO_S_1 Minimum CONT spacing = 0.4 
      EXT CONT < 0.4 SPACE ABUT>0<90 SINGULAR REGION 
   }
//
// Minimum CONT spacing = 0.4 
   SPAC_CONT_NOTCH_COS1 { @ CO_S_1 Minimum CONT spacing = 0.4 
      EXT CONT < 0.4 NOTCH ABUT>0<90 SINGULAR REGION 
   }
//
// Diffusion contact to GATE space >= 0.30
// Minimum DIFFCON to GATE spacing = 0.3 
   SPAC_DIFFCON_GATE_COC1 { @ CO_C_1 Minimum DIFFCON to GATE spacing = 0.3 
      EXT diffcon gate < 0.3 ABUT<90 SINGULAR INSIDE ALSO REGION
   }
//
// Poly contact to OD space >= 0.40
// Minimum POLY1CON to DIFF spacing = 0.4 
   SPAC_POLYCON_GATE_COC2 { @ CO_C_2 Minimum POLY1CON to DIFF spacing = 0.4 
      EXT poly1con DIFF < 0.4 ABUT<90 OVERLAP SINGULAR
   }
//
// OD enclosure of Diffusion Contact >= 0.15
// Minimum DIFF enclosure of DIFFCON = 0.15  
   OVLP_DIFF_CONT_COE1 { @ CO_E_1 Minimum DIFF enclosure of DIFFCON = 0.15 
      ENC diffcon DIFF < 0.15 ABUT<90 SINGULAR OUTSIDE ALSO REGION
   }
//
// POLY enclosure of Poly Contact >= 0.20
// Minimum POLY1 enclosure of POLY1CON = 0.2 
   OVLP_POLY_CONT_COE2 { @ CO_E_2 Minimum POLY1 enclosure of POLY1CON = 0.2 
      ENC poly1con POLY1 < 0.2 ABUT<90 SINGULAR OVERLAP REGION 
   }
//
//PP enclosure of Diffusion contact >= 0.25
// Minimum PPLUS enclosure of PDIFFCON = 0.25 
   OVLP_PPLUS_DIFFCON_COE3 { @ CO_E_3 Minimum PPLUS enclosure of PDIFFCON = 0.25 
      ENC diffcon PPLUS < 0.25 ABUT<90 SINGULAR OVERLAP REGION
   }
//
// NP enclosure of Diffusion contact >= 0.25
// Minimum NPLUS enclosure of NDIFFCON = 0.25 
   OVLP_NPLUS_DIFFCON_COE4 { @ CO_E_4 Minimum NPLUS enclosure of NDIFFCON = 0.25 
      ENC diffcon NPLUS < 0.25 ABUT<90 SINGULAR OVERLAP REGION
   }
//
// remove false errors csink/cstack
// Poly contact not allowed over OD
// POLY1CON on DIFF is not allowed 
   csink_for_drc = (COLL AND (DIFF AND POLY1)) NOT implant
   cstack_for_drc = csink_for_drc ENCLOSE POLY2
   ILL_POLYCONT_DIFF_COR1 { @ CO_R_1 POLY1CON on DIFF is not allowed 
       (poly1con AND DIFF) NOT csink_for_drc
       CONT AND gate
   }
//
// Butted CONT is not allowed 
   ILL_BUTTCON_COR2 { @ CO_R_2 Butted CONT is not allowed 
      diffcon CUT PPLUS
      diffcon CUT NPLUS
   }
// there must be any layer BELOW cont and via !!!!
// this is ERC check also
// CONT without DIFF or POLY1 or POLY2 is not allowed
   ILL_CONT_ISOLATED_R01CT {@ R01CT CONT without DIFF or POLY1 or POLY2 is not allowed
      CONT NOT INSIDE diff_or_poly
   }
// 
// check for conts missing met1/diff/poly
   ILL_CONT_MET1 {@ ERC Warning: CONT without MET1
                    CONT NOT met1_withslots
   }
   ILL_CONT_DIFFPOLY {@ ERC Warning: CONT without diff or poly
                    CONT NOT diff_or_poly
   }
//
//---------------------------------------------------------------------
//                          metal1 rules
//---------------------------------------------------------------------
//
// M1 width >= 0.50
// Minimum MET1 width = 0.5 
   WIDTH_MET1_M1W1 { @ M1_W_1 Minimum MET1 width = 0.5 
       INT met1_withslots < 0.5 ABUT>0<90 SINGULAR REGION
   }
// M1 space >= 0.45
// Minimum MET1 spacing = 0.45 
   SPAC_MET1_M1S1 { @ M1_S_1 Minimum MET1 spacing = 0.45 
       EXT met1_withslots < 0.45 ABUT>0<90 SPACE SINGULAR //REGION
   }
// Minimum MET1 spacing = 0.45 
   SPAC_MET1_NOTCH_M1S1 { @ M1_S_1 Minimum MET1 spacing = 0.45 
       EXT met1_withslots < 0.45 ABUT>0<90 NOTCH SINGULAR //REGION
   }
// M1 (at least 1 line >10um wide) space >= 0.80
// Minimum MET1 to WIDE_MET1 spacing = 0.8 
   SPAC_MET1WIDE_M1S2 { @ M1_S_2 Minimum MET1 to WIDE_MET1 spacing = 0.8 
       // underover, trunc acute if 45 edges in power bus
       m1rd = SIZE MET1 BY -5.0
       m1gu = SIZE m1rd BY  5.0 TRUNCATE 2.0
       m1sa = SIZE m1gu BY 0.4
       // grow junctions 1 U 
       m1sb = m1sa AND MET1
       m1sc = SIZE m1sb BY 0.4
       m1sd = m1sc AND MET1
       m1se = SIZE m1sd BY 0.2
       m1sf = m1se AND MET1       //wide M1
       s1 = MET1 NOT m1sf
       drc_4 = EXT [m1sf] < 0.8 ABUT>0<90 SINGULAR
       wm1e = EXPAND EDGE drc_4 OUTSIDE BY 0.001
       wm1e NOT MET1
       EXT m1sf s1 < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// M1 enclosure of Contact >= 0.15
// Minimum MET1 enclosure of CONT = 0.15 
   OVLP_MET1_CONT_M1E1 { @ M1_E_1 Minimum MET1 enclosure of CONT = 0.15 
       ENC CONT met1_withslots < 0.15 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
//
// attention : chip is total area of all layers
// Minimum density of MET1 area [%] = 30 30
   ILL_MET1_DIE_RATIO_M1R1 {@ M1_R_1 Minimum density of MET1 area [%] = 30 
       DENSITY MET1  < 0.3 PRINT "ratio_met1_die.txt"
   }
//---------------------------------------------------------------------
//                          via1 rules
//---------------------------------------------------------------------
//
// VIA1 width == 0.50
// Fixed VIA1 width = 0.5 
   WIDTH_VIA1_V1W1 { @ VIA1_W_1 Fixed VIA1 width = 0.5 
      NOT RECTANGLE VIA == 0.5 BY == 0.5
   }
//
// VIA1 space >= 0.45
// Minimum VIA1 spacing = 0.45 
   SPAC_VIA_VIAS1 { @ VIA1_S_1 Minimum VIA1 spacing = 0.45 
      EXT VIA < 0.45 ABUT>0<90 SPACE SINGULAR REGION 
   }
//
// Minimum VIA1 spacing = 0.45 
   SPAC_VIA_NOTCH_VIA1S1 { @ VIA1_S_1 Minimum VIA1 spacing = 0.45 
      EXT VIA < 0.45 ABUT>0<90 NOTCH SINGULAR REGION 
   }
//
// VIA1 must be within M1 and enclosed by >= 0.20 
// Minimum MET1 enclosure of VIA1 = 0.2 
   OVLP_MET1_VIA1_VIA1E1 { @ VIA1_E_1 Minimum MET1 enclosure of VIA1 = 0.2  
       ENC VIA met1_withslots < 0.2 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
// VIA1 without MET1 is not allowed
   ILL_VIA1_ISOLATED_R01V1 {@ R01V1 VIA1 without MET1 is not allowed
       VIA NOT INSIDE MET1
   }
// via missing metal1 
   ILL_VIA_MET1 {@ ERC Warning: via1 missing metal1
       VIA NOT met1_withslots
   }
//---------------------------------------------------------------------
//                          metal2 rules
//---------------------------------------------------------------------

// M2 width >= 0.60
// Minimum MET2 width = 0.6 
   WIDTH_MET2_M2W1 { @ M2_W_1 Minimum MET2 width = 0.6 
      INT met2_withslots < 0.6 ABUT>0<90 SINGULAR 
   }
// M2 space >= 0.50
// Minimum MET2 spacing = 0.5 
   SPAC_MET2_M2S1 { @ M2_S_1 Minimum MET2 spacing = 0.5 
       EXT met2_withslots < 0.5 ABUT>0<90 SPACE SINGULAR // REGION
   }
// Minimum MET2 spacing = 0.5 
   SPAC_MET2_NOTCH_M2S1 { @ M2_S_1 Minimum MET2 spacing = 0.5 
       EXT met2_withslots < 0.5 ABUT>0<90 NOTCH SINGULAR // REGION
   }
// Wide M2 space >= 0.80
// Minimum MET2 to WIDE_MET2 spacing = 0.8 
   SPAC_MET2WIDE_M2S2 { @ M2_S_2 Minimum MET2 to WIDE_MET2 spacing = 0.8 
        m2rd = MET2 SIZE BY -5.0
        m2gu = m2rd SIZE BY  5.0 TRUNCATE 2.0
        m2sa = SIZE m2gu BY 0.5
        m2sb = m2sa AND MET2
        m2sc = SIZE m2sb BY 0.5
        m2sd = m2sc AND MET2     //wide m2
        s2 = MET2 NOT m2sd
        drc_5 = EXT [m2sd] < 0.8 ABUT>0<90 SINGULAR
        wm2e = EXPAND EDGE drc_5 OUTSIDE BY 0.001 
        wm2e NOT MET2
        EXT m2sd s2 < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// VIA1 must be within M2 and enclosed by >= 0.15
// Minimum MET2 enclosure of VIA1 = 0.15 
   OVLP_MET2_VIA_M2E1 { @ M2_E_1 Minimum MET2 enclosure of VIA1 = 0.15 
       ENC VIA met2_withslots < 0.15 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
//
// attention : chip is total area of all layers
// Minimum density of MET2 area [%] = 30 
   ILL_MET2_DIE_RATIO_M2R1 {@ M2_R_1 Minimum density of MET2 area [%] = 30 
       DENSITY MET2 < 0.3 PRINT "ratio_met2_die.txt"
   }
//---------------------------------------------------------------------
//                          via2 rules
//---------------------------------------------------------------------
//
// VIA2 width == 0.50
// Fixed VIA2 width = 0.5 
   WIDTH_VIA2_VIA2W1 { @ VIA2_W_1 Fixed VIA2 width = 0.5 
     NOT RECTANGLE VIA2 == 0.5 BY == 0.5
   }
//
//  VIA2 space >= 0.45
// Minimum VIA2 spacing = 0.45 
   SPAC_VIA2_VIA2S1 { @ VIA2_S_1 Minimum VIA2 spacing = 0.45 
     EXT VIA2 < 0.45 ABUT>0<90 SPACE SINGULAR REGION
   }
//
// Minimum VIA2 spacing = 0.45 
   SPAC_VIA2_NOTCH_VIA2S1 { @ VIA2_S_1 Minimum VIA2 spacing = 0.45 
      EXT VIA2 < 0.45 ABUT>0<90 NOTCH SINGULAR REGION 
   }
//
// VIA2 must be within M2 and enclosed by >= 0.20
// Minimum MET2 enclosure of VIA2 = 0.2 
   OVLP_MET2_VIA2_VIA2E1 { @ VIA2_E_1 Minimum MET2 enclosure of VIA2 = 0.2 
      ENC VIA2 met2_withslots < 0.2 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
// VIA2 without MET2 is not allowed
   ILL_VIA2_ISOLATED_R01V2 {@ R01V2 VIA2 without MET2 is not allowed
       VIA2 NOT INSIDE MET2
   }
// via2 missing metal2 
   ILL_VIA2_MET2 {@ ERC Warning: via2 missing metal2
                 VIA2 NOT met2_withslots
   }
//---------------------------------------------------------------------
//                          metal3 rules
//---------------------------------------------------------------------
// M3 width >= 0.60
// Minimum MET3 width = 0.6 
   WIDTH_MET3_M3W1 { @ M3_W_1 Minimum MET3 width = 0.6 
     INT met3_withslots < 0.6 ABUT>0<90 SINGULAR REGION 
   }
//
#IFDEF fourmetal
// M3 space >= 0.50 for 4 metal
// Minimum MET3 spacing = 0.5 
   SPAC_MET3_M3S1 { @ M3_S_1 Minimum MET3 spacing = 0.5 
     EXT met3_withslots < 0.5 ABUT>0<90 SPACE SINGULAR // REGION 
   }
// Minimum MET3 spacing = 0.5 
   SPAC_MET3_NOTCH_M3S1 { @ M3_S_1 Minimum MET3 spacing = 0.5 
     EXT met3_withslots < 0.5 ABUT>0<90 NOTCH SINGULAR // REGION 
   }
#ELSE
// ========== ATTENTION ==========
// ATTENTION : for 3 metal process M3 is top metal with spacing
// spacing of M4
// M3 space >= 0.6 if top metal, 0.5 if no top metal
// Minumim MET3 spacing = 0.6
   SPAC_MET3_M3S1 { @ M3_S_1 Minimum MET3 spacing = 0.6
     EXT met3_withslots < 0.6 ABUT>0<90 SPACE SINGULAR // REGION 
   }
// Minumim MET3 spacing = 0.6
   SPAC_MET3_NOTCH_M3S1 { @ M3_S_1 Minimum MET3 spacing = 0.6
     EXT met3_withslots  < 0.6 ABUT>0<90 NOTCH SINGULAR // REGION 
   }
// ========== ATTENTION ==========
#ENDIF
//
//
// VIA2 must be within M3 and enclosed by >= 0.15
// Minimum MET3 enclosure of VIA2 = 0.15 
   OVLP_MET3_VIA2_M3E1 { @ M3_E_1 Minimum MET3 enclosure of VIA2 = 0.15 
     ENC VIA2 met3_withslots < 0.15 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION 
   }
//
//
// Wide M3 space >= 0.80
// Minimum MET3 to WIDE_MET3 spacing = 0.8 
   SPAC_MET3WIDE_M3S2 { @ M3_S_2 Minimum MET3 to WIDE_MET3 spacing = 0.8 
         m3rd = SIZE MET3   BY -5.0
         m3gu = SIZE m3rd BY  5.0 TRUNCATE 2.0
         m3sa = SIZE m3gu BY 0.5
         m3sb = m3sa AND MET3
         m3sc = SIZE m3sb BY 0.5
         m3sd = m3sc AND MET3         //wide M3
         s3 = MET3 NOT m3sd
         drc_6 = EXT [m3sd] < 0.8 ABUT>0<90 SINGULAR
         wm3E = EXPAND EDGE drc_6 OUTSIDE BY 0.001
         wm3E NOT MET3
         EXT m3SD s3 < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// attention : chip is total area of all layers
// Minimum density of MET3 area [%] = 30 
   ILL_MET3_DIE_RATIO_M3R1 {@ M3_R_1 Minimum density of MET3 area [%] = 30 
     DENSITY MET3 < 0.3 PRINT "ratio_met3_die.txt"
   }
//
// skip via3/met4 for 3 metal process
//
#IFDEF fourmetal
//---------------------------------------------------------------------
//                          via3 rules
//---------------------------------------------------------------------

// VTOP width == 0.50
// Fixed VIA3 width = 0.5 
   WIDTH_VIA3_VIA3W1 { @ VIA3_W_1 Fixed VIA3 width = 0.5 
     NOT RECTANGLE VIA3 == 0.5 BY == 0.5
   }
//
// VTOP space >= 0.45
// Minimum VIA3 spacing = 0.45 
   SPAC_VIA3_VIA3S1 { @ VIA3_S_1 Minimum VIA3 spacing = 0.45 
     EXT VIA3 < 0.45 ABUT>0<90 SPACE SINGULAR REGION 
   }
//
// Minimum VIA3 spacing = 0.45 
   SPAC_VIA3_NOTCH_VIA3S1 { @ VIA3_S_1 Minimum VIA3 spacing = 0.45 
     EXT VIA3 < 0.45 ABUT>0<90 NOTCH SINGULAR REGION 
   }
//
// VTOP must be within  M3 and enclosed by >= 0.20
// Minimum MET3 enclosure of VIA3 = 0.2 
   OVLP_MET3_VIA3_VIA3E1 { @ VIA3_E_1 Minimum MET3 enclosure of VIA3 = 0.2 
     ENC VIA3 met3_withslots < 0.2 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
// VIA3 without MET3 is not allowed
   ILL_VIA3_ISOLATED_R01V3 {@ R01V3 VIA3 without MET3 is not allowed
       VIA3 NOT INSIDE MET3
   }
// via3 missing met3
   ILL_VIA3_MET3 {@ ERC Warning: via3 missing met3   
                 VIA3 NOT met3_withslots
   }
//---------------------------------------------------------------------
//                          metal4 rules
//                        met4 is mettop
//---------------------------------------------------------------------
// via3 missing met4
   ILL_VIA3_MET4 {@ ERC Warning: via3 missing met4   
                 VIA3 NOT met4_withslots
   }
//
// ATTENTION : For b35xx checks met4 width/spacing/and via overlap
//             is done in b35 part of DRC
//
// C35xx metal4 DRC checks
//
// MTOP width >= 0.60
// Minimum MET4 width = 0.6 
   WIDTH_MET4_M4W1 { @ M4_W_1 Minimum MET4 width = 0.6 
     INT met4_withslots < 0.6 ABUT>0<90 SINGULAR REGION 
   }
//
// MTOP space >= 0.60
// Minimum MET4 spacing = 0.6 
   SPAC_MET4_M4S1 { @ M4_S_1 Minimum MET4 spacing = 0.6 
     EXT met4_withslots < 0.6 ABUT>0<90 SPACE SINGULAR // REGION
   }
//
// Minimum MET4 spacing = 0.6 
   SPAC_MET4_NOTCH_M4S1 { @ M4_S_1 Minimum MET4 spacing = 0.6 
     EXT met4_withslots < 0.6 ABUT>0<90 NOTCH SINGULAR // REGION
   }
//
// VTOP must be within MTOP and enclosed by >= 0.15
// Minimum MET4 enclosure of VIA3 = 0.15 
   OVLP_MET4_VIA3_M4E1 { @ M4_E_1 Minimum MET4 enclosure of VIA3 = 0.15 
     ENC VIA3 met4_withslots < 0.15 ABUT<90 OVERLAP OUTSIDE ALSO SINGULAR REGION
   }
//
// Wide MTOP space >= 0.80
// Minimum MET4 to WIDE_MET4 spacing = 0.8 
   SPAC_MET4WIDE_M4S2 { @ M4_S_2 Minimum MET4 to WIDE_MET4 spacing = 0.8 
        mtoprd = SIZE MET4   BY -5.0
        mtopgu = SIZE mtoprd BY  5.0 TRUNCATE 2.0
        mtopsa = SIZE mtopgu BY 0.5
        mtopsb = mtopsa AND MET4
        mtopsc = SIZE mtopsb BY 0.5
        mtopsd = mtopsc AND MET4         //wide MTOP
        s4 = MET4 NOT mtopsd
        drc_7 = EXT [mtopsd] < 0.8 ABUT>0<90 SINGULAR
        wmtope = EXPAND EDGE drc_7 OUTSIDE BY 0.001
        wmtope NOT MET4
        EXT mtopsd s4 < 0.8 ABUT>0<90 SINGULAR REGION
   }
//
// attention : chip is total area of all layers
// Minimum density of MET4 area [%] = 30 
   ILL_MET4_DIE_RATIO_M4R1 {@ M4_R_1 Minimum density of MET4 area [%] = 30 
     DENSITY MET4 < 0.3 PRINT "ratio_met4_die.txt"
   }


#ENDIF
//
//---------------------------------------------------------------------
//                          pad rules
//---------------------------------------------------------------------
//
// check for pad stack
//--------------------
//
   m1pad   = PAD AND MET1
   m2pad   = PAD AND MET2
   m3pad   = PAD AND MET3
//
// following checks are not in doc, but should find
// errors
//
   ILL_DIFF_PAD_BAD1PA {@ ERC Warning: diffusion on pad          
                 PAD AND DIFF
   }
   ILL_POLY1_PAD_BAD2PA {@ ERC Warning: poly1 on pad
                 PAD AND POLY1
   }
   ILL_POLY2_PAD_BAD3PA {@ ERC Warning: poly2 on pad
                 PAD AND POLY2
   }
   ILL_CONT_PAD {@ ERC Warning: contact on pad 
                PAD AND CONT
   }
//
// check if bondpad is covered by metal
//
// this rule is recommendation only to allow 
// anlogue pad also
//
// Recommended bond stack:
   NO_MET1_UNDER_PAD_CBR1_REC {@ CBR1 recommended metal1 under pad
                bondpad NOT m1pad
   }
// Recommended bond stack:
   NO_MET2_UNDER_PAD_CBR1_REC {@ CBR1 recommended metal2 under pad
                bondpad NOT m2pad
   }
// Recommended bond stack:
   NO_MET3_UNDER_PAD_CBR1_REC {@ CBR1 recommended metal3 under pad
                bondpad NOT m3pad
   }
#IFDEF fourmetal
   m4pad   = PAD AND MET4
// Recommended bond stack:
   NO_MET4_UNDER_PAD_CBR1_REC {@ CBR1 recommended metal4 under pad
                bondpad NOT m4pad
   }
#ENDIF
//
// test probe pad info
//----------------------
//
   INFO_TEST_PROBE_PAD {@ INFO: Test or Probe pad < 70 * 70 U
               COPY te_pro_pad
   }
#IFDEF fourmetal
   ILL_MISS_MET4_PROBEPAD_ERC {@ ERC Warning: Missing met4 on Test/Probe Pad
               te_pro_pad NOT INSIDE MET4
   }
#ELSE
// check for missing top metal on test/probe pads
   ILL_MISS_MET3_PROBEPAD_ERC {@ ERC Warning: Missing met3 on Test/Probe Pad
               te_pro_pad NOT INSIDE MET3
   }
#ENDIF
//
//  check pads below 70*70 for minimum allowed size
// Minimum PAD width = 15 
   WIDTH_TEPROPAD_W1PA {@ W1PA  Minimum PAD width = 15 U 
                   INT te_pro_pad < 15 ABUT<90 SINGULAR REGION
   }
//
//  check bonding pad size
//  attention : bondpad = PAD - test and probe pads
//
//  bond pads are pads larger than 70 * 70
// Minimum bonding PAD width = 85 
// extra check rfpads
   WIDTH_BONDPAD_CBW1 {@ CB_W_1 Minimum bonding PAD width = 85 
                  INT (bondpad NOT rfpad_good) < 85 SINGULAR REGION
                  INT rfpad_good < 85 PARALLEL OPPOSITE SINGULAR REGION
   }
// Minimum PAD spacing = 15    
   SPAC_PAD_CBS1 {@ CB_S_1 Minimum PAD spacing = 15 
             EXT PAD < 15 SPACE SINGULAR REGION
   }
// Minimum PAD spacing = 15    
   SPAC_PAD_NOTCH_CBS1 {@ CB_S_1 Minimum PAD spacing = 15 
             EXT PAD < 15 NOTCH ABUT<90 SINGULAR REGION
   }
//
// for maximum check cbe1/2/3/4 see "other checks"
// overlap added due to test layout update
//
// Minimum MET1 enclosure of PAD = 5     
   OVLP_MET1_PAD_CBE1 {@ CB_E_1 Minimum MET1 enclosure of PAD = 5 
                  @ and PAD without MET1 is not allowed 
                  ENC PAD MET1 < 5 ABUT==0 
                  SINGULAR REGION
                  OVERLAP
                  //OUTSIDE ALSO SINGULAR REGION
   }
// Minimum MET2 enclosure of PAD = 5     
   OVLP_MET2_PAD_CBE2 {@ CB_E_2 Minimum MET2 enclosure of PAD = 5 
                  @ and PAD without MET2 is not allowed 
                  ENC PAD MET2 < 5 ABUT==0 
                  SINGULAR REGION
                  OVERLAP
                  //OUTSIDE ALSO SINGULAR REGION
   }
// Minimum MET3 enclosure of PAD = 5     
   OVLP_MET3_PAD_CBE3 {@ CB_E_3 Minimum MET3 enclosure of PAD = 5 
                  @ and PAD without MET3 is not allowed 
                  ENC PAD MET3 < 5 ABUT==0 
                  SINGULAR REGION
                  OVERLAP
                  //OUTSIDE ALSO SINGULAR REGION
   }
#IFDEF fourmetal
// Minimum MET4 enclosure of PAD = 5.0     
   OVLP_MET4_PAD_CBE4 {@ CB_E_4 Minimum MET4 enclosure of PAD = 5.0 
                  @ and PAD without MET4 is not allowed 
                  ENC PAD MET4 < 5.0 ABUT==0 
                  SINGULAR REGION
                  OVERLAP
                  //OUTSIDE ALSO SINGULAR REGION
   }
#ENDIF
//
//
// pad vias extend pad window, get all vias near pad metal
   pad_allovs = SIZE PAD by 5.0 
   padvia  = VIA  INTERACT pad_allovs
   padvia2 = VIA2 INTERACT pad_allovs
   padvia3  = VIA3 INTERACT pad_allovs
   padvia_or_padvia2  = padvia OR padvia2
   padvia2_or_padvia3 = padvia2 OR padvia3
//
// only near pad 
   m1padpolyg = (MET1 INTERACT PAD) AND pad_allovs
   m2padpolyg = (MET2 INTERACT PAD) AND pad_allovs
   m3padpolyg = (MET3 INTERACT PAD) AND pad_allovs
//
// Minimum MET1 enclosure of the nearest PADVIA1 = 3 
   OVLP_PADVIA_MET1_CBE5 {@ CB_E_5 Minimum MET1 enclosure of the nearest PADVIA1 = 3 
                 ENC padvia MET1 < 3 ABUT==0
                 SINGULAR REGION 
   }
//
// cbe6,cbe8,cbe10,cbe12 : this rules have been removed in new drc rev
//
#UNDEFINE tsmc_orig_drc
//
// create 4 rectangles 
//
   pad_ring_m1 = EXPAND EDGE m1padpolyg INSIDE BY 6.0 EXTEND BY -7.0
   pad_ring_m2 = EXPAND EDGE m2padpolyg INSIDE BY 6.0 EXTEND BY -7.0
   pad_ring_m3 = EXPAND EDGE m3padpolyg INSIDE BY 6.0 EXTEND BY -7.0
//
#IFDEF fourmetal
   m4padpolyg  = (MET4 INTERACT PAD) AND pad_allovs
   pad_ring_m4 = EXPAND EDGE m4padpolyg INSIDE BY 6.0 EXTEND BY -7.0
#ENDIF
//
// check diamond shapes of via arrays on bondpad only
//
   padvia_merge  = (SIZE padvia   BY 2.0 OVERUNDER) AND bondpad
   padvia2_merge = (SIZE padvia2  BY 2.0 OVERUNDER) AND bondpad
//
// check via area to pad area ratio, must be about 0.5
// via array area must touch 4 sides
//
// change to info
//
// Minimum MET1 enclosure of the nearest PADVIA1 = 3 
   INFO_PADVIA_NO_DIAMOND_CBE5 { @ INFO CB_E_5 no or bad diamond shape of padvia array (must have 4 corners)
         ok = DENSITY padvia_merge INSIDE OF LAYER bondpad > 0.47 < 0.53
         //print diamond1.txt
         padvia_merge NOT ok
         padvia_merge NOT INTERACT pad_ring_m1 == 4
   }
// Minimum MET2 enclosure of the nearest PADVIA2 and PADVIA1 = 3 
   INFO_PADVIA2_NO_DIAMOND_CBE7 { @ INFO CB_E_7 no or bad diamond shape of padvia2 array (must have 4 corners)
         ok = DENSITY padvia2_merge INSIDE OF LAYER bondpad > 0.47 < 0.53
         // print diamond2.txt
         padvia2_merge NOT ok
         padvia2_merge NOT INTERACT pad_ring_m2 == 4
   }
#IFDEF fourmetal
   padvia3_merge = (SIZE padvia3  BY 2.0 OVERUNDER) AND bondpad
// Minimum MET3 enclosure of the nearest PADVIA3 and PADVIA2 = 3.0 
   INFO_PADVIA3_NO_DIAMOND_CBE9 { @ INFO CB_E_9 no or bad diamond shape of padvia3 array (must have 4 corners)
         ok = DENSITY padvia3_merge INSIDE OF LAYER bondpad > 0.47 < 0.53
         padvia3_merge NOT ok
         padvia3_merge NOT INTERACT pad_ring_m3 == 4
   }
#ENDIF
//
#IFDEF tsmc_orig_drc
// _CB_E_6_ 
   OVLPMAX_PADVIA_MET1_CBE6 {@ CB_E_6 _CB_E_6_ 
          pad_ring_m1 NOT ENCLOSE padvia >= 1 <=2
   }
#ENDIF
//
// Minimum MET2 enclosure of the nearest PADVIA2 and PADVIA1 = 3 
   OVLP_PADVIA_MET2_CBE7 {@ CB_E_7 Minimum MET2 enclosure of the nearest PADVIA2 and PADVIA1 = 3  U
                 ENC padvia MET2 < 3 ABUT==0
                 SINGULAR REGION 
   }
// Minimum MET2 enclosure of the nearest PADVIA2 and PADVIA1 = 3 
   OVLP_PADVIA2_MET2_CBE7 {@ CB_E_7 Minimum MET2 enclosure of the nearest PADVIA2 and PADVIA1 = 3  U
                 ENC padvia2 MET2 < 3 ABUT==0
                 SINGULAR REGION 
   }
#IFDEF tsmc_orig_drc
// max
// _CB_E_8_
   OVLPMAX_PADVIA_MET2_CBE8 {@ CB_E_8 _CB_E_8_ U
          pad_ring_m2 NOT ENCLOSE padvia_or_padvia2 >=1 <=3
   }
// _CB_E_8_ 
   OVLPMAX_PADVIA2_MET2_CBE8 {@ CB_E_8 _CB_E_8_  U
          pad_ring_m2 NOT INTERACT padvia2
   }
#ENDIF
//
// Minimum MET3 enclosure of the nearest PADVIA3 and PADVIA2 = 3.0 
   OVLP_PADVIA2_MET3_CBE9 {@ CB_E_9 Minimum MET3 enclosure of the nearest PADVIA3 and PADVIA2 = 3.0  U
                 ENC padvia2 MET3 < 3.0 ABUT==0
                 SINGULAR REGION 
   }
#IFDEF fourmetal
// Minimum MET3 enclosure of the nearest PADVIA3 and PADVIA2 = 3.0 
   OVLP_PADVIA3_MET3_CBE9 {@ CB_E_9 Minimum MET3 enclosure of the nearest PADVIA3 and PADVIA2 = 3.0  U
                 ENC padvia3 MET3 < 3.0 ABUT==0
                 SINGULAR REGION 
   }
#ENDIF
#IFDEF tsmc_orig_drc
// max
// _CB_E_10_ 
   OVLPMAX_PADVIA2_MET3_CBE10 {@ CB_E_10 _CB_E_10_  U
          pad_ring_m3 NOT ENCLOSE padvia2_or_padvia3 >=1 <=3
   }
#ENDIF
#IFDEF fourmetal
#IFDEF tsmc_orig_drc
// _CB_E_10_ _CB_E_10
   OVLPMAX_PADVIA3_MET3_CBE10 {@ CB_E_10 _CB_E_10_  U
          pad_ring_m3 NOT ENCLOSE padvia3 >=1 <=2
   }
#ENDIF
//
// Minimum MET4 enclosure of the nearest PADVIA3 = 3.0 
   OVLP_PADVIA3_MET4_CBE11 {@ CB_E_11 Minimum MET4 enclosure of the nearest PADVIA3 = 3.0  U
                 ENC padvia3 MET4 < 3.0 ABUT==0
                 SINGULAR REGION 
   }
#IFDEF tsmc_orig_drc
// _CB_E_12_ 
   OVLPMAX_PADVIA3_MET4_CBE12 {@ CB_E_12 _CB_E_12_ U
          pad_ring_m4 NOT ENCLOSE padvia3 >=1 <=2
   }
#ENDIF
#ENDIF
//
// fixed padvia width already checked by via width
//
// CBW2 : Fixed PADVIA1 width = 0.5
// CBW3 : Fixed PADVIA2 width = 0.5
// CBW4 : Fixed PADVIA3 width = 0.5
//
// Minimum PADVIA1 spacing = 0.8   
   SPAC_PADVIA_CBS2 {@ CB_S_2 Minimum PADVIA1 spacing = 0.8  U
              EXT padvia < 0.8 SPACE SINGULAR  REGION
   }
// Minimum PADVIA2 spacing = 0.8   
   SPAC_PADVIA2_CBS3 {@ CB_S_3 Minimum PADVIA2 spacing = 0.8 U
              EXT padvia2 < 0.8 SPACE SINGULAR  REGION
   }
#IFDEF fourmetal
// Minimum PADVIA3 spacing = 0.8   
   SPAC_PADVIA3_CBS4 {@ CB_S_4 Minimum PADVIA3 spacing = 0.8  U
              EXT padvia3 < 0.8 SPACE SINGULAR  REGION
   }
#ENDIF
// Minimum PADVIA2 to PADVIA1 spacing = 0.3 
   SPAC_PADVIAVIA2_CBC1 {@ CB_C_1 Minimum PADVIA2 to PADVIA1 spacing = 0.3  U
              EXT padvia padvia2 < 0.3 SINGULAR  REGION
   }
#IFDEF fourmetal
// Minimum PADVIA3 to PADVIA2 spacing = 0.3 
   SPAC_PADVIA2VIA3_CBC2 {@ CB_C_2 Minimum PADVIA3 to PADVIA2 spacing = 0.3  U
              EXT padvia3 padvia2 < 0.3 SINGULAR  REGION
   }
#ENDIF
//
// Minimum ratio of PADVIA1 area to PAD area [%] = 5 
   ILL_PADVIA_PAD_RATIO_CBR2 { @ CB_R_2 Minimum ratio of PADVIA1 area to PAD area [%] = 5 
           DENSITY padvia INSIDE OF LAYER PAD < 0.05      
   }
// Minimum ratio of PADVIA2 area to PAD area [%] = 5 
   ILL_PADVIA2_PAD_RATIO_CBR3 { @ CB_R_3 Minimum ratio of PADVIA2 area to PAD area [%] = 5 
           DENSITY padvia2 INSIDE OF LAYER PAD < 0.05      
   }
#IFDEF fourmetal
// Minimum ratio of PADVIA2 area to PAD area [%] = 5 
   ILL_PADVIA3_PAD_RATIO_CBR4 { @ CB_R_4 Minimum ratio of PADVIA3 area to PAD area [%] = 5 
           DENSITY padvia3 INSIDE OF LAYER PAD < 0.05      
   }
#ENDIF
//
// illegal pad via stack
   ILL_PADVIA_PADVIA2_CBC2 {@ CB_C_2 illegal pad via stack via1/via2
                 padvia AND padvia2
   }
#IFDEF fourmetal
// illegal pad via stack
   ILL_PADVIA2_PADVIA3_CBC3 {@  CB_C_3 illegal pad via stack via2/via3
                 padvia2 AND padvia3
   }
#ENDIF
//
// Spacing between pads and other layers is only checked for bondpads
// because test and probe pads might not be based on this design rules

// Minimum PAD to DIFF spacing = 9 
   SPAC_DIFF_BONDPAD_S1DFPA {@ S1DFPA Minimum PAD to DIFF spacing = 9  U
                      EXT DIFF bondpad < 9 ABUT==0
                      SINGULAR REGION
   }
// Minimum PAD to POLY1 spacing = 9 
   SPAC_POLY1_BONDPAD_S1P1PA {@ S1P1PA Minimum PAD to POLY1 spacing = 9  U
                       EXT bondpad routingpoly  < 9 ABUT==0
                       SINGULAR MEASURE ALL REGION
   }
// Minimum PAD to POLY2 spacing = 9 
   SPAC_POLY2_BONDPAD_S1P2PA {@ S1P2PA Minimum PAD to POLY2 spacing = 9 U
                       EXT bondpad POLY2 < 9 ABUT==0
                       SINGULAR REGION
   }
//
// attention : measure all allows spacing check if pad
// is enclosed by same layer !!!
//
// Minimum PAD to MET1 spacing (different net) = 9 
   SPAC_MET1_BONDPAD_S1M1PA {@ S1M1PA Minimum PAD to MET1 spacing (different net) = 9  U
                      EXT bondpad routingmet1 < 9 ABUT==0
                      NOT CONNECTED MEASURE ALL SINGULAR REGION
   }
// Minimum PAD to MET2 spacing (different net) = 9 
   SPAC_MET2_BONDPAD_S1M2PA {@ S1M2PA Minimum PAD to MET2 spacing (different net) = 9  U
                      EXT bondpad  routingmet2 < 9 ABUT==0
                      NOT CONNECTED MEASURE ALL SINGULAR REGION
   }
// Minimum PAD to MET3 spacing (different net) = 9 
   SPAC_MET3_BONDPAD_S1M3PA {@ S1M3PA Minimum PAD to MET3 spacing (different net) = 9  U
                      EXT bondpad  routingmet3 < 9 ABUT==0
                      NOT CONNECTED MEASURE ALL SINGULAR REGION
   }
#IFDEF fourmetal
// Minimum PAD to MET4 spacing (different net) = 9.0 
   SPAC_MET4_BONDPAD_S1M4PA {@ S1M4PA Minimum PAD to MET4 spacing (different net) = 9.0 U
                      EXT bondpad  routingmet4 < 9.0 ABUT==0
                      NOT CONNECTED MEASURE ALL SINGULAR REGION
   }
#ENDIF
//
// check for pad without top metal
// ----------------------------------
//
// PAD without MET4 is not allowed
#IFDEF fourmetal
   ILL_PAD_MISSING_MET4_R01PA {@ R01PA Pad without met4 is not allowed
       PAD NOT INSIDE MET4
   }
#ELSE
   ILL_PAD_MISSING_MET3_R01PA {@ R01PA Pad without met3 is not allowed
       PAD NOT INSIDE MET3
   }
#ENDIF
//
//---------------------------------------------------------------------
//                           hres rules
//---------------------------------------------------------------------

// resistor body is poly2 for hres

// Minimum HRES width = 0.6
   WIDTH_HRES_W1HR {@ W1HR Minimum HRES width = 0.6  U
               INT HRES < 0.6 ABUT<90 SINGULAR REGION
   }
// Minimum HRES spacing = 0.6 
   SPAC_HRES_S1HRHR {@ S1HRHR Minimum HRES spacing = 0.6  U
              EXT HRES < 0.6 SPACE SINGULAR REGION
   }
// Minimum HRES spacing = 0.6 
   SPAC_HRES_NOTCH_S1HRHR {@ S1HRHR Minimum HRES spacing = 0.6  U
                    EXT HRES < 0.6 NOTCH ABUT<90 SINGULAR REGION
   }
// HRES is not allowed over DIFF 
   ILL_HRES_DIFF_BAD1HR {@ BAD1HR  
                   HRES AND DIFF
   }
// HRES is not allowed over NPLUS 
   ILL_HRES_NPLUS_BAD2HR {@ BAD2HR 
                   HRES AND NPLUS
   }
// HRES is not allowed over POLY1 
   ILL_HRES_POLY1_BAD3HR {@ BAD3HR  
                   HRES AND POLY1
   }
// add inside alos due to test layout
// Minimum HRES enclosure of POLY2 = 3 
   OVLP_HRES_POLY2_E1HRP2 {@ E1HRP2 Minimum HRES enclosure of POLY2 = 3  U
                    ENC poly2_cut HRES < 3 ABUT==0
                    INSIDE ALSO  OVERLAP SINGULAR REGION
   }
// Minimum HRES to POLY1 spacing = 0.35 
   SPAC_HRES_POLY1_S1HRP1 {@ S1HRP1 Minimum HRES to POLY1 spacing = 0.35  U
                    EXT HRES poly1_cut < 0.35 ABUT==0 SINGULAR REGION
   }
// Minimum HRES to POLY2 spacing = 3 
   SPAC_HRES_POLY2_S1HRP2 {@ S1HRP2 Minimum HRES to POLY2 spacing = 3  U
                    EXT HRES poly2_cut < 3 ABUT==0 SINGULAR REGION
   }
// Minimum HRES to DIFF spacing = 0.35 
   SPAC_HRES_DIFF_S1DFHR {@ S1DFHR Minimum HRES to DIFF spacing = 0.35  U
                   EXT HRES DIFF < 0.35 ABUT==0
                   SINGULAR REGION
   }

//---------------------------------------------------------------------
//                          scribe rules
//---------------------------------------------------------------------

// Currently not checked

//---------------------------------------------------------------------
//                          element rules
//---------------------------------------------------------------------
//
//  cpoly
//-------------
//  PPLUS on CPOLY is not allowed 
   ILL_PPLUS_CPOLY_RECG1 { @ CPOLY_G1 PPLUS on CPOLY is not allowed
             PPLUS AND cpoly
             }
// NPLUS on CPOLY is not allowed 
   ILL_NPLUS_CPOLY_RECG2 { @ CPOLY_G2 NPLUS on CPOLY is not allowed
             NPLUS AND cpoly
             }
//
// next 2 checks are not in doc, but give error, if implant too near
// PPLUS on CPOLY is not allowed 
   SPAC_PPLUS_CPOLY_RECG1 {@ CPOLY_G1 Warning : Spacing pplus cpoly < 1 U
                     EXT PPLUS cpoly < 1.0 ABUT==0
                     SINGULAR REGION
   }
// NPLUS on CPOLY is not allowed 
   SPAC_NPLUS_CPOLY_RECG2 {@ CPOLY_G2 Warning : Spacing nplus cpoly < 1 U
                     EXT NPLUS cpoly < 1.0 ABUT==0
                     SINGULAR REGION
   }
//
// use same rules for rpoly1 used for rpoly2
//
// rpoly1
//--------
//  PPLUS on RPOLY1 is not allowed
   ILL_PPLUS_RPOLY1_R1 { @ RPOLY1_R1 PPLUS on RPOLY1 is not allowed
       PPLUS AND pres1
   }
//  NPLUS on RPOLY1 is not allowed
   ILL_NPLUS_RPOLY1_R2 { @ RPOLY1_R2 NPLUS on RPOLY1 is not allowed
       NPLUS AND pres1
   }
// RPOLY1: Recommended minimum number of squares L/W >= 5
// Minimum number of RPOLY1 squares = 5
   ILL_RPOLY1_RATIO_RECG1 {@ RPOLY1_G1 Minimum number of RPOLY1 squares = 5
       NET AREA RATIO pres1_lexp_net pres1_wexp_net < 5
   }
//
// rpoly2
//--------
//  PPLUS on RPOLY2 is not allowed
   ILL_PPLUS_RPOLY2_R1 { @ RPOLY2_R1 PPLUS on RPOLY2 is not allowed
       PPLUS AND pres        
   }
//  NPLUS on RPOLY2 is not allowed
   ILL_NPLUS_RPOLY2_R2 { @ RPOLY2_R2 NPLUS on RPOLY2 is not allowed
       NPLUS AND pres        
   }
// RPOLY2: Recommended minimum number of squares L/W >= 5
// Minimum number of RPOLY2 squares = 5
   ILL_RPOLY2_RATIO_RECG1 {@ RPOLY2_G1 Minimum number of RPOLY2 squares = 5
       NET AREA RATIO pres_lexp_net pres_wexp_net < 5
   }
//
// rnwell
//--------
// Minimum number of RNWELL squares = 5
// RNWELL: Recommended minimum number of squares L/W >=5
   ILL_RNWELL_RATIO_RECG1 {@ RNWELL_G1 Minimum number of RNWELL squares = 5
       NET AREA RATIO nwres_lexp_net nwres_wexp_net < 5
   }
//
// rpolyh
//--------
//
// rpolyhcon is poly2con
// Minimum PPLUS enclosure of POLY2CON = 0.6
   OVLP_PPLUS_RPHCON_E1IPCT {@ E1IPCT Minimum PPLUS enclosure of POLY2CON = 0.6 U
                 ENC rpolyhcon PPLUS < 0.6 ABUT==0
                 OUTSIDE ALSO SINGULAR REGION
   }
// POLY2CON on RPOLYH is not allowed without PPLUS
   ILL_POLY2CON_E1IPCT {@ E1IPCT POLY2CON on RPOLYH is not allowed without PPLUS
                 rpolyhcon NOT PPLUS
   }
//
// combine edge and polygon check to cover all possible errors
// Minimum PPLUS to RPOLYH spacing = 0.35 
   SPAC_PPLUS_RPOLYH_S1IPP2 {@ S1IPP2 Minimum PPLUS to RPOLYH spacing = 0.35 U
        EXT (POLY2 INSIDE HRES) PPLUS < 0.35 REGION SINGULAR ABUT == 0
        EXT (presh NOT COINCIDENT OUTSIDE EDGE (preshterm ENCLOSE poly2con)) PPLUS < 0.35 REGION ABUT == 0
   }
// Minimum number of RPOLYH squares = 5
   ILL_RPOLYH_RATIO_RECG1 {@ RPOLYH_G1 Minimum number of RPOLYH squares = 5
       NET AREA RATIO presh_lexp_net presh_wexp_net < 5
   }
// Minimum high precision RPOLYH width = 2
   WIDTH_RPOLYH_RECG2 {@ RPOLYH_G2 Minimum high precision RPOLYH width = 2
        INT presh_1 < 2 SINGULAR REGION
   }
// 
//---------------------------------------------------------------------
//                          Metal Slot Rules
//---------------------------------------------------------------------
//
// DRC SELECT CHECK HOLE_CHECKS

// select all hole checks
   GROUP HOLECHECK_ALL ?_AMW0 ?_AMW1 ?_AML1 ?_AML2 ?_AMS? ?_AMC1 ?_AMC2 
// end group

// select only missing areas
   GROUP HOLECHECK ?_NOHOLES_?
// end group
//
// identify slots with holes command directly from metal
// This allows identification of holes both from drawn metal and from   
// holes layer which cuts metal
//
// flow for this check :
// wide metal with slots inside cannot be found by sizing
// holes are closed before underover
//   - remove small metal to reduce data
//   - get all holes ( hole in hole )
//   - close small holes by expandig edges inside to avoid large size
//   - do underover to get met > 35
//   - holes < 4.0 U  inside of large metal are checked for rules
//     4 U is used to avoid too much false errors
//
//------------------------------------------------------
// remove small metal lines for data reduction 
   met1_wide_1 = SIZE ( SIZE met1_withslots BY -0.5) BY 0.5 TRUNCATE 0.5
// no area constraint possible
   met1_holes  = (HOLES met1_wide_1) NOT met1_wide_1
// no slot if other metal inside
// and avoid hole inside hole
   m1_hole_1   = (met1_holes TOUCH met1_wide_1 == 1) NOT ENCLOSE MET1
// get hole edge
   met1_wide_hole_edge  = m1_hole_1 COINCIDENT OUTSIDE EDGE met1_wide_1
   met1_h_edge          = met1_wide_hole_edge EXPAND EDGE INSIDE BY 1.0
// close hole inside
   met1_h_fill = SIZE met1_h_edge BY 10 INSIDE OF m1_hole_1
// wide metal with closed holes
   met1_wide_gapclos =  met1_wide_1 OR met1_h_fill
// this wide metal must have holes
   met1_wide_nogap_35 = SIZE met1_wide_gapclos BY 17.5 UNDEROVER 
// holes smaller 4 U for checking
   m1_hole = (m1_hole_1 INSIDE met1_wide_nogap_35 ) INTERACT ( INT m1_hole_1 < 4.0 REGION ) 
// this is wide met with NO holes
   met1_wide = (met1_wide_1 TOUCH m1_hole ) OR m1_hole

// for debug
//
//   met1_holes { COPY met1_holes }
//   met1_h_edge { COPY met1_h_edge }
//   met1_wide { COPY met1_wide }
//   met1_wide_1 { COPY met1_wide_1 }
//   met1_wide_gapclos { COPY met1_wide_gapclos }
//   met1_wide_nogap_35  { COPY met1_wide_nogap_35 }
//   m1_hole_1 { COPY m1_hole_1 }
//
//------------------------------------------------------
//
   met2_wide_1 = SIZE ( SIZE met2_withslots BY -0.5) BY 0.5 TRUNCATE 0.5
   met2_holes  = (HOLES met2_wide_1) NOT met2_wide_1
   m2_hole_1   = (met2_holes TOUCH met2_wide_1 == 1) NOT ENCLOSE MET2
   met2_wide_hole_edge  = m2_hole_1 COINCIDENT OUTSIDE EDGE met2_wide_1
   met2_h_edge          = met2_wide_hole_edge EXPAND EDGE INSIDE BY 1.0
   met2_h_fill = SIZE met2_h_edge BY 10 INSIDE OF m2_hole_1
   met2_wide_gapclos =  met2_wide_1 OR met2_h_fill
   met2_wide_nogap_35 = SIZE met2_wide_gapclos BY 17.5 UNDEROVER 
   m2_hole = (m2_hole_1 INSIDE met2_wide_nogap_35 ) INTERACT ( INT m2_hole_1 < 4.0 REGION ) 
   met2_wide = (met2_wide_1 TOUCH m2_hole) OR m2_hole
//
//------------------------------------------------------
//
   met3_wide_1 = SIZE ( SIZE met3_withslots BY -0.5) BY 0.5 TRUNCATE 0.5
   met3_holes  = (HOLES met3_wide_1) NOT met3_wide_1
   m3_hole_1   = (met3_holes TOUCH met3_wide_1 == 1) NOT ENCLOSE MET3
   met3_wide_hole_edge  = m3_hole_1 COINCIDENT OUTSIDE EDGE met3_wide_1
   met3_h_edge          = met3_wide_hole_edge EXPAND EDGE INSIDE BY 1.0
   met3_h_fill = SIZE met3_h_edge BY 10 INSIDE OF m3_hole_1
   met3_wide_gapclos =  met3_wide_1 OR met3_h_fill
   met3_wide_nogap_35 = SIZE met3_wide_gapclos BY 17.5 UNDEROVER 
   m3_hole = (m3_hole_1 INSIDE met3_wide_nogap_35 ) INTERACT ( INT m3_hole_1 < 4.0 REGION ) 
   met3_wide = (met3_wide_1 TOUCH m3_hole) OR m3_hole
//
// for debug
//
// m1_hole { COPY m1_hole }
// m2_hole { COPY m2_hole }
// m3_hole { COPY m3_hole }
// get drawn holes
// m1_drawn_hole { m1_hole NOT INTERACT M1HOLE }
// m2_drawn_hole { m2_hole NOT INTERACT M2HOLE }
// m3_drawn_hole { m3_hole NOT INTERACT M3HOLE }
// 
#IFDEF fourmetal
   met4_wide_1 = SIZE ( SIZE met4_withslots BY -0.5) BY 0.5 TRUNCATE 0.5
   met4_holes  = (HOLES met4_wide_1) NOT met4_wide_1
   m4_hole_1   = (met4_holes TOUCH met4_wide_1 == 1) NOT ENCLOSE MET4
   met4_wide_hole_edge  = m4_hole_1 COINCIDENT OUTSIDE EDGE met4_wide_1
   met4_h_edge          = met4_wide_hole_edge EXPAND EDGE INSIDE BY 1.0
   met4_h_fill = SIZE met4_h_edge BY 10 INSIDE OF m4_hole_1
   met4_wide_gapclos =  met4_wide_1 OR met4_h_fill
   met4_wide_nogap_35 = SIZE met4_wide_gapclos BY 17.5 UNDEROVER 
   m4_hole = (m4_hole_1 INSIDE met4_wide_nogap_35 ) INTERACT ( INT m4_hole_1 < 4.0 REGION ) 
   met4_wide = (met4_wide_1 TOUCH m4_hole) OR m4_hole
//
// m4_hole { COPY m4_hole }
// m4_drawn_hole { m4_hole NOT INTERACT M4HOLE }
//
#ENDIF
//
// find areas without slots
//
// Maximum METx width = 35
   ILL_MET1_NOHOLES_AMW0 { @ AMW0 Wide M1 > 35um should have slots.
      SIZE (met1_wide_1 NOT PAD) BY 17.5 UNDEROVER 
   }
//
// Maximum METx width = 35
   ILL_MET2_NOHOLES_AMW0 { @ AMW0 Wide M2 > 35um should have slots.
      SIZE (met2_wide_1 NOT PAD) BY 17.5 UNDEROVER 
   }
//
// Maximum METx width = 35
   ILL_MET3_NOHOLES_AMW0 { @ AMW0 Wide M3 > 35um should have slots.
      SIZE (met3_wide_1 NOT PAD) BY 17.5 UNDEROVER 
   }
//
#IFDEF fourmetal
// Maximum METx width = 35
   ILL_MET4_NOHOLES_AMW0 { @ AMW0 Wide M4 > 35um should have slots.
      SIZE (met4_wide_1 NOT PAD) BY 17.5 UNDEROVER 
   }
#ENDIF
// 
// Open M1/2/3/4 Slot width must be exactly == 3.0
// change sizing from -1.55 to -1.5
// is this ok for 45 degree slots with rounding ?
// no, we need 1.55 
// Fixed slot width = 3 3
   WIDTH_M1SLOT_AMW1 { @ AMW1 metal1 Fixed slot width = 3
       INT m1_hole < 3 ABUT>0<90 SINGULAR REGION
       SIZE m1_hole BY -1.55 
   }
//
   WIDTH_M2SLOT_AMW1 { @ AMW1 metal2 Fixed slot width = 3
       INT m2_hole < 3 ABUT>0<90 SINGULAR REGION
       SIZE m2_hole BY -1.55 
   }
//
   WIDTH_M3SLOT_AMW1 { @ AMW1 metal3 Fixed slot width = 3
       INT m3_hole < 3 ABUT>0<90 SINGULAR REGION
       SIZE m3_hole BY -1.55  
   }
//
#IFDEF fourmetal
   WIDTH_M4SLOT_AMW1 { @ AMW1 metal4 Fixed slot width = 3
       INT m4_hole < 3 ABUT>0<90 SINGULAR REGION
       SIZE m4_hole BY -1.55  
   }
#ENDIF
//
// Open M1 Slot Minimum Length >= 30
// Minimum slot length = 30
   sl1_sid = INT [m1_hole] < 4.25 OBTUSE ALSO
   LENGTH_M1SLOT_AML1 { @ AML1 metal1 Minimum slot length = 30
         PATH LENGTH sl1_sid < 30
   }
// Open M1 Slot Maximum Length <= 300
// Maximum slot length = 300
   LENGTH_M1SLOT_MAX_AML2 { @ AML2 metal1 Maximum slot length = 300
         PATH LENGTH sl1_sid > 300
   }
//
// Open M2 Slot Minimum Length >= 30
// Minimum slot length = 30
   sl2_sid = INT [m2_hole] < 4.25 OBTUSE ALSO
   LENGTH_M2SLOT_AML1 { @ AML1 metal2 Minimum slot length = 30
         PATH LENGTH sl2_sid < 30
   }
// Open M2 Slot Maximum Length <= 300
// Maximum slot length = 300
   LENGTH_M2SLOT_MAX_AML2 { @ AML2 metal2 Maximum slot length = 300
         PATH LENGTH sl2_sid > 300
   }
//
// Open M3 Slot Minimum Length >= 30
// Minimum slot length = 30
   sl3_sid = INT [m3_hole] < 4.25 OBTUSE ALSO
   LENGTH_M3SLOT_AML1 { @ AML1 metal3 Minimum slot length = 30
         PATH LENGTH sl3_sid < 30
   }
// Open M3 Slot Maximum Length <= 300
// Maximum slot length = 300
   LENGTH_M3SLOT_MAX_AML2 { @ AML2 metal3 Maximum slot length = 300
         PATH LENGTH sl3_sid > 300
   }
//
#IFDEF fourmetal
//
// Open M4 Slot Minimum Length >= 30
// Minimum slot length = 30
   sl4_sid = INT [m4_hole] < 4.25 OBTUSE ALSO
   LENGTH_M4SLOT_AML1 { @ AML1 metal4 Minimum slot length = 30
         PATH LENGTH sl4_sid < 30
   }
// Open M4 Slot Maximum Length <= 300
// Maximum slot length = 300
   LENGTH_M4SLOT_MAX_AML2 { @ AML2 metal4 Maximum slot length = 300
         PATH LENGTH sl4_sid > 300
   }
#ENDIF
//
// Open M1-Slot to M1-Slot space >= 10.0
// Minimum spacing between two parallel slots = 10
// Minimum spacing between two slots in a sequence = 10
   SPAC_M1HOLE_AMS1 { @ AMS1 metal1 Minimum spacing between two parallel slots = 10
         EXT m1_hole < 10 ABUT>0<90 SINGULAR REGION 
   }
// Minimum spacing between two parallel slots = 10
   SPAC_M2HOLE_AMS1 { @ AMS1 metal2 Minimum spacing between two parallel slots = 10
         EXT m2_hole < 10 ABUT>0<90 SINGULAR REGION 
   }
// Minimum spacing between two parallel slots = 10
   SPAC_M3HOLE_AMS1 { @ AMS1 metal3 Minimum spacing between two parallel slots = 10
         EXT m3_hole < 10 ABUT>0<90 SINGULAR REGION 
   }
#IFDEF fourmetal
// Minimum spacing between two parallel slots = 10
   SPAC_M4HOLE_AMS1 { @ AMS1 metal4 Minimum spacing between two parallel slots = 10
         EXT m4_hole < 10 ABUT>0<90 SINGULAR REGION 
   }
#ENDIF
//
//
// Open M1-Slot to M2-Slot space >= 2.0; No overlap allowed.
// Open M2-Slot to M3-Slot space >= 2.0; No overlap allowed.
// Open M3-Slot to M4-Slot space >= 2.0; No overlap allowed.
//
// Minimum slots spacing between neighbour layers  = 2
   SPAC_M1M2HOLE_AMC1 { @ AMC1 met1 met2  2
        EXT m1_hole m2_hole < 2 ABUT<90 SINGULAR INSIDE ALSO REGION 
   }
   SPAC_M2M3HOLE_AMC1 { @ AMC1 met2 met3  2
        EXT m2_hole m3_hole < 2 ABUT<90 SINGULAR INSIDE ALSO REGION 
   }
#IFDEF fourmetal
   SPAC_M3M4HOLE_AMC1 { @ AMC1 met3 met4  2
        EXT m3_hole m4_hole < 2 ABUT<90 SINGULAR INSIDE ALSO REGION 
   }
#ENDIF
//
// Open M1-Slot enclosed by M1 >= 10.0
// Open M2-Slot enclosed by M2 >= 10.0
// Open M3-Slot enclosed by M3 >= 10.0
// Open M4-Slot enclosed by M4 >= 10.0
//
// Minimum slot to inner metal edge spacing = 10
// Minimum slot to outer metal edge spacing = 10
// change met1 by wide met1
   OVLP_MET1_M1HOLE_AMC2 { @ AMC2/AMC3 metal1 Minimum slot to inner metal edge spacing = 10
        ENC m1_hole met1_wide < 10 ABUT>0<90  OPPOSITE MEASURE ALL REGION
   }
   OVLP_MET2_M2HOLE_AMC2 { @ AMC2/AMC3 metal2 Minimum slot to inner metal edge spacing = 10
        ENC m2_hole met2_wide < 10 ABUT>0<90  OPPOSITE MEASURE ALL REGION
   }
   OVLP_MET3_M3HOLE_AMC2 { @ AMC2/AMC3 metal3 Minimum slot to inner metal edge spacing = 10
        ENC m3_hole met3_wide < 10 ABUT>0<90  OPPOSITE MEASURE ALL REGION
   }
#IFDEF fourmetal
   OVLP_MET4_M4HOLE_AMC2 { @ AMC2/AMC3 metal4 Minimum slot to inner metal edge spacing = 10
        ENC m4_hole met4_wide < 10 ABUT>0<90  OPPOSITE MEASURE ALL REGION
   }
#ENDIF
//
// bad slots 
// also checked by other checks
//
   ILL_OUT_M1HOLE_AMW0 {@ AM ERROR BAD SLOT: met1 hole outside met1
                   M1HOLE NOT MET1
   }
   ILL_OUT_M2HOLE_AMW0 {@ AM ERROR BAD SLOT: met2 hole outside met2
                   M2HOLE NOT MET2
   }
   ILL_OUT_M3HOLE_AMW0 {@ AM ERROR BAD SLOT: met3 hole outside met3
                   M3HOLE NOT MET3
   }
   ILL_CONT_M1HOLE_AMW0 {@ AM ERROR BAD SLOT: met1 hole over cont   
                    M1HOLE AND CONT
   }
   ILL_VIA_M1HOLE_AMW0 {@ AM ERROR BAD SLOT: met1 hole over via   
                   M1HOLE AND VIA
   }
   ILL_VIA_M2HOLE_AMW0 {@ AM ERROR BAD SLOT: met2 hole over via   
                   M2HOLE AND VIA
   }
   ILL_VIA2_M2HOLE_AMW0 {@ AM ERROR BAD SLOT: met2 hole over via2
                    M2HOLE AND VIA2
   }
   ILL_VIA2_M3HOLE_AMW0 {@ AM ERROR BAD SLOT: met3 hole over via2   
                    M3HOLE AND VIA2
   }
#IFDEF fourmetal
   ILL_OUT_M4HOLE_AMW0 {@ AM ERROR BAD SLOT: met4 hole outside met4
                   M4HOLE NOT MET4
   }
   ILL_VIA3_M4HOLE_AMW0 {@ AM ERROR BAD SLOT: met4 hole over via3   
                    M4HOLE AND VIA3
   }
#ENDIF
//
//---------------------------------------------------------------------
//                    Top metal dummy structures
//---------------------------------------------------------------------
//
// The following dummy structures must be added in the top metal layer
// as an assembly stress buffer
//
#IFDEF fourmetal
//------------------------------------------------------------------
//>>>>>>>>>>>>
//  get small met4 < 10
   met4_gt_10 = SIZE MET4 BY 5 UNDEROVER
// >>>>>>>>>>>
// small metal, but not already placed filling rects
   met4_lt_10 = (MET4 NOT met4_gt_10 ) NOT met4_block
// >>>>>>>>>>>
   //met4_lt_10 { COPY met4_lt_10 }
   //met4_gt_10 { COPY met4_gt_10 }
// are there any gaps > 10 between
   met4_lt_10_ovs = (SIZE met4_lt_10 BY 5.0 ) NOT met4_gt_10
   //met4_lt_10_ovs { COPY met4_lt_10_ovs }
//
// these areas should be filled
// grow from these areas
//
// grow areas which should be filled by 100 U, cut narrow parts by underover and do not 
// grow outside data ( for cell check )
//
//>>>>>>>>>>>
// remove already placed rects 2x5 and do not allow to grow over this blocking area
// this is also a "nofill" area
// only ok with fixed rects size 2x5 U
   met4_block_closed = (met4_block SIZE BY 3.0) OR NOFILL 
   met4_gt_10_block = met4_gt_10 OR met4_block_closed
   //met4_gt_10_block { COPY met4_gt_10_block }
   met4_f1  = met4_lt_10_ovs NOT met4_block_closed
   //met4_f1 { COPY met4_f1 }
//
   met4_f2  = ((SIZE met4_f1 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)
                SIZE BY 5.0 UNDEROVER
   met4_f3  = ((SIZE met4_f2 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f4  = ((SIZE met4_f3 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f5  = ((SIZE met4_f4 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f6  = ((SIZE met4_f5 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f7  = ((SIZE met4_f6 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f8  = ((SIZE met4_f7 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f9  = ((SIZE met4_f8 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met4_f10 = ((SIZE met4_f9 BY 10 OUTSIDE OF met4_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
//
   met4_blockfillarea = met4_f10 NOT met4_lt_10_ovs
// dummy structures must be added on top metal layer as stress buffer 
// outside of nofill layer
// 10 Maximum MTOP spacing when the width of one or both MTOP shapes is less than 10um = 10
   ILL_MISS_MET4BLOCK_AMTS1 { @ AMTS1 Maximum MTOP spacing when the width of one or both MTOP shapes is less than 10um = 10  
         FLATTEN met4_blockfillarea 
   }
////////////////////////////////////////////////////
//
// checked : AMTW1 : Fixed width of dummy MTOP block = 2
// checked : AMTL1 : Fixed length of dummy MTOP block = 5
// checked : AMTS2 : Minimum MTOP feature to dummy MTOP block spacing = 2
// checked : AMTS3 : Maximum MTOP feature to dummy MTOP block spacing = 6
// checked : AMTS4 : Fixed dummy MTOP block spacing = 2
// not checked : AMTR1 : Minimum number of dummy MTOP blocks in a region = 3
//
// guidelines for blocks 
//-------------------------
// small isolated top metal
   met4_floatrect = RECTANGLE (MET4 NOT ENCLOSE VIA3) < 15.0
// correct size
   met4_block =  RECTANGLE met4_floatrect == 2.0 BY == 5.0
// for 4 metal bicmos use 2.5 * 5 
   //met4_block { COPY met4_block }
   met4_block_bad = met4_floatrect NOT met4_block
   ILL_MET4BLOCK_AMTW1_REC { @ AMTW1/AMTL1 fixed with of met4 blocks
      COPY met4_block_bad
   }
   met4_not_met4block = MET4 NOT met4_block
   SPAC_MET4BLOCK_MET4_AMTS2_REC {@ AMTS2 minimum met4 to met4 block spacing
      EXT met4_block met4_not_met4block < 2.0 SINGULAR REGION
   }
// check from 6 to 10 U, no error, if larger
// more effort to avoid false errors over narrow metal
   SPAC_MET4BLOCK_MET4_AMTS3_REC {@ AMTS3 maximum met4 to met4 block spacing
      x = met4_block SIZE BY 6.0 OUTSIDE OF MET4 STEP 0.5
      y = (EXT x met4_not_met4block < 4.0 OPPOSITE PARA ONLY PROJ REGION) NOT CUT MET4
      z = (EXT y met4_block < 6.5 OPPOSITE PARA ONLY PROJ REGION) NOT CUT MET4
      u = (y OR z) NOT MET4
      u TOUCH met4_block
   }
//
// check for 4 U instead of 5 U to avoid errors from thick metal spac 4 U
//
   met4_block_spac_exact  = EXT met4_block == 2.0 OPPOSITE PARA ONLY REGION
   met4_block_spac_large  = EXT met4_block < 4.0 OPPOSITE PARA ONLY REGION
   // met4_block_spac { COPY met4_block_spac }
   SPAC_MET4BLOCK_AMTS4_REC {@ AMTS4 fixed met4 block spacing
      EXT met4_block < 2.0 SINGULAR REGION
      met4_block_spac_large NOT met4_block_spac_exact
   }
//
#ELSE
//------------------------------------------------------------------
// ATTENTION : this filling check has been modified due to
//             false errors if filling rects are already placed
//             Recognices only filling rects 2x5
//             Fails with other size
//  The old algorithm has flagged unfilled areas outside of already filled
//  areas, which is no error
//  This algorithm does not allow to grow over 2x5 blocking rects
//
//  get small met3 < 10
   met3_gt_10 = SIZE MET3 BY 5 UNDEROVER
// >>>>>>>>>>>
// small metal, but not already placed filling rects
   met3_lt_10 = (MET3 NOT met3_gt_10 ) NOT met3_block
// >>>>>>>>>>>
   //met3_lt_10 { COPY met3_lt_10 }
   //met3_gt_10 { COPY met3_gt_10 }
// are there any gaps > 10 between
   met3_lt_10_ovs = (SIZE met3_lt_10 BY 5.0 ) NOT met3_gt_10
   //met3_lt_10_ovs { COPY met3_lt_10_ovs }
//
// these areas should be filled
// grow from these areas
//
// grow areas which should be filled by 100 U, cut narrow parts by underover and do not 
// grow outside data ( for cell check )
//
//>>>>>>>>>>>
// remove already placed rects 2x5 and do not allow to grow over this blocking area
// this is also a "nofill" area
// only ok with fixed rects size 2x5 U
   met3_block_closed = (met3_block SIZE BY 3.0) OR NOFILL 
   met3_gt_10_block = met3_gt_10 OR met3_block_closed
   //met3_gt_10_block { COPY met3_gt_10_block }
   met3_f1  = met3_lt_10_ovs NOT met3_block_closed
   //met3_f1 { COPY met3_f1 }
//
   met3_f2  = ((SIZE met3_f1 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)
                SIZE BY 5.0 UNDEROVER
   met3_f3  = ((SIZE met3_f2 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f4  = ((SIZE met3_f3 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f5  = ((SIZE met3_f4 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f6  = ((SIZE met3_f5 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f7  = ((SIZE met3_f6 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f8  = ((SIZE met3_f7 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f9  = ((SIZE met3_f8 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
   met3_f10 = ((SIZE met3_f9 BY 10 OUTSIDE OF met3_gt_10_block  STEP 1.0) AND substrate_all)                       
                SIZE BY 5.0 UNDEROVER
//
   met3_blockfillarea = met3_f10 NOT met3_lt_10_ovs
// 10.0
// dummy structures must be added on top metal layer as stress buffer 
// outside of nofill layer
   ILL_MISS_MET3BLOCK_AMTS1 { @ AMTS1 Maximum MTOP spacing = 10.0 
         FLATTEN met3_blockfillarea 
   }
////////////////////////////////////////////////////
//
// guidelines for blocks 
//-------------------------
// small isolated top metal
   met3_floatrect = RECTANGLE (MET3 NOT ENCLOSE VIA2) < 15.0
// correct size
   met3_block =  RECTANGLE met3_floatrect == 2.0 BY == 5.0
   //met3_block { COPY met3_block }
   met3_block_bad = met3_floatrect NOT met3_block
   ILL_MET3BLOCK_AMTW1_REC { @ AMTW1/AMTL1 fixed with of met3 blocks
      COPY met3_block_bad
   }
   met3_not_met3block = MET3 NOT met3_block
   SPAC_MET3BLOCK_MET3_AMTS2_REC {@ AMTS2 minimum met3 to met3 block spacing
      EXT met3_block met3_not_met3block < 2.0 SINGULAR REGION
   }
// check from 6 to 10 U, no error, if larger
   SPAC_MET3BLOCK_MET3_AMTS3_REC {@ AMTS3 maximum met3 to met3 block spacing
      x = met3_block SIZE BY 6.0 OUTSIDE OF MET3 STEP 0.5
      y = (EXT x met3_not_met3block < 4.0 OPPOSITE PARA ONLY PROJ REGION) NOT CUT MET3
      z = (EXT y met3_block < 6.5 OPPOSITE PARA ONLY PROJ REGION) NOT CUT MET3
      u = (y OR z) NOT MET3
      u TOUCH met3_block
   }
//
   met3_block_spac_exact  = EXT met3_block == 2.0 OPPOSITE PARA ONLY REGION
   met3_block_spac_large  = EXT met3_block < 5.0 OPPOSITE PARA ONLY REGION
   // met3_block_spac { COPY met3_block_spac }
   SPAC_MET3BLOCK_AMTS4_REC {@ AMTS4 fixed met3 block spacing
      EXT met3_block < 2.0 SINGULAR REGION
      met3_block_spac_large NOT met3_block_spac_exact
   }
#ENDIF
//
//-----------------------------------------------------------------
//           Guideline : poly1/poly2 must have sufficient conts
//-----------------------------------------------------------------
// cannot use density check, because density uses bounding box of polygons
//
// Maximum ratio of POLY1 area to connected CONT area = 18000
//
      poly1_polygon = POLY1 enclose poly1con
      poly1_poly1con = poly1con INSIDE poly1_polygon
      poly1_polygon_net = COPY poly1_polygon
      CONNECT poly1_polygon_net 
   ILL_RATIO_CONT_POLY1_RECG01P1 { @ G01P1 Maximum ratio of POLY1 area to connected CONT area = 18000
      //poly1_polygon_net = POLYNET poly1_polygon
      poly1_poly1con_net = STAMP poly1_poly1con BY poly1_polygon_net
      NET AREA RATIO poly1_polygon_net poly1_poly1con_net > 18000 
      xx = NET AREA RATIO poly1_polygon_net poly1_poly1con_net > 18000 ACCUMULATE
      NET AREA RATIO PRINT xx 'ratio_poly1_cont.txt'
   }
//
// Maximum ratio of POLY2 area to connected CONT area = 22000
      poly2_polygon = POLY2 enclose poly2con
      poly2_polygon_net = COPY poly2_polygon
      CONNECT poly2_polygon_net 
   ILL_RATIO_CONT_POLY2_RECG01P2 { @ G01P2 Maximum ratio of POLY2 area to connected CONT area = 22000
      poly2_poly2con = poly2con INSIDE poly2_polygon
      //poly2_polygon_net = POLYNET poly2_polygon
      poly2_poly2con_net = STAMP poly2_poly2con BY poly2_polygon_net
      NET AREA RATIO poly2_polygon_net poly2_poly2con_net > 22000 
      xx = NET AREA RATIO poly2_polygon_net poly2_poly2con_net > 22000 ACCUMULATE
      NET AREA RATIO PRINT xx 'ratio_poly2_cont.txt'
   }
//
//-----------------------------------------------------------------
//               additional pad checks
//-----------------------------------------------------------------
//
// check if pad metx is connected by vias
//-----------------------------------------
//
   via_pad  = padvia INSIDE m1pad
   via2_pad = padvia2 INSIDE m2pad
#IFDEF fourmetal
   via3_pad = padvia3 INSIDE m3pad
#ENDIF
   CONNECT m3pad  m2pad  BY via2_pad MASK
   CONNECT m2pad  m1pad  BY via_pad  MASK
#IFDEF fourmetal
   CONNECT m4pad  m3pad  BY via3_pad MASK
//
   ILL_MET4_MET3_BONDPAD_CBR1 {@ CBR1 PAD met4 not connected to met3
                      EXT m4pad m3pad < 1.0 OVERLAP INSIDE ALSO
                      NOT CONNECTED SINGULAR REGION
   }
//
#ENDIF
   ILL_MET3_MET2_BONDPAD_CBR1 {@ CBR1 PAD met3 not connected to met2
                      EXT m3pad m2pad < 1.0 OVERLAP INSIDE ALSO
                      NOT CONNECTED SINGULAR REGION
   }
   ILL_MET2_MET1_BONDPAD_CBR1 {@ CBR1 PAD met2 not connected to met1
                      EXT m2pad m1pad < 1.0 OVERLAP INSIDE ALSO
                      NOT CONNECTED SINGULAR REGION
   }
//
//---------------------------------------------------------------------
//                            Other checks               
//---------------------------------------------------------------------
//
#IFDEF tsmc_orig_drc
//
// check for max metal pad enclosure :
//-------------------------------------
// pad metal is wide metal, which is already generated 
//
// count edges of oversized pad cutting into metal
// one connection is ok ( pad connect )
//
// get pad wide metal, close smaller connections like fingers to pad
   met1_wide_pad = SIZE (met1_wide_1 ENCLOSE PAD) BY 1.6 OVERUNDER
   met2_wide_pad = SIZE (met2_wide_1 ENCLOSE PAD) BY 1.6 OVERUNDER
   met3_wide_pad = SIZE (met3_wide_1 ENCLOSE PAD) BY 1.6 OVERUNDER
#IFDEF fourmetal
   met4_wide_pad = SIZE (met4_wide_1 ENCLOSE PAD) BY 1.6 OVERUNDER
#ENDIF
//
// allow bus connections up to 15 U without error
// change shrinking from 5 to 7.5 U
//
   met1_p = met1_wide_pad NOT m1padpolyg 
   met1_pad_edge  =  m1padpolyg COINCIDENT OUTSIDE EDGE met1_p
   met1_pad_edge1 =  EXPAND EDGE met1_pad_edge INSIDE BY 0.5 EXTEND BY -7.5
   // met1_pad_edge1 { COPY met1_pad_edge1 }
   met1_pad_o     =  pad_allovs INTERACT met1_pad_edge1 > 1
   OVLP_MET1_PAD_MAX_CBE1 {@ CB_E_1 Minimum MET1 enclosure of PAD = 5 max
            met1_pad_edge1 INTERACT met1_pad_o
   }
//
   met2_p = met2_wide_pad NOT m2padpolyg 
   met2_pad_edge  =  m2padpolyg COINCIDENT OUTSIDE EDGE met2_p
   met2_pad_edge1 =  EXPAND EDGE met2_pad_edge INSIDE BY 0.5 EXTEND BY -7.5
   met2_pad_o     =  pad_allovs INTERACT met2_pad_edge1 > 1
   OVLP_MET2_PAD_MAX_CBE2 {@ CB_E_2 Minimum MET2 enclosure of PAD = 5 max
            met2_pad_edge1 INTERACT met2_pad_o
   }
//
   met3_p = met3_wide_pad NOT m3padpolyg 
   met3_pad_edge  =  m3padpolyg COINCIDENT OUTSIDE EDGE met3_p
   met3_pad_edge1 =  EXPAND EDGE met3_pad_edge INSIDE BY 0.5 EXTEND BY -7.5
   met3_pad_o     =  pad_allovs INTERACT met3_pad_edge1 > 1
   OVLP_MET3_PAD_MAX_CBE3 {@ CB_E_3 Minimum MET3 enclosure of PAD = 5 max
            met3_pad_edge1 INTERACT met3_pad_o
   }
//
#IFDEF fourmetal
   met4_p = met4_wide_pad NOT m4padpolyg 
   met4_pad_edge  =  m4padpolyg COINCIDENT OUTSIDE EDGE met4_p
   met4_pad_edge1 =  EXPAND EDGE met4_pad_edge INSIDE BY 0.5 EXTEND BY -7.5
   met4_pad_o     =  pad_allovs INTERACT met4_pad_edge1 > 1
   OVLP_MET4_PAD_MAX_CBE4 {@ CB_E_4 Minimum MET4 enclosure of PAD = 5.0 max
            met4_pad_edge1 INTERACT met4_pad_o
   }
#ENDIF
#ENDIF // tsmc_orig_drc

//--------- Check for correct Resistor definition ---------

//
// Fixed RESTRM enclosure of RESDEF edge 
//
// we use tubdef for well resistors and resdef for all other resistors
//
   OVLP_RESTRM_RESDEF_REC {@ Recommendation : Fixed RESTRM enclosure of RESDEF edge 0.1 U
                       @ or missing RESTRM
                       ENC RESDEF RESTRM < 0.1 ABUT==0 REGION
                       ENC TUBDEF RESTRM < 0.1 ABUT==0 REGION
                       RESDEF CUT RESTRM < 2
                       TUBDEF CUT RESTRM < 2
                       x = RESDEF OR TUBDEF
                       (x NOT INTERACT RESTRM) NOT HRES
                       // do not check in spirals
                       (RESTRM NOT INTERACT x) NOT INTERACT INDDEF
   }
//

//--------- Check for Layer Structures without contact or via ---------

// Diffusion without contact
   ILL_DIFF_NOT_CONT_ERC {@ ERC Warning: DIFF without any contact
                  diff_cut NOT ENCLOSE CONT
   }
// Floating Poly1
// drop fill rectangles
   ILL_POLY1_NOT_CONT_ERC {@ ERC Warning: Floating POLY1
               xx =  RECTANGLE poly1_cut == 2.0 BY == 5.0
               (poly1_cut NOT ENCLOSE poly1con) NOT xx
   }
// Floating Poly2
   ILL_POLY2_NOT_CONT_ERC {@ ERC Warning: Floating POLY2
                  poly2_cut NOT ENCLOSE CONT
   }
// Floating Metal1
// mask out m1 with m1pinshape for reduced cells 
// drop fill rectangles
   ILL_MET1_NOT_VIA_CONT_ERC {@ ERC Warning: Floating MET1
                 xx =  RECTANGLE met1_withslots == 2.0 BY == 5.0
                 yy = (met1_withslots NOT ENCLOSE via_cont) NOT INTERACT M1PINSHAPE
                 yy NOT xx
   }
// Floating Metal2
// drop fill rectangles
   ILL_MET2_NOT_VIA2_VIA_ERC {@ ERC Warning: Floating MET2
                 xx =  RECTANGLE met2_withslots == 2.0 BY == 5.0
                 (met2_withslots NOT ENCLOSE via2_via) NOT xx
 }
//
// drop stress top metal blocks :
// this is not quite correct, because for top met4 blocks
// for met3 are also removed
// Floating Metal3
   ILL_MET3_NOT_VIA2_ERC {@ ERC Warning: Floating MET3
                 xx =  RECTANGLE met3_withslots == 2.0 BY == 5.0
                 (met3_withslots NOT ENCLOSE via3_via2) NOT xx
 }
#IFDEF fourmetal
// Floating Metal4
// use 2.5x5 for 4 metal bicmos
   ILL_MET4_NOT_VIA3_ERC {@ ERC Warning: Floating MET4
                 xx =  RECTANGLE met4_withslots == 2.0 BY == 5.0
                 (met4_withslots NOT ENCLOSE VIA3) NOT xx
 }
#ENDIF

//
// --------  check for unused min layout structures on pad stack --------
//
// these checks are not in doc, but valid for quality improvement
//
// check for 4 3 and 2 metal
// check for min overlap too complicated, use 1*1U
//
   met2_less_1 = MET2 AREA < 1.0
   met3_less_1 = MET3 AREA < 1.0
//
#IFDEF fourmetal
   met4_less_1 = MET4 AREA < 1.0
// top met4
   INFO_TOPMINMET4_ON_VIA3 {@ INFO:    Min Top MET4 on VIA3 stack is used     
      met4_less_1 ENCLOSE VIA3
   }
// stack ends with met2
   INFO_TOPMINMET2_ON_VIA {@ INFO:     Min Top MET2 on VIA stack is used     
      ((met2_less_1 ENCLOSE VIA) NOT ENCLOSE VIA2) NOT ENCLOSE VIA3
   }
// stack ends with met3
   INFO_TOPMINMET3_ON_VIA2 {@ INFO:     Min Top MET3 on VIA2 stack is used     
      (met3_less_1 ENCLOSE VIA2) NOT ENCLOSE VIA3
   }
// stack ends with small met4 AND small met3
   INFO_TOPMINMET34_ON_VIA23 {@ INFO:     Min Top MET4 and min MET3 on VIA3/VIA2 stack is used
      ((met3_less_1 AND met4_less_1) ENCLOSE VIA2) ENCLOSE VIA3
   }
// stack ends with small met3 AND small met2
   INFO_TOPMINMET32_ON_VIA_VIA2 {@  INFO:     Min Top MET3 and min MET2 on VIA/VIA2 stack is used
      (((met3_less_1 AND met2_less_1) ENCLOSE VIA) ENCLOSE VIA2) NOT ENCLOSE VIA3
   }
#ELSE
// stack ends with met3
   INFO_TOPMINMET3_ON_VIA2 {@  INFO:     Min Top MET3 on VIA2 stack is used     
      met3_less_1 ENCLOSE VIA2
   }
// stack ends with met2
   INFO_TOPMINMET2_ON_VIA {@  INFO:     Min Top MET2 on VIA stack is used     
      (met2_less_1 ENCLOSE VIA) NOT ENCLOSE VIA2
   }
// stack ends with small met3 AND small met2
   INFO_TOPMINMET32_ON_VIA_VIA2 {@  INFO:     Min Top MET3 and min MET2 on VIA/VIA2 stack is used
      ((met3_less_1 AND met2_less_1) ENCLOSE VIA) ENCLOSE VIA2
   }
#ENDIF

//---------------------------------------------------------------------
//                      Subdef Layer Checks              
//---------------------------------------------------------------------
//
// SUBDEF cuts substrate to support different vss nodes
// eg subdef layer is drawn to divide analogue and digital
// areas to check for vss/vssa
// to make sure that the layer is drawn ok possibe
// errors are found by DRC 
//
   INFO_SUBDEF { @ INFO: subdef layer found, only info
                 COPY SUBDEF
               }
// all these checks search for illegal subdef layer
// drawings
// 
// does not open substrate, opens ntub only
// normally not used for LVS
   INFO_SUBDEF_CUT_NTUB { @ ERC Warning: subdef layer cuts ntub
                          NTUB AND subdef_ring
                        }
// this is a bad device for LVS, 2 nodes on substrate
   ILL_SUBDEF_CUT_GATE { @ ERC Warning: subdef layer cuts gate area
                         subdef_ring AND ngate
                       }
// substrate diff shortens substrate areas
   ILL_SUBDEF_CUT_SUBTAP { @ ERC Warning: subdef layer cuts subtap area
                           subdef_ring AND subtap
                         }
//
// substrate on same potential : 
// substrate areas split by subdef layer are connected 
// otherwise (by metal) 
   SPAC_SUBDEFAREA_CONN {@ ERC Warning: spacing substrate same potential
                         @ substrate regions are shorted
                         EXT substrate < 0.1 
                         SINGULAR CONNECTED
                        }
//
// check if any substrate created by subdef has a net name VDD
   subdef_under = SIZE SUBDEF BY -0.05
   substrate_in_subdef = substrate AND subdef_under
//
   //substrate_gnd = NET substrate_in_subdef "?GND?" "?VSS?"
   //substrate_gnd { COPY substrate_gnd }
//
   substrate_vdd = NET substrate_in_subdef  "?VCC?" "?vcc?" "?VDD?" "?vdd?" "?VBAT?" "?vbat?"
   //substrate_vdd { COPY substrate_vdd }
   ILL_SUBDEFAREA_CONN_VDD { @ ERC Warning: subdef layer cuts substrate area with net name VDD/VCC/VBAT
                             @              is this correct ?
         COPY substrate_vdd
   }
// 
//---------------------------------------------------------------------
//                           ERC checks                       
//---------------------------------------------------------------------

// check for possible zener diodes
//---------------------------------
// a zener diode is a p/n diffusion abutting, connected to different nets
   ILL_POSSIBLE_Z_DIODE_ERC {@ ERC Warning: If ndiff and pdiff are butted they have to be
                         @ on the same net - connected by met1
                         @ p/ndiff abutment on different nets is a z-diode
                         EXT ndiff_n_zener pdiff_n_zener < 0.05 ABUT == 0
                         SINGULAR NOT CONNECTED
   }

// check for illegal high voltage nmos transistors
//--------------------------------------------------
// the poly-diff area of a hv-nmos transistor has to touch the ntub area
   ILL_HV_NMOS_ERC {@ ERC Warning: gate area and nwell area of the high voltage nmos
                    @ must overlap by 1.6 U exactly
                    ndev INTERACT ill_hvmos_nwell
   }

//  check for soft substrate and wells            
//---------------------------------------
// This check shows the diff involved in soft connection
// Since we have already used connection for well/substrate taps
// we do this check locally again by introduction (copy) of new
// layers. Thus we have to establish a new connectivity.
// This makes the soft checks totally independent of the rule file.
// This is a disadvantage due to runtime, but can be used
// for all processes ( for 3 met add met3/via2)
//
// We are not interested in all soft connected taps, only in
// s/d of transistors connected to this soft taps. 
// A stamping error shows all involved taps, this would show
// too much transistors. Therefor we identify all power nets(touching pad)
// and remove these transistors connected to power.
// This check shows the error gate and the met1 leading to the
// soft connected tap
//
// CALIBRE generates following stamping errors : 
//    - missing connections stamp : a polygon was found which did
//               not get a stamp
//    - conflicting connection stamp : polygon did not get a stamp
//               because different nodes are trying to stamp the
//               same object

    psub_soft = COPY psub
    routingnwell_soft = COPY routingnwell
    subtap_soft = COPY subtap
    welltap_soft = COPY welltap

//  psub_soft { COPY psub}
//  routingnwell_soft { COPY routingnwell}
//  subtap_soft { COPY subtap}
//  welltap_soft { COPY welltap}
//  ndiff { COPY ndiff}
//  pdiff { COPY pdiff}

    ndiff_c1 = COPY ndiff
    pdiff_c1 = COPY pdiff
    met1_c1  = COPY MET1  
    met2_c1  = COPY MET2  
    met3_c1  = COPY MET3  
#IFDEF fourmetal
    met4_c1  = COPY MET4  // c35b4 
#ENDIF
    cont_c1  = COPY CONT  
    via_c1   = COPY VIA  
    via2_c1  = COPY VIA2  
#IFDEF fourmetal
    via3_c1  = COPY VIA3  // c35b4 
#ENDIF
    pad_c    = COPY PAD
    CONNECT ndiff_c1 met1_c1 by cont_c1
    CONNECT pdiff_c1 met1_c1 by cont_c1
    CONNECT met2_c1 met1_c1 by via_c1
    CONNECT met3_c1 met2_c1 by via2_c1
#IFDEF fourmetal
    CONNECT met4_c1 met3_c1 by via3_c1   // c35b4
#ENDIF
    // CONNECT pad_c met2_c1
    CONNECT pad_c met3_c1

    stamped_subtap = STAMP subtap_soft BY pdiff_c1
    stamped_psub = STAMP psub_soft BY stamped_subtap
//  stamped_subtap { COPY stamped_subtap }
//  stamped_psub { COPY stamped_psub}
//  this shows all soft substrate taps
//  ILL_SOFT_CONN_PSUB {@ Soft connected substrate
//                x = psub_soft NOT stamped_psub
//                x AND stamped_subtap 
//  }
    stamped_welltap = STAMP welltap_soft BY ndiff_c1
    stamped_routingnwell = STAMP routingnwell_soft BY stamped_welltap
//  stamped_welltap { COPY stamped_welltap }
//  stamped_routingnwell { COPY stamped_routingnwell}
//  this shows all soft well taps 
//  ILL_SOFT_CONN_NTUB {@ Soft connected ntub
//                x = routingnwell_soft NOT stamped_routingnwell 
//                x AND stamped_welltap
//  }
//
// get power bus connected by met1/2
// must have pad or text on net
//
// attention : this must be placed in header near ATTACH and must be
//             edit 
   // text_vdd = (EXPAND TEXT ?VDD? 59 BY 0.1) OR (EXPAND TEXT ?VCC? 59 BY 0.1)
   // text_vss = (EXPAND TEXT ?VSS? 59 BY 0.1) OR (EXPAND TEXT ?GND? 59 BY 0.1)
//
   INFO_TEXT_VDD { COPY text_vdd }
   INFO_TEXT_VSS { COPY text_vss }
//
// select text for connectivity from top to bottom
// to avoid short if text is located on 2 not connected metal layers 
// ( if text on more layers crossing with different net..)
#IFDEF fourmetal
   text_vdd_m4 = text_vdd AND MET4
   text_vdd_all = COPY text_vdd_m4
#ELSE
//  empty layer
   text_vdd_all = SIZE text_vdd BY -1.0
#ENDIF
   text_vdd_m3 = (text_vdd AND MET3) NOT text_vdd_all
   text_vdd_all_1 = text_vdd_all OR text_vdd_m3
   text_vdd_m2 = (text_vdd AND MET2) NOT text_vdd_all_1
   text_vdd_all_2 = text_vdd_all_1 OR text_vdd_m3
   text_vdd_m1 = (text_vdd AND MET1) NOT text_vdd_all_2
   CONNECT met1_c1 text_vdd_m1
   CONNECT met2_c1 text_vdd_m2
   CONNECT met3_c1 text_vdd_m3
   met1_vdd_hard_x1  = NET AREA RATIO met1_c1 text_vdd_m1 > 0
   met1_vdd_hard_x2  = NET AREA RATIO met1_c1 text_vdd_m2 > 0
   met1_vdd_hard_x3  = NET AREA RATIO met1_c1 text_vdd_m3 > 0
   met1_vdd_hard_123 = met1_vdd_hard_x1 OR (met1_vdd_hard_x2 OR met1_vdd_hard_x3)
#IFDEF fourmetal
   CONNECT met4_c1 text_vdd_m4
   met1_vdd_hard_x4 = NET AREA RATIO met1_c1 text_vdd_m4 > 0
   met1_vdd_hard = met1_vdd_hard_123 OR met1_vdd_hard_x4
#ELSE
   met1_vdd_hard = COPY met1_vdd_hard_123
#ENDIF
#IFDEF fourmetal
   text_vss_m4 = text_vss AND MET4
   text_vss_all = COPY text_vss_m4
#ELSE
   text_vss_all = SIZE text_vss BY -1.0
#ENDIF
   text_vss_m3 = (text_vss AND MET3) NOT text_vss_all
   text_vss_all_1 = text_vss_all OR text_vss_m3
   text_vss_m2 = (text_vss AND MET2) NOT text_vss_all_1
   text_vss_all_2 = text_vss_all_1 OR text_vss_m3
   text_vss_m1 = (text_vss AND MET1) NOT text_vss_all_2
   CONNECT met1_c1 text_vss_m1
   CONNECT met2_c1 text_vss_m2
   CONNECT met3_c1 text_vss_m3
   met1_vss_hard_x1  = NET AREA RATIO met1_c1 text_vss_m1 > 0
   met1_vss_hard_x2  = NET AREA RATIO met1_c1 text_vss_m2 > 0
   met1_vss_hard_x3  = NET AREA RATIO met1_c1 text_vss_m3 > 0
   met1_vss_hard_123 = met1_vss_hard_x1 OR (met1_vss_hard_x2 OR met1_vss_hard_x3)
#IFDEF fourmetal
   CONNECT met4_c1 text_vss_m4
   met1_vss_hard_x4 = NET AREA RATIO met1_c1 text_vss_m4 > 0
   met1_vss_hard = met1_vss_hard_123 OR met1_vss_hard_x4
#ELSE
   met1_vss_hard = COPY met1_vss_hard_123
#ENDIF
//
   met1_power_pad  = NET AREA RATIO met1_c1 pad_c > 0
   met1_power      = met1_power_pad OR (met1_vdd_hard OR met1_vss_hard) 
   met1_power_vdd  = met1_power_pad OR met1_vdd_hard 
   met1_power_vss  = met1_power_pad OR met1_vss_hard 
//
//   met1_power_vdd { COPY met1_power_vdd }
//   met1_power_vss { COPY met1_power_vss }
//
// attention : pmos and pmosm !!
//
    x1 = routingnwell_soft NOT stamped_routingnwell 
    soft_welltap = x1 AND stamped_welltap
    soft_welltap_cont = soft_welltap AND CONT
    sd_pmos_pdiff = pdiff INTERACT pmos_3
    sd_pmos_pdiff_cont = CONT AND sd_pmos_pdiff
    // trace from soft tap to s/d of transistor via met1
    soft_welltap_met1 = MET1 enclose soft_welltap_cont
    ILL_SOFT_CONN_MET1_NWELL_ERC {@ ERC Warning: Soft connection of met1 in nwell 
            soft_welltap_met1 NOT met1_power_vdd 
            //  COPY soft_welltap_met1 
  }

    ILL_SOFT_CONN_PTRANS_ERC {@ ERC Warning: Soft connection of sd of ptrans 
                // all nets connected to pad
                sd_pmos_cont_soft = sd_pmos_pdiff_cont AND soft_welltap_met1 
                sd_pmos_pdiff_soft = sd_pmos_pdiff INTERACT sd_pmos_cont_soft
                pmos_soft_all = pmos_3 INTERACT sd_pmos_pdiff_soft

                soft_welltap_met1x = met1_power_vdd enclose soft_welltap_cont
                sd_pmos_cont_softx = sd_pmos_pdiff_cont AND soft_welltap_met1x 
                sd_pmos_pdiff_softx = sd_pmos_pdiff INTERACT sd_pmos_cont_softx
                pmos_soft_power = pmos_3 INTERACT sd_pmos_pdiff_softx

                // COPY pmos_soft_power
                // remaining soft conn trans not conn to pad 
                pmos_soft_all_x = pmos_soft_all NOT pmos_soft_power
                // get metal1 conected to this s/d
                sd_pmos_pdiff_soft_x = sd_pmos_pdiff_soft INTERACT pmos_soft_all_x
                sd_pmos_pdiff_cont_x = sd_pmos_pdiff_cont AND sd_pmos_pdiff_soft_x
                met1_soft = MET1 ENCLOSE sd_pmos_pdiff_cont_x
                pmos_soft_all_x OR met1_soft
    }
//
// attention : nmos and nmosm !!
//
    x2 = psub_soft NOT stamped_psub
    soft_subtap = x2 AND stamped_subtap
    soft_subtap_cont = soft_subtap AND CONT
    sd_nmos_ndiff = ndiff INTERACT nmos_4
    sd_nmos_ndiff_cont = CONT AND sd_nmos_ndiff
    soft_subtap_met1 = MET1 enclose soft_subtap_cont
    ILL_SOFT_CONN_MET1_PSUB_ERC {@ ERC Warning: Soft connection of met1 in psub 
             soft_subtap_met1 NOT met1_power_vss  
             //  COPY soft_subtap_met1 
     }

    ILL_SOFT_CONN_NTRANS_ERC {@ ERC Warning: Soft connection of sd of ntrans 
                sd_nmos_cont_soft = sd_nmos_ndiff_cont AND soft_subtap_met1 
                sd_nmos_ndiff_soft = sd_nmos_ndiff INTERACT sd_nmos_cont_soft
                nmos_soft_all = nmos_4 INTERACT sd_nmos_ndiff_soft

                soft_subtap_met1x = met1_power_vss enclose soft_subtap_cont
                sd_nmos_cont_softx = sd_nmos_ndiff_cont AND soft_subtap_met1x 
                sd_nmos_ndiff_softx = sd_nmos_ndiff INTERACT sd_nmos_cont_softx
                nmos_soft_power = nmos_4 INTERACT sd_nmos_ndiff_softx

                nmos_soft_all_x = nmos_soft_all NOT nmos_soft_power
                // get metal1 conected to this s/d
                sd_nmos_ndiff_soft_x = sd_nmos_ndiff_soft INTERACT nmos_soft_all_x
                sd_nmos_ndiff_cont_x = sd_nmos_ndiff_cont AND sd_nmos_ndiff_soft_x
                met1_soft = MET1 ENCLOSE sd_nmos_ndiff_cont_x
                nmos_soft_all_x OR met1_soft

    }
//
// check for metal1 soft connected to welltap/subtap
//---------------------------------------------------
// This check flags met1 soft connected to welltap/
// subtap . Only nets leading to any pad are flagged.
// This check is usefull to identify soft conn guard
// bars.
// create new connectivity for metal
// pdiff in nwell is connected 
    pdiff_cx = COPY pdiff
    pdiff_c2 = pdiff_cx AND routingnwell
    met1_c2  = COPY met1_c1
    met2_c2  = COPY met2_c1
    met3_c2  = COPY met3_c1
#IFDEF fourmetal
    met4_c2  = COPY met4_c1   // c35b4
#ENDIF
    cont_c2  = COPY cont_c1
    via_c2   = COPY via_c1
    via2_c2  = COPY via2_c1
#IFDEF fourmetal
    via3_c2  = COPY via3_c1  // c35b4
#ENDIF
    pad_c2   = COPY pad_c
    CONNECT met1_c2 cont_c2
    CONNECT pdiff_c2 met1_c2 by cont_c2
    CONNECT met2_c2 met1_c2 by via_c2
    CONNECT met3_c2 met2_c2 by via2_c2
#IFDEF fourmetal
    CONNECT met4_c2 met3_c2 by via3_c2   // c35b4
#ENDIF
    // CONNECT pad_c2 met2_c2
    CONNECT pad_c2 met3_c2
// COPY taps
    welltap_c2 = COPY welltap
    subtap_c2 = COPY subtap
    stamped_ndf = STAMP welltap_c2 BY cont_c2
    stamped_pdf = STAMP subtap_c2 BY cont_c2
//
// met1 conneceted via met to pad 
// met1 connected via met to pad or vdd/vss text 
//
// connect text to layers
//
   text_vdd_m1_2 = COPY text_vdd_m1
   text_vdd_m2_2 = COPY text_vdd_m2
   text_vdd_m3_2 = COPY text_vdd_m3
   text_vss_m1_2 = COPY text_vss_m1
   text_vss_m2_2 = COPY text_vss_m2
   text_vss_m3_2 = COPY text_vss_m3
   CONNECT met1_c2 text_vdd_m1_2
   CONNECT met1_c2 text_vss_m1_2
   CONNECT met2_c2 text_vdd_m2_2
   CONNECT met2_c2 text_vss_m2_2
   CONNECT met3_c2 text_vdd_m3_2
   CONNECT met3_c2 text_vss_m3_2
   met1_vdd_hard_x1_2  = NET AREA RATIO met1_c2 text_vdd_m1_2 > 0
   met1_vdd_hard_x2_2  = NET AREA RATIO met1_c2 text_vdd_m2_2 > 0
   met1_vdd_hard_x3_2  = NET AREA RATIO met1_c2 text_vdd_m3_2 > 0
   met1_vdd_hard_123_2 = met1_vdd_hard_x1_2 OR (met1_vdd_hard_x2_2 OR met1_vdd_hard_x3_2)
#IFDEF fourmetal
   CONNECT met4_c2 text_vdd_m4_2  // c35b4
   CONNECT met4_c2 text_vss_m4_2  // c35b4
#ENDIF
#IFDEF fourmetal
   text_vdd_m4_2 = COPY text_vdd_m4
   CONNECT met4_c2 text_vdd_m4_2
   met1_vdd_hard_x4_2 = NET AREA RATIO met1_c2 text_vdd_m4_2 > 0
   met1_vdd_hard_2    = met1_vdd_hard_123_2 OR met1_vdd_hard_x4_2
#ELSE
   met1_vdd_hard_2 = COPY met1_vdd_hard_123_2
#ENDIF
   met1_vss_hard_x1_2  = NET AREA RATIO met1_c2 text_vss_m1_2 > 0
   met1_vss_hard_x2_2  = NET AREA RATIO met1_c2 text_vss_m2_2 > 0
   met1_vss_hard_x3_2  = NET AREA RATIO met1_c2 text_vss_m3_2 > 0
   met1_vss_hard_123_2 = met1_vss_hard_x1_2 OR (met1_vss_hard_x2_2 OR met1_vss_hard_x3_2)
#IFDEF fourmetal
   text_vss_m4_2 = COPY text_vss_m4
   CONNECT met4_c2 text_vss_m4_2
   met1_vss_hard_x4_2 = NET AREA RATIO met1_c2 text_vss_m4_2 > 0
   met1_vss_hard_2    = met1_vss_hard_123_2 OR met1_vss_hard_x4_2
#ELSE
   met1_vss_hard_2 = COPY met1_vss_hard_123_2
#ENDIF
//
   met1_power_pad_2  = NET AREA RATIO met1_c2 pad_c2 > 0
   met1_power_c2     = met1_power_pad_2 OR (met1_vdd_hard_2 OR met1_vss_hard_2) 
//  these taps are bad stamped
    ndc2 = welltap_c2 NOT stamped_ndf
    pdc2 = subtap_c2 NOT stamped_pdf
// get all tap conts 
    wellcont = welltap AND CONT
    subcont = subtap AND CONT
// bad tap conts
    ndc2cont = ndc2 AND wellcont
    pdc2cont = pdc2 AND subcont
// get hard connected met1 leading to pad and enclose tap conts
    met1_power_c2_ndhard = met1_power_c2 ENCLOSE wellcont 
    met1_power_c2_pdhard = met1_power_c2 ENCLOSE subcont 
    // met1_power_c2_ndhard { COPY met1_power_c2_ndhard }
    // met1_power_c2_pdhard { COPY met1_power_c2_pdhard }
// get all met1 enclosing tap conts also connected via diff
    met1_power_ptapall = met1_power ENCLOSE subcont 
    met1_power_ntapall = met1_power ENCLOSE wellcont 
    // met1_power_ntapall { COPY met1_power_ntapall}
    // met1_power_ptapall { COPY met1_power_ptapall}
    ILL_SOFT_CONN_MET1_WELLTAP_ERC {@ ERC Warning: Soft connection of met1 to welltap in nwell 
                met1_power_ntapall NOT met1_power_c2_ndhard
    }
    ILL_SOFT_CONN_MET1_SUBTAP_ERC {@ ERC Warning: Soft connection of met1 to subtap in psub 
                met1_power_ptapall NOT met1_power_c2_pdhard
    }
//
// check for floating nmos/pmos gates 
//------------------------------------
// Floating gates are gates which are connected to a net without 
// touching any s/d or resistor terminal, pad window or text property.
//
// cannot use any n/pdiff, must use nmos/pmos diff , because net may have
// any diode
// do not select nets with any text 
// do not select nets connected to pad (if text on pad missing)
    trans_no_name = NOT NET trans "?"
    ngate_sd = ndiff INTERACT ngate
    pgate_sd = pdiff INTERACT pgate
    CONNECT ngate_sd ndiff
    CONNECT pgate_sd pdiff
    // pad is connected to met3
    // CONNECT PAD routingmet2
    ILL_FLOATING_GATE_ERC {@ ERC Warning: floating gates not conn s/d or resistor 
                ntrans_conn_sd = NET AREA RATIO trans_no_name ngate_sd > 0
                ptrans_conn_sd = NET AREA RATIO trans_no_name pgate_sd > 0
                trans_conn_r = NET AREA RATIO trans_no_name RESTRM > 0
                trans_conn_rh = NET AREA RATIO trans_no_name preshterm > 0
                trans_conn_pad = NET AREA RATIO trans_no_name PAD > 0
                trans_good1 = ntrans_conn_sd OR ptrans_conn_sd
                trans_good2 = trans_conn_r  OR trans_conn_rh
                // these gates are good
                trans_good3 = trans_good1 OR trans_good2 
                trans_good = trans_good3 OR trans_conn_pad
                // remaining are floating
                float_trans = trans_no_name NOT trans_good
                COPY float_trans
//
// output net connected to fl gate
//
//#DEFINE FLOATING_GATE_NET  
#IFDEF FLOATING_GATE_NET
                STAMP float_trans BY trans
#IFDEF fourmetal
                L1 = NET AREA RATIO routingpoly routingmet1 routingmet2 routingmet3 routingmet4 float_trans   > 0
                L2 = NET AREA RATIO routingmet1 routingpoly routingmet2 routingmet3 routingmet4 float_trans   > 0
                L3 = NET AREA RATIO routingmet2 routingmet1 routingpoly routingmet3 routingmet4 float_trans   > 0
                L4 = NET AREA RATIO routingmet3 routingmet2 routingmet1 routingpoly routingmet4 float_trans   > 0
                L5 = NET AREA RATIO routingmet4 routingmet3 routingmet2 routingmet1 routingpoly float_trans   > 0
                L1 ORNET ( L2 ORNET ( L3 ORNET ( L4 ORNET L5)))
#ELSE
                L1 = NET AREA RATIO routingpoly routingmet1 routingmet2 routingmet3  float_trans   > 0
                L2 = NET AREA RATIO routingmet1 routingpoly routingmet2 routingmet3  float_trans   > 0
                L3 = NET AREA RATIO routingmet2 routingmet1 routingpoly routingmet3  float_trans   > 0
                L4 = NET AREA RATIO routingmet3 routingmet2 routingmet1 routingpoly  float_trans   > 0
                L5 = NET AREA RATIO routingmet3 routingmet2 routingmet1 routingpoly float_trans   > 0
                L1 ORNET ( L2 ORNET ( L3 ORNET L4 ))
#ENDIF
#ENDIF
    }
//
// check for gates connected to supply
//-------------------------------------
    ILL_GATES_CONN_VDD_ERC {@ ERC Warning: Gates connected VDD/VCC/VBAT, do not switch
                NET trans "?VDD?" "?VCC?" "?VBAT?"
    }
// remove "AGND"
    ILL_GATES_CONN_VSS_ERC {@ ERC Warning: Gates connected VSS/GND/VEE/VSUB, do not switch
                gnd_netall = NET trans "?VSS?" "?GND?" "?VEE?" "?VSUB?"
                agnd_net = NET trans "AGND"
                gnd_netall NOT agnd_net
    }
//
// check for nwell not connected to VDD/VCC or to same transistor s/d
//---------------------------------------------------------------------
// remove well res terms and snap and pad well
// get all nwell not named vdd
// if text is missing this check may cause a lot of errors
//
    floatwell5 = routingnwell NOT ( NET routingnwell "?VDD?" "?VCC?" "?VBAT?")
    // not near pad
    padovs100 = pad SIZE BY 100.0
    floatwell6 = floatwell5 NOT INTERACT padovs100
    // no snaps
    floatwell7 = floatwell6 NOT INSIDE DIFF 
    // no modnh
    floatwell8 = floatwell7 NOT INTERACT nmosh_d_term
    // no res
    floatwell9 = floatwell8 NOT INTERACT (RESDEF OR (TUBDEF OR HVDEF))
    // no DIODE
    floatwell10 = floatwell9 NOT INTERACT DIODE
    // no vert or vert10 or spiral
    floatwell11 = (floatwell10 NOT INTERACT pnpvert10) NOT INDDEF 
    //
    floatwell12 = floatwell11 NOT INTERACT cvar_ele
    // propagate node info
    floatwell = STAMP floatwell12 BY routingnwell
// get all pgate s/d conn to same nwell, remaining is bad ?
    pgate_sdx = EXT pgate_sd floatwell == 0 INSIDE ALSO CONNECTED REGION 
    ILL_NWELL_NOT_CONN_VDD_SD_ERC {@ ERC Warning: Nwell not connected VDD or pgate sd in same well
                floatwell NOT INTERACT pgate_sdx
    }
//
// check for maximum substrate contact distance 50 U in nwell
//------------------------------------------------------------
// size welltaps by 25 U . If spacing of all taps was < 50
// only 1 sized tap should stay in nwell
// 
   well_pgate = routingnwell INTERACT pgate
   welltap_final = SIZE welltap BY 25 INSIDE OF well_pgate STEP 2.5
//
// check, if more than 1 substrate island in well with distance > 50 
// do not show taps, only gaps
   SPAC_NTAP_IN_NWELL_GT50_ERC {@ ERC Warning: distance well taps > 50  U
     x=well_pgate INTERACT welltap_final > 1    
     x NOT welltap_final 
     // x AND welltap
   }
//
// next 2 checks are latchup prevention
//----------------------------------------
// remove s/d ndiff enclosing nwell in peri cells (bu8sp)
//
//#IFDEF csxswitch
//
// find all sd/diff inside area (see doc) , but flag only
// parts of s/d diff outside
//
// modification : 1.) remove "outside of nwell" for subtap 
//                    (substrate under nwell)
//                2.) 20 U is recommendation
//                3.) remove csxswitch
//
// check for distance ngate to subtap > 50
//----------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
    SPAC_SUBTAP_NDIFF50_LAT3_ERC {@ ERC Warning: LAT3 distance s/d diff ngate subtap > 50
        // subtap_ovs  = SIZE subtap BY 50.0 OUTSIDE OF routingnwell STEP 1.0
        subtap_ovs  = SIZE subtap BY 50.0 
        x = ((ndiff INTERACT ngate) NOT ENCLOSE routingnwell) NOT INSIDE subtap_ovs
        x NOT subtap_ovs 
    }
//
// check for distance pgate to welltap > 50
//------------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
   SPAC_WELLTAP_PDIFF50_LAT3_ERC {@ ERC Warning: LAT3 distance s/d diff pgate welltap > 50
         welltap_ovs = SIZE welltap BY 50 INSIDE OF well_pgate STEP 1.0
         x = (pdiff INTERACT pgate) NOT INSIDE  welltap_ovs
         x NOT welltap_ovs 
   }
//
//#ELSE
//
// check for distance ngate to subtap > 20
//----------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
    SPAC_SUBTAP_NDIFF_LAT3_REC {@ Recommendation : ERC Warning: LAT3 distance s/d diff ngate subtap > 20
        // subtap_ovs  = SIZE subtap BY 20.0 OUTSIDE OF routingnwell STEP 1.0
        subtap_ovs  = SIZE subtap BY 20.0 
        x = ((ndiff INTERACT ngate) NOT ENCLOSE routingnwell) NOT INSIDE subtap_ovs
        x NOT subtap_ovs 
    }
//
// check for distance pgate to welltap > 20
//------------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
   SPAC_WELLTAP_PDIFF_LAT3_REC {@ Recommendation : ERC Warning: LAT3 distance s/d diff pgate welltap > 20
         welltap_ovs = SIZE welltap BY 20 INSIDE OF well_pgate STEP 1.0
         x = (pdiff INTERACT pgate) NOT INSIDE  welltap_ovs
         x NOT welltap_ovs 
   }
//#ENDIF
//
// check if poly gate of LAT2 transistor is connected to supply
//------------------------------------------------------------------
// (also checked by interactive LVS, because lat2 is 5 terminal device
//  not checked by batch LVS )
//
   pgate_lat2x = routingpoly INTERACT pnplat2_g
   pgate_lat2 = STAMP pgate_lat2x BY routingpoly
//   
   pgate_lat_vddvcc  = NET pgate_lat2 "?VDD?" "?VCC?" "?VBAT?"
//
// pgate of latx transistor not connected to vdd
//
   ILL_PGATE_LAT2DEV_NOVDD_ERC {@ ERC Warning: pgate of lat2 transistor not connected to VDD/VCC/VBAT
                        pgate_lat2 NOT pgate_lat_vddvcc
   }
//
// check for illegal contacts covering resistors
//-------------------------------------------------
// DRC and LVS will not find an illegal contact placed on resistor body
// violating NO DRC rule, because poly, diffusion and well is removed
// from all further checks, if a RESDEF layer is drawn.
// This check should cover this situation
//
   ILL_CONT_RPOLY1_ERC {@ ERC Warning: illegal contact covering poly1 resistor
                 rescont_poly1 = pres1 AND CONT 
                 rescont_poly1 NOT INTERACT RESTRM
   }
   ILL_CONT_RPOLY2_ERC {@ ERC Warning: illegal contact covering poly2 resistor
                 rescont_poly2 = pres AND CONT 
                 rescont_poly2 NOT INTERACT RESTRM
   }
   ILL_CONT_RDIFFN_ERC {@ ERC Warning: illegal contact covering ndiff resistor
                 rescont_ndiff = ndres AND CONT 
                 rescont_ndiff NOT INTERACT RESTRM
   }
   ILL_CONT_RDIFFP_ERC {@ ERC Warning: illegal contact covering pdiff resistor
                 rescont_pdiff = pdres AND CONT 
                 rescont_pdiff NOT INTERACT RESTRM
   }
   ILL_CONT_RPOLYH_ERC {@ ERC Warning: illegal contact covering hrpoly resistor
                     presh AND CONT 
   }
   ILL_CONT_RNWELL_ERC {@ ERC Warning: illegal contact covering rnwell resistor
                 bad_resc_nwell1 = nwres AND CONT  
                 bad_resc_nwell1 AND DIFF
   }
//
// check for shapes cutting resdef outside and cutting layer
// touching resdef
//-----------------------------------------
//
// check for routingpoly1 shorting device and cut layer on resdef
   ILL_POLY1_RPOLY1_ERC {@ ERC Warning: illegal POLY1 touching poly1 resistor outside
                 x = pres1 COINCIDENT OUTSIDE EDGE routingpoly
                 (EXPAND EDGE x OUTSIDE BY 0.05) NOT INTERACT RESTRM
   }
// check for routingpoly2 shorting device and cut layer on resdef
   ILL_POLY2_RPOLY2_ERC {@ ERC Warning: illegal POLY2 touching poly2 resistor outside
                 x = pres COINCIDENT OUTSIDE EDGE routingpoly2
                 (EXPAND EDGE x OUTSIDE BY 0.05) NOT INTERACT RESTRM
   }
// check for cutting layer near resdef
   ILL_POLY2CUT_RPOLY2_ERC {@ ERC Warning: illegal POLY2CUT touching poly2 resistor body
                 PO2CUT INTERACT RESDEF
   }
// rpolyh
// no resdef
   ILL_POLY2_RPOLYH_ERC {@ ERC Warning: illegal poly2cut touching rpolyh resistor
                 PO2CUT INTERACT presh
   }
// rnwell lv
   ILL_NTUB_RNWELL_ERC {@ ERC Warning: illegal NTUB touching rnwell resistor outside
                 x = nwres COINCIDENT OUTSIDE EDGE routingnwell
                 (EXPAND EDGE x OUTSIDE BY 0.05) NOT INTERACT RESTRM
   }
// rdiffp in dntub and ntub
   ILL_PDIFF_RDIFFP_ERC {@ ERC Warning: illegal pdiff touching rdiffp resistor outside
                 x1 = pdres COINCIDENT OUTSIDE EDGE pdiff
                 (EXPAND EDGE x1 OUTSIDE BY 0.05) NOT INTERACT RESTRM
                 DIFCUT INTERACT pdres
   }
//
// check for connection of wells below caps and resistors         
//-----------------------------------------------------------
// well below pdiff res MUST be connected to VDD
// if no well...fatal error
// This is also checked by LVS
//
// check well below pdiff res :
// check for nwell connected to vdd
//
   routingnwell_vddsupply = NET routingnwell "?VDD?" "?VCC?" "?VBAT?"
//
// find ntub connected to VSS or GND or VEE or VSUB
//
   routingnwell_vsssupply  = (NET routingnwell "?VSS?" "?GND?" "?VEE?" "?VSUB?") NOT
                             (NET routingnwell "AGND")
//
   routingnwell_supply = routingnwell_vddsupply OR routingnwell_vsssupply
//
   ILL_NWELL_RDIFFP_NOVDD_ERC {@ ERC Warning: no nwell pdiff resistor or not connected to VDD/VCC/VBAT
         pdres NOT routingnwell_vddsupply
   }
//
// well below resistor and caps must be connected to supply
// if a well exists
//
   ILL_NWELL_RPOLY1_NOSUPPLY_ERC {@ ERC Warning: no nwell below poly1 res or not connected to VDD or VSS
                      pores1_nwells = pres1 AND routingnwell
                      pores1_nwells NOT routingnwell_supply
   }
   ILL_NWELL_RPOLY2_NOSUPPLY_ERC {@ ERC Warning: no nwell below poly2 res or not connected to VDD or VSS
                      pores2_nwells = pres AND routingnwell
                      pores2_nwells NOT routingnwell_supply
   }
   ILL_NWELL_CPOLY_NOSUPPLY_ERC  {@ ERC Warning: no nwell below cap or not connected to VDD or VSS
                      pocap_nwells = cpoly AND routingnwell
                      pocap_nwells NOT routingnwell_supply
   }
//
// Check for incomplete standard cells with incomplete shapes
// These shapes have a text on layer resdef 
//
   WARNING_REDUCED_CELL {@ WARNING : Reduced cell found
                         EXPAND TEXT "LAYOUT:REDUCED" RESDEF_TEXT BY 2
                        }
//
// rf pad with 8 vertices
//------------------------
//
   INFO_RF_PAD {@ INFO: RF PAD 8 vertices and rfdef layer 
          COPY rfpad_good
   }
//
// this pad has no rfdef layer, is obsolete
//
   INFO_ILLEGAL_RF_PAD {@ INFO: obsolate PAD, PAD with 8 vertices, but no rfdef layer
          COPY rfpad_bad
   }
//
   INFO_BOND_PAD {@ INFO: bond PAD
          COPY bondpad
   }
//
// check for pad pitch < 100 U
//------------------------------
//
// this check is just for info, no part of TSMC document
// do pitch check down to pads with 60 * 60 U
//
// do this check only for pad windows which are identified as possibe pad
// windows, no logos ...
// no scribe
//
   padrect = RECTANGLE PAD > 60 BY > 60
//
   bondpad_for_check = bondpad8 OR padrect
//
// create a square in cent with 1 U
//
   bondpad_cent = EXTENTS bondpad_for_check CENTERS 1.0
//
// cut out
//
   bondpad_cent_ovs = SIZE bondpad_cent BY 5.0
//
   INFO_ILL_PAD_PITCH_100 { @ Error: pad pitch less than 100 U
        CUT( (EXT bondpad_cent < 99.0 REGION) NOT bondpad_cent_ovs) bondpad_for_check == 2
   }
//-----------------------------------------------
//
//
///////////////////////////////////////////////////////////////////////
//                rules for interactive DRC in CBC mode              //
///////////////////////////////////////////////////////////////////////

//group continuous_drc 
//    SPAC_MET1_M1S1
//    SPAC_MET1_NOTCH_M1S1
//    SPAC_MET2_M2S1
//    SPAC_MET2_NOTCH_M2S1
//    SPAC_MET3_M3S1
//    SPAC_MET3_NOTCH_M3S1
//#IFDEF fourmetal
//    SPAC_MET4_M4S1
//    SPAC_MET4_NOTCH_M4S1
//#ENDIF

//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//                         LVTDEF checks
//
///////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////


#IFDEF layer_lvtdef

// Minimum LVTDEF width = 0.6 
// Minimum LVTDEF width = 0.6
   WIDTH_LVTDEF_W1LV {@ W1LV Minimum LVTDEF width = 0.6
       INT LVTDEF < 0.6 ABUT<90 SINGULAR REGION
   } 
//
// Minimum LVTDEF spacing = 0.6 
// Minimum LVTDEF spacing = 0.6
   SPAC_LVTDEF_S1LVLV {@ S1LVLV Minimum LVTDEF spacing = 0.6
       EXT LVTDEF < 0.6  ABUT>0<90 SPACE SINGULAR REGION
   }
// Minimum LVTDEF spacing = 0.6 
// Minimum LVTDEF spacing = 0.6
   SPAC_LVTDEF_NOTCH_S1LVLV {@ S1LVLV Minimum LVTDEF spacing = 0.6 notch 
       EXT LVTDEF < 0.6  ABUT>0<90 NOTCH SINGULAR REGION
   }
//
// add inside also option
// do not allow any lvtdef edge inside diff
// flag lvtdef touching diff but not enclosing also as error
// Minimum LVTDEF enclosure of DIFF = 0.25 
// Minimum LVTDEF enclosure of DIFF = 0.25
   OVLP_LVTDEF_DIFF_E1LVAA {@ E1LVAA Minimum LVTDEF enclosure of DIFF = 0.25
       ENC DIFF LVTDEF < 0.25 ABUT < 90 INSIDE ALSO SINGULAR REGION
       (LVTDEF INTERACT DIFF) NOT ENCLOSE DIFF
   }
//
// Minimum LVTDEF to DIFF spacing = 0.35
// Minimum LVTDEF to DIFF spacing = 0.35
   SPAC_LVTDEF_DIFF_S1AALV {@ S1AALV  Minimum LVTDEF to DIFF spacing = 0.35
       EXT LVTDEF DIFF < 0.35 ABUT == 0 OVERLAP SINGULAR REGION 
   }
//
// LVTDEF over ZENER is not allowed
   ILL_LVTDEF_ZENER_BAD1LV {@ LVR001 LVTDEF over ZENER is not allowed
       LVTDEF AND ZENER
   }
//
// LVTDEF outside GATE is not allowed
// LVTDEF outside GATE is not allowed
   ILL_LVTDEF_NOGATE_BAD2LV {@ LVR002 LVTDEF outside GATE is not allowed
       LVTDEF NOT ENCLOSE gate
   }
// LVTA outside SFCDEF will be removed and regenerated
   ILL_LVTA_OUT_SFCDEF_LVR003 {@ LVR003 LVTA outside SFCDEF will be removed and regenerated
       LVTA NOT SFCDEF       
   }
// LVPTUB outside SFCDEF will be removed and regenerated
   ILL_LVPTUB_OUT_SFCDEF_LFR001 {@ LFR001 LVPTUB outside SFCDEF will be removed and regenerated
       LVPTUB NOT SFCDEF       
   }
#ENDIF
// 
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                     METCAP checks
///////////////////////////////////////////////////////////////////////
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                30-May-2006       aob     metcap from s35  
///////////////////////////////////////////////////////////////////////
//

#IFDEF layer_metcap
//-----------------------------------------------------------------
//                       metcap  checks
//-----------------------------------------------------------------
//
   ILL_METC_OUTSIDE_MET2 { @ INFO : metcap not inside met2
             METCAP NOT INSIDE MET2
   }
//
// metcap_bottom_plate = MET2 ENCLOSE METCAP
//
// Minimum METCAP width = 4
   WIDTH_METC_W1MC {@ W1MC Minimum METCAP width = 4
          INT (METCAP ENCLOSE VIA2)  < 4 ABUT<89.9 SINGULAR REGION
   }
//
// assumption : dummy metcap does not have via2
// Minimum dummy METCAP width = 0.5
   WIDTH_METC_DUMMY_W2MC {@ W2MC Minimum dummy METCAP width = 0.5
          INT (METCAP NOT ENCLOSE VIA2) < 0.5 ABUT<89.9 SINGULAR REGION
   }
//
// do underover if 45 degree vertex
// Maximum METCAP width = 30
   WIDTH_METC_MAX_W3MC { @ W3MC Maximum METCAP width = 30
              LENGTH (METCAP SIZE BY 0.8 UNDEROVER) > 30
   }
// Maximum MET2 width (capacitor bottom plate ) = 35
   WIDTH_METC_BOTTMAX_W1M2 { @ W1M2 Maximum MET2 width (capacitor bottom plate ) = 35
              LENGTH metcap_bottom_plate > 35
   }
// Minimum METCAP spacing = 0.8
   SPAC_METC_S1MCMC {@ S1MCMC Minimum METCAP spacing = 0.8
              EXT METCAP < 0.8 SINGULAR REGION
   }
// Minimum MET2 spacing (capacitor bottom plate) = 0.8
   SPAC_METC_BOTT_S1M2M2 {@ S1M2M2 Minimum MET2 spacing (capacitor bottom plate) = 0.8
              EXT metcap_bottom_plate MET2 < 0.8 SINGULAR REGION
   }
// Minimum spacing between VIA1 and METCAP = 0.5
   SPAC_METC_VIA1_S1MCV1 {@ S1MCV1 Minimum spacing between VIA1 and METCAP = 0.5
              EXT VIA METCAP < 0.5 ABUT==0 OVERLAP SINGULAR REGION
   }
// Minimum spacing between VIA2 and METCAP = 0.5
   SPAC_METC_VIA2_S1MCV2 {@ S1MCV2 Minimum spacing between VIA2 and METCAP = 0.5
              EXT VIA2 METCAP < 0.5 ABUT==0 OVERLAP SINGULAR REGION
   }

// Minimum VIA2 spacing on MET2 bottom plate outside METCAP = 4
   SPAC_METC_VIA2_S1V2V2 {@ S1V2V2 Minimum VIA2 spacing on MET2 bottom plate outside METCAP = 4
              EXT ((VIA2 AND metcap_bottom_plate) NOT METCAP)  < 4 SINGULAR REGION
   }
// Minimum VIA2 spacing on METCAP = 3.5
   SPAC_METC_VIA2_S2V2V2 {@ S2V2V2 Minimum VIA2 spacing on METCAP = 3.5
              EXT (VIA2 AND METCAP) < 3.5 SINGULAR REGION
   }
//
// check removed doc Rev 5
// _S1M2MC_
//   SPAC_METC_MET2UNREL_S1M2MC {@ S1M2MC _S1M2MC_
//              EXT (MET2 NOT ENCLOSE METCAP) METCAP < _S1M2MC SINGULAR REGION
//   }
// Minimum MET2 enclosure of METCAP = 1
   OVLP_METC_BOTT_E1M2MC {@ E1M2MC Minimum MET2 enclosure of METCAP = 1
              ENC METCAP metcap_bottom_plate  < 1 ABUT==0
              OVERLAP SINGULAR REGION
   }
// next 2 checks only near cmim, 2 U is estimated
// Minimum MET2 enclosure of VIA1 (capacitor bottom plate) = 0.2
   cmim_ovs = SIZE cmim BY 2.0
   via_near_cmim  = VIA  INSIDE cmim_ovs
   via2_near_cmim = VIA2 INSIDE cmim_ovs
   OVLP_METC_VIA1BOTT_E1M2V1 {@ E1M2V1 Minimum MET2 enclosure of VIA1 (capacitor bottom plate) = 0.2
              ENC via_near_cmim metcap_bottom_plate < 0.2 ABUT==0
              OVERLAP SINGULAR REGION
   }
// Minimum MET2 enclosure of VIA2 (capacitor bottom plate) = 0.2
   OVLP_METC_VIA2BOTT_E1M2V2 {@ E1M2V2 Minimum MET2 enclosure of VIA2 (capacitor bottom plate) = 0.2
              ENC via2_near_cmim metcap_bottom_plate < 0.2 ABUT==0
              OVERLAP SINGULAR REGION
   }
// Minimum METCAP enclosure of VIA2 = 0.5
   OVLP_METC_VIA2_E1MCV2 {@ E1MCV2 Minimum METCAP enclosure of VIA2 = 0.5
              ENC VIA2 METCAP < 0.5 ABUT==0
              OVERLAP SINGULAR REGION
   }
// attention : chip is total area of all layers
// do only if metcap exists
// Minimum METCAP density [%] = 3
   ILL_METC_DIERATIO_R1MC {@ R1MC Minimum METCAP density [%] = 3
       DENSITY METCAP INSIDE OF LAYER (substrate_all INTERACT METCAP) < 0.03 PRINT "ratio_metcap_die.txt"
   }

// Minimum VIA2 density inside METCAP [%] = 1
   ILL_METC_VIA2_RATIO_R1V2 {@ R1V2 Minimum VIA2 density inside METCAP [%] = 1
              DENSITY VIA2 INSIDE OF LAYER METCAP < 0.01 PRINT "ratio_via2_metcap.txt"
   }
// MET1 under METCAP region is not allowed
   ILL_METC_MET1_BAD1M1 { @ BAD1M1 MET1 under METCAP region is not allowed
           MET1 AND METCAP
   }
//
   ILL_METC_OVER_DEVICE_RECG1 { @ CMIM_G1 : cmim device over active or passive device not allowed
           METCAP AND trans
           METCAP AND pres
           METCAP AND presh
           METCAP AND pdres
           METCAP AND ndres
           METCAP AND nwres
           METCAP AND pnpvert10
           METCAP AND pnplat
           METCAP AND cvar_device_layer
           METCAP AND cpoly
           METCAP AND INDDEF
           METCAP AND DIODE
           METCAP AND HALLDEF
   }
//
// DFM check for miss via2, guideline
//
   metcap_top_plate = MET3 AND METCAP
   metcap_top_plate_via2 = metcap_top_plate AND via2_near_cmim
   // min via2 spacing on metcap is 3.5
   // only estimated
   ILL_METC_MORE_VIA2_RECG2 { @ CMIM_G2 : cmim device : put as many via2 as possible on metcap for high Q
     metcap_top_plate_con =  STAMP metcap_top_plate BY routingmet3
     via2_closed = (SIZE  metcap_top_plate_via2 BY 1.8) AND metcap_top_plate
     via2_closed_conn = STAMP via2_closed BY routingvia2
     xx = NET AREA RATIO metcap_top_plate_con via2_closed_conn > 1.2
     SIZE (xx NOT via2_closed) BY 0.5 UNDEROVER
   }
#ENDIF
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//             floating metal checks and probe pads 
//
///////////////////////////////////////////////////////////////////////
// check floating metal/poly nets not connected to any device
//-------------------------------------------------------------
//  5-Feb-2003
// 24-Feb-2003 : poly2 added
//  3-Mar-2003 : feed cells ignored
//  2-Sep-2004 : fill rectangles poly1/met1/2/3 ingnored
// 22-Jul-2005 : probe pad must have only metal below, no via 
//-------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
//
// This check find isolated nets connected by any cont, vias
// by antenna checks 
// fillcells : area ndiff/poly/met1234 structures placed in empty
//             areas of chip for density, all structures are connected
//             but not connected to substrate
// fill pattern : are 2 * 5 top metal isolated rectangles placed near 
//                small top metal to avoid stress
// fillcells and fillpattern should NOT be flagged by this checked
//
// -  Following layers with connectivity are flagged :
//      poly, metal1, metal2, metal3, metal4
// -  Not flagged are diffusion and wells
// -  Rectangles for fill pattern on top metal are removed
// -  checks must be extended if fill pattern on other layers are used
// -  fill cells created by cal_fillcell are connected to ndiff : this connection
//    is removed to avoid output of metal of all fillcells
//
// attention : there are feed cells(25,10,5,2) in standard cell layout with diff cut layer
//             remove poly and metal from this structures
//             p/n device with drain connected to other gate
//
//
    ILL_FLOATING_NET_ERC {@ ERC Warning: floating net, net not connected to any device 
                //
                // metal with text is not floating
                //
                routingpoly_nopin = NOT NET routingpoly "?" 
                routingmet1_nopin = NOT NET routingmet1 "?" 
                routingmet2_nopin = NOT NET routingmet2 "?" 
                routingmet3_nopin = NOT NET routingmet3 "?" 
                //
                conn_pol1_ng = NET AREA RATIO routingpoly_nopin ngate_sd > 0
                conn_met1_ng = NET AREA RATIO routingmet1_nopin ngate_sd > 0
                conn_met2_ng = NET AREA RATIO routingmet2_nopin ngate_sd > 0
                conn_met3_ng = NET AREA RATIO routingmet3_nopin ngate_sd > 0
                //
                conn_pol1_pg = NET AREA RATIO routingpoly_nopin pgate_sd > 0
                conn_met1_pg = NET AREA RATIO routingmet1_nopin pgate_sd > 0
                conn_met2_pg = NET AREA RATIO routingmet2_nopin pgate_sd > 0
                conn_met3_pg = NET AREA RATIO routingmet3_nopin pgate_sd > 0
                //
                conn_pol1_tr = NET AREA RATIO routingpoly_nopin trans_no_name > 0
                conn_met1_tr = NET AREA RATIO routingmet1_nopin trans_no_name > 0
                conn_met2_tr = NET AREA RATIO routingmet2_nopin trans_no_name > 0
                conn_met3_tr = NET AREA RATIO routingmet3_nopin trans_no_name > 0
                //
                conn_pol1_re = NET AREA RATIO routingpoly_nopin RESTRM > 0
                conn_met1_re = NET AREA RATIO routingmet1_nopin RESTRM > 0
                conn_met2_re = NET AREA RATIO routingmet2_nopin RESTRM > 0
                conn_met3_re = NET AREA RATIO routingmet3_nopin RESTRM > 0
                //
                conn_pol1_rh = NET AREA RATIO routingpoly_nopin preshterm > 0
                conn_met1_rh = NET AREA RATIO routingmet1_nopin preshterm > 0
                conn_met2_rh = NET AREA RATIO routingmet2_nopin preshterm > 0
                conn_met3_rh = NET AREA RATIO routingmet3_nopin preshterm > 0
                //
                // remove feed zells from floating net
                //
                feed_diff = DIFCUT AND DIFF
                feed_trans = feed_diff AND routingpoly
                feed_trans_n = feed_trans AND NPLUS
                feed_trans_p = feed_trans AND PPLUS
                feed_diff_n = feed_diff INTERACT feed_trans_n
                feed_diff_p = feed_diff INTERACT feed_trans_p
                feed_diff_nc = CONT INSIDE feed_diff_n
                feed_diff_pc = CONT INSIDE feed_diff_p
                met1_not_float_n = routingmet1_nopin ENCLOSE feed_diff_nc
                met1_not_float_p = routingmet1_nopin ENCLOSE feed_diff_pc
                // remove this from floating
                met1_not_float = met1_not_float_n OR met1_not_float_p
                poly1_not_float = (routingpoly_nopin INTERACT (feed_trans_n OR feed_trans_p))
                                   INTERACT met1_not_float
                //
                // remove fill cells from floating net 
                //
                // ndiff is connected to fill cells pattern         
                ndiff_fill   = ndiff OUTSIDE routingnwell
                conn_pol1fill_1 = NET AREA RATIO routingpoly_nopin ndiff_fill > 0
                conn_met1fill_1 = NET AREA RATIO routingmet1_nopin ndiff_fill > 0
                conn_met2fill_1 = NET AREA RATIO routingmet2_nopin ndiff_fill > 0
                conn_met3fill_1 = NET AREA RATIO routingmet3_nopin ndiff_fill > 0
                // all metal crosses 
                merge_area1_3m = conn_pol1fill_1 AND (conn_met1fill_1 AND
                              (conn_met2fill_1 AND conn_met3fill_1))
#IFDEF fourmetal
                routingmet4_nopin = NOT NET routingmet4 "?" 
                conn_met4fill_1 = NET AREA RATIO routingmet4_nopin ndiff_fill > 0
                merge_area1 = merge_area1_3m AND conn_met4fill_1
#ELSE
                merge_area1 = COPY merge_area1_3m
#ENDIF
                // crossing area wit 1 via inside
                merge_area2 = RECTANGLE merge_area1 > 1.9 BY > 3.0
                merge_area = merge_area2 ENCLOSE VIA == 1
                // get fillcell 
                conn_pol1_fi = conn_pol1fill_1 INTERACT merge_area
                conn_met1_fi = conn_met1fill_1 INTERACT merge_area
                conn_met2_fi = conn_met2fill_1 INTERACT merge_area
                conn_met3_fi = conn_met3fill_1 INTERACT merge_area
#IFDEF fourmetal
                conn_met4_fi = conn_met4fill_1 INTERACT merge_area
#ENDIF
                //
                err_poly1 = routingpoly_nopin NOT (conn_pol1_ng OR (conn_pol1_pg OR (conn_pol1_tr OR
                     (conn_pol1_re OR (conn_pol1_rh OR (conn_pol1_fi OR poly1_not_float))))))
                err_met1 = routingmet1_nopin NOT (conn_met1_ng OR (conn_met1_pg OR 
                     (conn_met1_tr OR (conn_met1_re OR (conn_met1_rh OR (conn_met1_fi OR met1_not_float))))))
                err_met2 = routingmet2_nopin NOT (conn_met2_ng OR (conn_met2_pg OR
                     (conn_met2_tr OR (conn_met2_re OR (conn_met2_rh OR conn_met2_fi)))))
                // do not flag fill rectangles
                fillrp1 = RECTANGLE poly1_cut == 2.0 BY == 5.0
                fillrm1 = RECTANGLE met1_withslots == 2.0 BY == 5.0
                fillrm2 = RECTANGLE met2_withslots == 2.0 BY == 5.0
                err_poly1 NOT fillrp1
                err_met1  NOT fillrm1
                err_met2  NOT fillrm2
                err_met3 = routingmet3_nopin NOT (conn_met3_ng OR (conn_met3_pg OR
                     (conn_met3_tr OR (conn_met3_re OR (conn_met3_rh OR conn_met3_fi)))))
#IFDEF fourmetal
                COPY err_met3
#ELSE
                fillr3 = RECTANGLE met3_withslots == 2.0 BY == 5.0
                err_met3 NOT fillr3
#ENDIF
//
//  add poly2 
//
                routingpoly2_nopin = NOT NET routingpoly2 "?" 
                conn_pol2_ng = NET AREA RATIO routingpoly2_nopin ngate_sd > 0
                conn_pol2_pg = NET AREA RATIO routingpoly2_nopin pgate_sd > 0
                conn_pol2_tr = NET AREA RATIO routingpoly2_nopin trans_no_name > 0
                conn_pol2_re = NET AREA RATIO routingpoly2_nopin RESTRM > 0
                conn_pol2_rh = NET AREA RATIO routingpoly2_nopin preshterm > 0
                routingpoly2_nopin NOT (conn_pol2_ng OR (conn_pol2_pg OR (conn_pol2_tr OR
                     (conn_pol2_re OR conn_pol2_rh ))))
//
//  four metal process
//
#IFDEF fourmetal
                conn_met4_ng = NET AREA RATIO routingmet4_nopin ngate_sd > 0
                conn_met4_pg = NET AREA RATIO routingmet4_nopin pgate_sd > 0
                conn_met4_tr = NET AREA RATIO routingmet4_nopin trans_no_name > 0
                conn_met4_re = NET AREA RATIO routingmet4_nopin RESTRM > 0
                conn_met4_rh = NET AREA RATIO routingmet4_nopin preshterm > 0
                err_met4 = routingmet4_nopin NOT (conn_met4_ng OR (conn_met4_pg OR 
                     (conn_met4_tr OR (conn_met4_re OR (conn_met4_rh OR conn_met4_fi)))))
                fillr4 = RECTANGLE met4_withslots == 2.0 BY == 5.0
                err_met4 NOT fillr4
#ENDIF
    }
///////////////////////////////////////////////////////////////////////
// 
// This check is useful for finding any pad shorts if no LVS is done
// If more VSS pads exist : short over substrate
//
// check for any pad shorts, may be VSS also, to find shorts without any text
// short is also substrate short, not only metal short
// pads with supply text are NOT removed  !!! 
//
#IFDEF fourmetal
   SHORTED_PADS_EQ2_SERC { @ ERC Warning : 2 pads are shorted ( may be intentional VSS) 
     x =  NET AREA RATIO routingmet4 PAD == 2 [ COUNT(PAD)]
     NET AREA RATIO PAD x > 0
   }
   SHORTED_PADS_EQ3_SERC { @ ERC Warning : 3 pads are shorted ( may be intentional VSS)
      x = NET AREA RATIO routingmet4 PAD == 3 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
   SHORTED_PADS_EQ4_SERC { @ ERC Warning : 4 pads are shorted ( may be intentional VSS)
      x = NET AREA RATIO routingmet4 PAD == 4 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
   SHORTED_PADS_GT4_SERC { @ ERC Warning : more than 4 pads are shorted ( may be intentional VSS)
      x = NET AREA RATIO routingmet4 PAD > 4 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
#ELSE
   SHORTED_PADS_EQ2_SERC { @ ERC Warning : 2 pads are shorted ( may be intentional VSS) 
     x =  NET AREA RATIO routingmet3 PAD == 2 [ COUNT(PAD)]
     NET AREA RATIO PAD x > 0
   }
   SHORTED_PADS_EQ3_SERC { @ ERC Warning : 3 pads are shorted ( may be intentional VSS)
      x = NET AREA RATIO routingmet3 PAD == 3 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
   SHORTED_PADS_EQ4_SERC { @ ERC Warning : 4 pads are shorted ( may be intentional VSS)
      x = NET AREA RATIO routingmet3 PAD == 4 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
   SHORTED_PADS_GT4_SERC { @ ERC Warning : more than 4 pads are shorted ( may be intentional)
      x = NET AREA RATIO routingmet3 PAD > 4 [ COUNT(PAD)]
      NET AREA RATIO PAD x > 0 
   }
#ENDIF

//=====================================================================
//                           PROBE PADS   
//=====================================================================
//
// probe pads do not have any pad layer
//
   probe_layer = COPY PROBE
//
// ATTENTION : NO pad window !!!!!!!!
//
   INFO_PROBE_PAD {@ INFO: Probe pad with probe layer
               COPY probe_layer
   }
//
// check for missing top metal on probe pads
// top metal too small, missing via
// 3.0 is min width
//
#IFDEF fourmetal
   ILL_MISS_MET4_PROBE_ERC {@ ERC Warning: Missing met4 and/or via3 on Probe Pad
               probe_layer NOT INTERACT MET4
               // probe_layer NOT ENCLOSE VIA3
   }
   ILL_WIDTH_MET4_PROBE_ERC {@ ERC Warning: met4 on Probe Pad too small
               x = probe_layer AND MET4
               INT x < 3.0
   }
#ELSE
   ILL_MISS_MET3_PROBE_ERC {@ ERC Warning: Missing met3 and/or via2 on Probe Pad
               probe_layer NOT INTERACT MET3
               // probe_layer NOT ENCLOSE VIA2
   }
   ILL_WIDTH_MET3_PROBE_ERC {@ ERC Warning: met3 on Probe Pad too small
               x = probe_layer AND MET3
               INT x < 3.0
   }
#ENDIF
//
// no dokumentation but I use 3 U
//
   WIDTH_PROBE_PAD_ERC {@ ERC Warning: Minimum PROBE width = 3 U
                   INT probe_layer < 3 ABUT<90 SINGULAR REGION
   }
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                     HALL element checks
//                     PHOTO diode checks
///////////////////////////////////////////////////////////////////////
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                 2-Jul-2003       aob      basic hall check        
//                14-Feb-2005       aob      rules extended
//                                           element rules added
//                 9-Nov-2005       aob      conterclockwise is error (kri)
//                13-Feb-2007       aob      add photo diode checks
//                 3-Aug-2007       aob      c35o doc rev 1 ENG - 325 implemented
///////////////////////////////////////////////////////////////////////
//
//                         hall element rules
//
///////////////////////////////////////////////////////////////////////
//
// not identified hall element ( no name found )
//
   hall_identified = COPY hall_body_HALLC35
   // replace for more hall elements
   // hall_identified = hall_body_HALLC35 OR (hall_body_hall1 OR hall_body_hall2)
   BAD_HALL_UNIDENT { @ Name of hall element not identified
      HALLDEF NOT hall_identified
   }
//
// check for any bad layer on hall center
//----------------------------------------
//
   BAD_HALL_ILLEGAL_LAYER {@ Error: bad layer in center of hall element 
      halldef_in  = SIZE HALLDEF BY -16.6
      MET1 AND halldef_in
      MET2 AND halldef_in
      MET3 AND halldef_in
      POLY1 AND halldef_in
      POLY2 AND halldef_in
#IFDEF fourmetal
      MET4 AND halldef_in
#ENDIF
      DIFF AND halldef_in
      PAD AND halldef_in
      implant AND halldef_in
   }
//
// check hall orientation 
//-------------------------------------
// a,b,c,d must be clockwise 
//
// create square on term
   hall_a  =  (EXPAND TEXT "A" M1PIN BY 0.5) INTERACT HALLDEF
   hall_b  =  (EXPAND TEXT "B" M1PIN BY 0.5) INTERACT HALLDEF
   hall_c  =  (EXPAND TEXT "C" M1PIN BY 0.5) INTERACT HALLDEF
   hall_d  =  (EXPAND TEXT "D" M1PIN BY 0.5) INTERACT HALLDEF
   // hall_a { COPY hall_a }
   // hall_b { COPY hall_b }
   // hall_c { COPY hall_c }
   // hall_d { COPY hall_d }
//
//

// check for existance of terminals
//
   HALLC35_MISS_TERM_A { @ ERROR : Text for terminal A is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_a
   }
   HALLC35_MISS_TERM_B { @ ERROR : Text for terminal B is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_b
   }
   HALLC35_MISS_TERM_C { @ ERROR : Text for terminal C is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_c
   }
   HALLC35_MISS_TERM_D { @ ERROR : Text for terminal D is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_d
   }
   HALLC35_MISS_TERM_P1 { @ ERROR : Text for terminal P1 is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_p1
   }
   HALLC35_MISS_TERM_P2 { @ ERROR : Text for terminal P2 is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_p2
   }
   HALLC35_MISS_TERM_S { @ ERROR : Text for terminal S is missing on HALLC35
      hall_body_HALLC35 NOT INTERACT hall_term_s
   }
//
// check for orientation makes only sense if 4 terms exist
//
   hall_body_a = hall_body_HALLC35 INTERACT hall_term_a
   hall_body_b = hall_body_HALLC35 INTERACT hall_term_b
   hall_body_c = hall_body_HALLC35 INTERACT hall_term_c
   hall_body_d = hall_body_HALLC35 INTERACT hall_term_d
   hall_body_4terms_good =  hall_body_a AND (hall_body_b AND (hall_body_c AND hall_body_d))
//
//
// create lines between a,b,c,d ...assume hall is 45 degrees rotated
// following 4 positions are possible
//  a b    d a   c d   b c
//  d c    c b   b a   a b
// grow lines to center for all 4 possibilities, 1 should match
// if no match : wrong orientation
//
   hall_dist_a_b = EXT hall_a hall_b < 40.0 REGION PARA OPPOSITE
   hall_dist_b_c = EXT hall_b hall_c < 40.0 REGION PARA OPPOSITE
   hall_dist_c_d = EXT hall_c hall_d < 40.0 REGION PARA OPPOSITE
   hall_dist_d_a = EXT hall_d hall_a < 40.0 REGION PARA OPPOSITE
   // hall_dist_a_b { COPY hall_dist_a_b }
   // hall_dist_b_c { COPY hall_dist_b_c }
   // hall_dist_c_d { COPY hall_dist_c_d }
   // hall_dist_d_a { COPY hall_dist_d_a }
// 
   a1 = GROW hall_dist_a_b BOTTOM BY 20.0
   a2 = GROW hall_dist_b_c LEFT BY 20.0
   a3 = GROW hall_dist_c_d TOP BY 20.0
   a4 = GROW hall_dist_d_a RIGHT BY 20.0
   mergea = a1 AND (a2 AND (a3 AND a4))
   // mergea { COPY mergea } 
//
   b1 = GROW hall_dist_a_b LEFT   BY 20.0
   b2 = GROW hall_dist_b_c TOP    BY 20.0
   b3 = GROW hall_dist_c_d RIGHT  BY 20.0
   b4 = GROW hall_dist_d_a BOTTOM BY 20.0
   mergeb = b1 AND (b2 AND (b3 AND b4))
   // mergeb { COPY mergeb } 
// 
   c1 = GROW hall_dist_a_b TOP   BY 20.0
   c2 = GROW hall_dist_b_c RIGHT BY 20.0
   c3 = GROW hall_dist_c_d BOTTOM BY 20.0
   c4 = GROW hall_dist_d_a LEFT   BY 20.0
   mergec = c1 AND (c2 AND (c3 AND c4))
   // mergec { COPY mergec } 
// 
   d1 = GROW hall_dist_a_b RIGHT   BY 20.0
   d2 = GROW hall_dist_b_c BOTTOM BY 20.0
   d3 = GROW hall_dist_c_d LEFT BY 20.0
   d4 = GROW hall_dist_d_a TOP   BY 20.0
   merged = d1 AND (d2 AND (d3 AND d4))
   // merged { COPY merged } 
   mergeall = mergea OR ( mergeb OR (mergec OR merged))
   // mergeall { COPY mergeall }
   hall_ntub = NTUB INTERACT HALLDEF
   hall_ntub_mid = EXTENTS hall_ntub CENTERS 
//
//
// hall_ntub_mid { COPY hall_ntub_mid }
// BAD_HALL_COUNTERCLOCKWISE { @ Error: Orientation of hall element pins a/b/c/d is anti-clockwise 
//    x = hall_ntub_mid NOT INTERACT (mergeall AND hall_ntub)
//    hall_ntub INTERACT x  
// }
//
// output orientation
//
// only output if 4 terms found
//
   hall_orient = hall_ntub_mid NOT INTERACT (mergeall AND hall_ntub)
   hall_orient_anti = (hall_ntub INTERACT hall_orient) INTERACT hall_body_4terms_good
   HALLC35_ERROR_COUNTERCLOCKWISE { @ ERROR : Orientation of hall element pins a/b/c/d is anti-clockwise
       COPY hall_orient_anti
   }
//
   hall_orient_clock = (hall_ntub NOT INTERACT hall_orient_anti) INTERACT hall_body_4terms_good
   HALLC35_ORIENT_CLOCKWISE_INFO { @ INFO: Orientation of hall element pins a/b/c/d is clockwise
       COPY hall_orient_clock
   }
//
   hall_orient_unident = hall_ntub NOT INTERACT (hall_orient_anti OR hall_orient_clock)
   HALLC35_ERR_ORIENT_UNIDENTIFIED { @ ERROR : Orientation of hall element pins a/b/c/d is unidentified
       COPY hall_orient_unident
   }
//
//=====================================================================
//                       HALLC35 ELEMENT rules
//=====================================================================
//
// NTUB area [um^2] = 1503.2   NTUB area [um^2] = 1503.2   
// NTUB perimeter [um] = 180.9   NTUB perimeter [um] = 180.9   
// Inner PTAP perimeter [um] = 198   Inner PTAP perimeter [um] = 198   
// Inner coil perimeter [um] = 97.4   Inner coil perimeter [um] = 97.4   
//
   HALL_NTUB_AREA { @ HALLC35 Element Rule : NTUB area [um 2] =  1503.2
      good = AREA hall_ntub > 1490.0 < 1510.0
      hall_ntub NOT good
   }
//
   HALL_NTUB_PERIM { @ HALLC35 Element Rule : NTUB perimeter [um] = 180.9 180.9
      good = PERIMETER hall_ntub > 175 < 185
      hall_ntub NOT good
   }
//
   HALL_PTAP_PERIM { @ HALLC35 Element Rule : Inner PTAP perimeter [um] = 198 198
     x = HOLES (ndiff AND HALLDEF)
     good = PERIMETER x > 190 < 205
     x NOT good
   }
//
   HALL_COIL_PERIM { @ HALLC35 Element Rule : Inner coil perimeter [um] = 97.4 97.4
     coil_inner = HOLES( (MET1 AND halldef_cut) OR (MET2 AND halldef_cut))
     good = PERIMETER coil_inner > 95 < 102
     coil_inner NOT good
   }
///////////////////////////////////////////////////////////////////////
//
//                       PHOTO diode rules
//                  0.35 U CMOS C35O design rules
//
///////////////////////////////////////////////////////////////////////
// PHDNW850 no ARC ( anti reflect coating)
// PHDNWA850 with ARC 
// ARC is not drawn on GDSII
///////////////////////////////////////////////////////////////////////

#IFDEF layer_devdefopto
//
// 4.1.1 DEVDEF Opto checks
//
// not in doc, but check all possible layer
// nofill ok
//
   PHDNWA850_PHOTO_DIODE_ILL_LAYER { @ PHDNWA850 PHOTO DIODE : Illegal layer on photo diode
          diode_phdnwa850 AND PAD
          diode_phdnwa850 AND CONT
          diode_phdnwa850 AND VIA
          diode_phdnwa850 AND VIA2
          diode_phdnwa850 AND VIA3
          diode_phdnwa850 AND MIDOX
          diode_phdnwa850 AND PPLUS
          diode_phdnwa850 AND HRES
          diode_phdnwa850 AND FIMP
          diode_phdnwa850 AND RESDEF
          diode_phdnwa850 AND TUBDEF
          OPTDEF AND DIFCUT
          diode_phdnwa850 AND DIODE
          diode_phdnwa850 AND ZENER
   }
//
#IFDEF fourmetal
   PHDNWA850_PHOTO_DIODE_PHR001 { @ PHDNWA850 PHOTO DIODE PHR001 : Illegal layer on photo diode
                                  @ poly1/poly2/met1/met2/met3/met4
          POLY1 INTERACT OPTDEF
          POLY2 INTERACT OPTDEF
          MET1 INTERACT OPTDEF
          MET2 INTERACT OPTDEF
          MET3 INTERACT OPTDEF
          MET4 INTERACT OPTDEF
   }
#ELSE
   PHDNWA850_PHOTO_DIODE_PHR001 { @ PHDNWA850 PHOTO DIODE PHR001 : Illegal layer on photo diode
                                  @ poly1/poly2/met1/met2/met3
          POLY1 INTERACT OPTDEF
          POLY2 INTERACT OPTDEF
          MET1 INTERACT OPTDEF
          MET2 INTERACT OPTDEF
          MET3 INTERACT OPTDEF
   }
#ENDIF
//
   PHDNWA850_PHOTO_DIODE_NTUB_BAD4 {@ PHDNWA850 PHOTO DIODE : ntub must not enclose any other data
       x = routingnwell INTERACT diode_phdnwa850
       x AND PAD
       x AND POLY1
       x AND POLY2
       x AND MIDOX
       x AND PPLUS
       x AND HRES
       x AND RESDEF
       x AND TUBDEF
       x AND DIODE
   }
//
   PHDNWA850_PHOTO_DIODE_BAD1 { @ PHDNWA850 PHOTO DIODE : ntub does not enclose OPTDEF
       OPTDEF NOT INSIDE NTUB
   }
//
// no holes or missing data inside
// optdef does not have ntub and ndiff below
   PHDNWA850_PHOTO_DIODE_BAD2 { @ PHDNWA850 PHOTO DIODE : OPTDEF does not cover ntub and ndiff totally 
          OPTDEF NOT diode_phdnwa850 
   }
//
// not totally enclosing
   PHDNWA850_PHOTO_DIODE_BAD3 { @ PHDNWA850 PHOTO DIODE : OPTDEF layer outside of ntub and ndiff
       OPTDEF NOT ENCLOSE  diode_phdnwa850
   }
//
// missing text on top for 3. pin
// text for light missing on top level of hierarchie
// please add value on layer OPTDEF for correct simulation
//
    PHDNWA850_PHOTO_DIODE_MISS_LIGHT_TXT { @ PHDNWA850 PHOTO DIODE : text label for light terminal (P) missing on top level of hierarchie
                                 @ please add label with terminal name on layer "DEVDEF opto" for 
                                 @ correct extraction
       OPTDEF NOT WITH TEXT "?" OPTDEF_TEXT PRIMARY ONLY
   }
//
// 5.1.1 Element  rules
//
//
// w/l checks
// Minimum NTUB size (W and L) = 5 
   PHDNWA850_PHOTO_DIODE_MIN_WIDTH {@ PHDNWA850 PHOTO DIODE : Minimum NTUB size (W and L) = 5
       INT (routingnwell INTERACT diode_phdnwa850) < 5.0 ABUT<90 SINGULAR REGION
   }
//
// Maximum NTUB size (W and L) = 150 
   PHDNWA850_PHOTO_DIODE_MAX_LENGTH {@ PHDNWA850 PHOTO DIODE :  Maximum NTUB size (W and L) = 150
       LENGTH ( routingnwell INTERACT diode_phdnwa850)  > 150.0
   }
//
//   PHDNWA850_PHOTO_DIODE_NOT_SQUARE_INFO { @ PHDNWA850 PHOTO DIODE : OPTDEF layer is not square
//         diode_phdnwa850_square = RECTANGLE diode_phdnwa850 ASPECT == 1
//         diode_phdnwa850 NOT  diode_phdnwa850_square
//   }
//
   INFO_PHDNWA850_PHOTO_DIODE_DIFF_NOT_SQUARE { @ PHDNWA850 INFO PHOTO DIODE : NDIFF is not square
        y = ndiff INTERACT diode_phdnwa850
        x = RECTANGLE y ASPECT == 1
        y NOT x
   }
//
// must be rectangle
   PHDNWA850_ILL_PHOTO_DIODE_NOT_RECT { @ PHDNWA850 INFO PHOTO DIODE : PHOTO diode is not square
        diode_phdnwa850 NOT RECTANGLE
   }
//
   INFO_PHDNWA850_PHOTO_DIODE_NTUB_NOT_SQUARE { @ PHDNWA850 INFO PHOTO DIODE : NTUB is not square
        y = routingnwell INTERACT diode_phdnwa850
        x = RECTANGLE y ASPECT == 1
        y NOT x
   }
//
// check if substrate pdiff near 2 U
   phdnwa_grow_area  = substrate_all NOT pdiff
   phdnwa_1 = SIZE diode_phdnwa850 BY 2.0 INSIDE OF phdnwa_grow_area STEP 0.05
   phdnwa_2 = phdnwa_1 NOT COINCIDENT OUTSIDE EDGE pdiff
   phdnwa_3 = phdnwa_2 EXPAND EDGE INSIDE BY 0.2
   PHDNWA850_PHOTO_DIODE_MISS_PTAP_S1 { @ PHDNWA850 PHOPTO DIODE : miss substrate ptap fixed distance 0.4 U
        COPY phdnwa_3
   }
//
// assume ptap in between
// min ntub spacing is 1 U
// 
//   PHDNWA850_SPAC_PHOTO_DIODE {@ PHDNWA850 Minimum PHOTO DIODE spacing = 1.9  U
//                     @ add substrate ptap between photo diodes
//       EXT diode_phdnwa850  < 1.90 ABUT<90 SINGULAR REGION
//   }
//
// hot nwell spacing
// Minimum spacing of NTUB with different potential = 3
// same check also NWS1
   PHDNWA850_SPAC_PHOTO_DIODE_DIFFNET {@ PHDNWA850 Minimum PHOTO DIODE spacing = 3.0 different potential U
         EXT (routingnwell INTERACT diode_phdnwa850)  < 3 SPACE SINGULAR REGION
                                       NOT CONNECTED
   }
//
// Fixed NTUB enclosure of NDIFF = 0.2 
   PHDNWA850_OVLP_NTUB_NDIFF_E1_ELE {@ PHDNWA850_E1 : Fixed NTUB enclosure of NDIFF = 0.2
     phwell = routingnwell INTERACT diode_phdnwa850
     phndiff = ndiff INTERACT diode_phdnwa850
     phwell_good1 =  ENC ndiff  phwell == 0.2  OPPOSITE PARA ONLY REGION
     phwell_all   =  ENC ndiff  phwell < 2.0 OPPOSITE PARA ONLY REGION
     phwell_all NOT  phwell_good1
   }
// Fixed PDIFF to NTUB spacing = 0.4 
   PHDNWA850_SPAC_NTUB_PDIFF_S1_ELE {@ PHDNWA850_S1 : Fixed PDIFF to NTUB spacing = 0.4
     phwell = routingnwell INTERACT diode_phdnwa850
     phwell_good =  EXT pdiff phwell == 0.4  OPPOSITE PARA ONLY REGION
     phwell_all  =  EXT pdiff phwell < 2  OPPOSITE PARA ONLY REGION
     phwell_all NOT phwell_good
   }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//             end of hall check  end of hall check
//                 end of photo diode check  
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
//                0.35 U CMOS C35 Element Layouts
//
//       Document: ENG-234                      Revision: 2.0
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                 4-Jul-2003       aob      basic check
//                14-Jul-2003       aob   zener diode update
//                                        m4 variables added
//                23-Jul-2003       aob   nmosh_s1 extended to 5.5 U
//                20-Oct-2003       aob   z-diode edge length changed   
//                                        from 0.36 to 0.408
//                 2-Dec-2003       aob   zdiode impl edge 0.405-0.41 
//                26-May-2004       aob   cvar y1 modfied 
//                 7-Mar-2006       aob   vert10 use inner holes (h35 difffill)
///////////////////////////////////////////////////////////////////////
//
// all these check make only sense, if device is recogniced
//
//=====================================================================
//                       VERT10 ELEMENT rules
//=====================================================================
//
// EMITTER-PDIFF perimeter / 4 = 10
// VERT10_P1 Emitter pdiff perimeter/4 = 10  40 
// not checked : this is part of device recognition
//
// BASE-NTUB perimeter / 4 = 13.8
// VERT10_P2 Base NTUB Perimeter/4 = 13.8    55.2
   pnpvert10_ntub = NTUB INTERACT pnpvert10
   VERT10_BASE_NTUB_PERI_P2_ELEM {@ VERT10_P2 Element Rule : Base Ntub Perimeter/4 = 13.8
      good = PERIMETER pnpvert10_ntub > 55.1 < 55.3
      pnpvert10_ntub NOT good
   }
//
// h35 : may be inside ptap
// PTAP inside perimeter / 4 = 14.9
// VERT10_P3 Ptap Inside Perimeter/4 = 14.9  59.6
   VERT10_PTAP_INSIDE_PERI_P3_ELEM {@ VERT10_P3 Element Rule : Ptap Inside Perimeter/4 = 14.9
      x = (HOLES pdiff < 1000.0 INNER) INTERACT pnpvert10
      good = PERIMETER x > 59.5 < 59.7
      y = x NOT good
      y COINCIDENT OUTSIDE EDGE pdiff
   }
//
// NTUB enclosure of NTAP = 0.45
   VERT10_OVLP_NTUB_NTAP_E1_ELEM {@ VERT10_E1 Element Rule : NTUB enclosure of ntap = 0.45
     good = ENC ndiff pnpvert10_ntub == 0.45 OPPOSITE PARA ONLY REGION
     all = ENC ndiff pnpvert10_ntub < 8.0 OPPOSITE PARA ONLY REGION
     all NOT good
   }
//
//=====================================================================
//                       LAT2 ELEMENT rules
//=====================================================================
//
// EMITTER perimeter / 4 = 2
// LAT2_P1  Emitter Perimeter
   LAT2_EMITTER_PERI_P1_ELEM {@ LAT2_P1 Element Rule : Emitter Perimeter/4 = 2
       good = PERIMETER pnplat2_e >7.95 <8.05
       pnplat2_e NOT good
   }
// COLLECTOR-PDIFF perimeter / 4 = 6.2
// LAT2_P2 Collector pdiff Perimeter/4 = 6.2
   LAT2_COLL_PDIFF_PERI_P2_ELEM {@ LAT2_P2 Element Rule : Collector pdiff Perimeter/4 = 6.2
      x = pdiff_1 INTERACT pnplat2_g
      good = PERIMETER x > 24.7 < 24.9
      x NOT good
   }
// BASE-NTUB perimeter / 4 = 10
// LAT2_P3 Base Ntub Perimeter/4 = 10.0
   pnplat2_ntub = NTUB INTERACT pnplat2_g
   LAT2_BASE_NTUB_PERI_P3_ELEM {@ LAT2_P3 Element Rule : Base Ntub Perimeter/4 = 10.0
      good = PERIMETER pnplat2_ntub > 39.9 < 40.1
      pnplat2_ntub NOT good
   }
// PTAP inside perimeter / 4 = 11.1
// LAT2_P4 Ptap Inside Perimeter/4 = 11.1
   LAT2_PTAP_INSIDE_PERI_P4_ELEM {@ LAT2_P4 Element Rule : Ptap Inside Perimeter/4 = 11.1
      x = (HOLES pdiff < 200.0) INTERACT pnplat2_g
      good = PERIMETER x > 44.3 < 44.5
      y = x NOT good
      y COINCIDENT OUTSIDE EDGE pdiff
   }
// lateral BASE width = 10
// LAT2_W1 Lateral Base Width = 1
   LAT2_BASE_WIDTH_W1_ELEM {@ LAT2_W1 Element Rule : Lateral Base Width = 1
      good = INT pnplat2_g == 1.0 OPPOSITE PARA ONLY REGION
      all = INT pnplat2_g < 1.5 OPPOSITE PARA ONLY REGION
      all NOT good
   }
// NTUB enclosure of NTAP = 0.45
   LAT2_OVLP_NTUB_NTAP_E1_ELEM {@ LAT2_E1 Element Rule : NTUB enclosure of ntap = 0.45
     good = ENC ndiff pnplat2_ntub == 0.45 OPPOSITE PARA ONLY REGION
     all = ENC ndiff pnplat2_ntub < 1.0 OPPOSITE PARA ONLY REGION
     all NOT good
   }
// G must be connected to highest potential              
// LAT2_G1 gate must be connected to highest potential
   LAT2_GATE_NOVDD_G1_ELEM {@ LAT2_G1 Element Rule : gate of lat2 transistor not connected to VDD or VCC
     pgate_lat2x = routingpoly INTERACT pnplat2_g
     pgate_lat2  = STAMP pgate_lat2x BY routingpoly
     pgate_lat_vddvcc  = NET pgate_lat2 "?VDD?" "?VCC?"
     pgate_lat2 NOT pgate_lat_vddvcc
   }
//=====================================================================
//                    NMOSH/NMOSMH ELEMENT rules
//=====================================================================
// create layers to find nwells belonging to illegal hv transistors
// illegal is : ntub touches exactly trans
//              ntub ovlp != 1.6
//
// already in runset,
// also on ERC 
//
// GATE overlap of NTUB = 1.6              
   NMOSH_OVLP_GATE_NTUB_O1_ELEM { @ NMOSH_O1/NMOSMH_O1 Element Rule : Gate Overlap of Ntub = 1.6 U
     ndev INTERACT ill_hvmos_nwell
   }
// GATE to DRAIN-NDIFF spacing = 2.8              
   nmosh_draindiff = ndiff INTERACT nmosh_d_term
   NMOSH_SPAC_GATE_DRDIFF_S1_ELEM { @ NMOSH_S1/NMOSMH_S1 Element Rule : Gate Drain Diff spacing = 2.8 U
     good = EXT nmosh_draindiff nmoshall == 2.8 OPPOSITE PARA ONLY REGION
     all  = EXT nmosh_draindiff nmoshall < 5.5 OPPOSITE PARA ONLY REGION
     all NOT good
   }
// POLY1 extension of GATE = 0.6              
   NMOSH_OVLP_POLY_GATE_E1_ELEM { @ NMOSH_E1/NMOSMH_E1 Element Rule : Poly Extension of gate = 0.6 U
     good = ENC nmoshall routingpoly == 0.6 OPPOSITE PARA ONLY REGION
     all  = ENC nmoshall routingpoly < 1.5 OPPOSITE PARA ONLY REGION
     all NOT good
   }
// GATE length = 3               
// NMOSH_L1 gate length = 3
   NMOSH_GATE_LENGTH_L1_ELEM { @ NMOSH_L1/NMOSMH_L1 Element Rule : Gate Length = 3.0 U
      x = nmoshall OR ((ndiff INTERACT nmoshall) OR nmosh_d_fill)
      gate_l = COINCIDENT INSIDE EDGE x nmoshall
      NOT LENGTH gate_l > 2.95 < 3.05
   }
// DRAIN-NDIFF 45deg-corner = 0.6 
// NMOSH_X1 drain vertex
   NMOSH_DRAIN_NDIFF45_X1_1_ELEM { @ NMOSH_X1/NMOSMH_X1 Element Rule : drain angles = 45
       VERTEX nmosh_draindiff != 8
   }
// DRAIN-NDIFF 45deg-corner = 0.6 
// 0.849 = 0.6 * sqrt(2)
   NMOSH_DRAIN_NDIFF45_X1_2_ELEM { @ NMOSH_X1/NMOSMH_X1 Element Rule :edge length = 0.6 * sqrt(2)
       x = ANGLE nmosh_draindiff > 44.9 < 45.1
       NOT LENGTH x > 0.83 < 0.86
   }
//
//=====================================================================
//                    CVAR ELEMENT rules
//=====================================================================
// GATE unit width = 6.6
// 6.6  0.65
   CVAR_ILL_GATE_WIDTH_W1_ELEM { @ CVAR_W1 Element Rule : Gate unit width = 0.65
      good = INT cvar_ele == 0.65 OPPOSITE PARA ONLY REGION
      all = INT cvar_ele < 3.0 OPPOSITE PARA ONLY REGION
      all NOT good
   }
   cvar_gate_w = COINCIDENT INSIDE EDGE cvar_ele routingpoly
   CVAR_ILL_GATE_LENGTH_L1_ELEM { @ CVAR_L1 Element Rule : Gate unit length = 6.60
      NOT LENGTH cvar_gate_w > 6.55 < 6.65
   }
// GATE spacing = 1
   CVAR_ILL_GATE_SPAC_X1_ELEM { @ CVAR_X1 Element Rule : Gate spacing 1.0
      good = EXT cvar_gate_w == 1.0 OPPOSITE PARA ONLY REGION
      all = EXT cvar_gate_w < 2.0 OPPOSITE PARA ONLY REGION
      all NOT good
   }
// DIFF spacing = 1.6 
// check only between rows of 
   CVAR_ILL_DIFF_SPAC_Y1_ELEM { @ CVAR_Y1 Element Rule : Diff spacing 1.6
     // get diff edge touching pad
     diff_edge = TOUCH EDGE cvar_ndiff cvar_ele
     good = EXT diff_edge == 1.6 OPPOSITE PARA ONLY REGION
     all = EXT diff_edge < 3.0 OPPOSITE PARA ONLY REGION
     all NOT good
   }
//=====================================================================
//                  ZENER ZD2SM24 ELEMENT rules
//=====================================================================
// implant overlap = 0.2              
// check for implant ovlp 
   ZD2SM24_ILL_IMPL_OVLP_O1_ELEM { @ ZD2SM24_O1 Element Rule : must have 0.2 U implant ovlp
        zdiode_all NOT zdiode_02
   }
//
// dip width = 0.408               
// check for implant edge length on all diodes 
   zdiode_a = INT zdiode_all < 0.4 OPPOSITE PARA ONLY REGION
   zdiode_nimpl = zdiode_a COINCIDENT INSIDE EDGE ndiff
   zdiode_pimpl = zdiode_a COINCIDENT INSIDE EDGE pdiff
   ZD2SM24_ILL_IMPL_LENGTH_W1_ELEM { @ ZD2SM24_W1 Element Rule : must have 0.408 U implant edge length
        NOT LENGTH zdiode_nimpl > 0.405 < 0.41
        NOT LENGTH zdiode_pimpl > 0.405 < 0.41
   }
//
///////////////////////////////////////////////////////////////////////
//
//                 end of c35 element check
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
//              0.35 U CMOS C35 NMOS30 Element Layouts
//
//       Document: ENG-326                      Revision: 1.0
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                10-Sep-2007       aob   nmos30m/nmos30t added
//                15-Jul-2008       aob   update nmos30m REV2
//                                               nmos30t REV1 new
///////////////////////////////////////////////////////////////////////
//
//=====================================================================
//                  NMOS30M/NMOS30T ELEMENT rules
//=====================================================================
//
// check HVDEF 
//
// Minimum HVDEF spacing = 0.1
   SPAC_HVDEF_S1HVHV {@ S1HVHV Minimum HVDEF spacing = 0.1
      EXT HVDEF < 0.1 SPACE SINGULAR REGION
      }
//
// Minimum HVDEF spacing = 0.1
   SPAC_HVDEF_NOTCH_S1HVHV {@ S1HVHV Minimum HVDEF spacing = 0.1 notch
      EXT HVDEF < 0.1  ABUT < 90 NOTCH REGION
      }
//
// Each HVDEF shape must be marked with a single HVDEF text label
   ILL_HVDEF_MISS_TEXT_HVR001 { @ HVR001 : missing text on HVDEF
      HVDEF NOT WITH TEXT "?" HVDEF_TEXT
   }
//
// Each HVDEF shape must be marked with a single HVDEF text label
   hvdef_text_exp = EXPAND TEXT "?" HVDEF_TEXT  BY 0.1
   INFO_HVDEF_MULT_TEXT_HVR001 { @ HVR001 : multiple text on HVDEf found, is ok
     HVDEF ENCLOSE hvdef_text_exp > 1
   }
//
//----------------------------------------------------------------------
//       NMOS30T_rev:   1.0
//       NMOS30M_rev:   2.0
//
// check version
//
   nmos30t_hvdef = HVDEF WITH TEXT "NMOS30T_?" HVDEF_TEXT
   nmos30m_hvdef = HVDEF WITH TEXT "NMOS30M_?" HVDEF_TEXT
//
// REV2 NMOS30M
// REV1 NMOS30T !!!
//
   nmos30t_hvdef_ok = HVDEF WITH TEXT "NMOS30T_REV_1.0" HVDEF_TEXT
   nmos30m_hvdef_ok = HVDEF WITH TEXT "NMOS30M_REV_2.0" HVDEF_TEXT
//
// check, if any HVDEF on device
//
   NMOS30T_MISS_HVDEF_HVR001 { @ HVR001 : No HVDEF on nmos30t
     nmos30t NOT INSIDE HVDEF
   }
   NMOS30M_MISS_HVDEF_HVR001 { @ HVR001 : No HVDEF on nmos30m
     nmos30m NOT INSIDE HVDEF
   }
//
// check version
//
   NMOS30T_OBSOLETE_VERSION { @ HVR001 : Version of nmos30t is obsolete or missing
     nmos30t_hvdef NOT nmos30t_hvdef_ok
   }
   NMOS30M_OBSOLETE_VERSION { @ HVR001 : Version of nmos30m is obsolete or missing
     nmos30m_hvdef NOT nmos30m_hvdef_ok
   }
//
// check incorrect or missing HVDEF texting
//
   NMOS30T_ILL_HVDEF_HVR001 { @ HVR001 : HVDEF has illegal name on nmos30t
     nmos30t NOT INSIDE nmos30t_hvdef
   }
   NMOS30M_ILL_HVDEF_HVR001 { @ HVR001 : HVDEF has illegal name on nmos30m
     nmos30m NOT INSIDE nmos30m_hvdef
   }
//
   INFO_NMOS30T_HVDEF      { @ INFO : nmos30t HVDEF
    COPY nmos30t_hvdef
   }
   INFO_NMOS30M_HVDEF      { @ INFO : nmos30m HVDEF
    COPY nmos30m_hvdef
   }
//----------------------------------------------------------------------
//
// source must be connected because is one device
//
   nmos30_double_all = nmos30t_double OR nmos30m_double
   NMOS30_OPEN_SOURCE_HVR003 { @ HVR003 ERC Warning : NMOS30M/T sources must be connected together
          stamp1 =  STAMP nmos30_double_all BY ndiff_source ABUT ALSO
          x1 = nmos30_double_all NOT stamp1
          ndiff_source INTERACT x1
   }
//
//----------------------------------------------------------------------
// flag if source diff is not connected to suptap   
//
   NMOS30_SOURCE_SUPTAP_UNCONNECTED_ERC {@ ERC Warning: NMOS30M/T subtap not connected to source of nmos30m/nmos30t
     source30 =  ndiff_source TOUCH nmos30_hv_devices_all
     source30_float =  EXT source30 subtap < 0.7 INSIDE ALSO NOT CONNECTED REGION
     source30_float_edge  = EXPAND EDGE source30_float INSIDE BY 0.1
     source30 INTERACT source30_float_edge
   }
//----------------------------------------------------------------------
//
   ILL_HVDEF_NO_DEVICE_HVR001 { @ HVR001 : HVDEF does not enclose any HV-device
      HVDEF NOT ENCLOSE nmos30_double_all 
   }
//
//================================================================================
// element checks:         NMOS30T/NMOS30M
//================================================================================
// attention FIMP is NOT used, but FIDEF is identical and checked for
// DRC 
// internal naming convention not changed fimp = fidef
// no FIMP must be drawn on device
//
// Element rule revision of NMOS30T : 1.0
// Element rule revision of NMOS30M : 2.0
//
   nmos30_devlay_ele = nmos30t_double OR nmos30m_double
//
   nmos30_hvdef_all = nmos30t_hvdef_ok OR nmos30m_hvdef_ok
//
   nmos30_subtap_ele  = subtap INTERACT nmos30_hvdef_all
   nmos30_fimp_device_ele    = FIDEF INTERACT nmos30_devlay_ele
// obsolete
   // nmos30_fimp_iso_ele    = (FIDEF INTERACT nmos30_hvdef_all) NOT nmos30_fimp_device_ele
//
   nmos30_poly_ele    = POLY1 INTERACT nmos30_devlay_ele
   nmos30_poly_holes_ele = HOLES nmos30_poly_ele INNER              
   nmos30_ndiff_ele = ndiff_1 INTERACT nmos30_devlay_ele
   nmos30_drain_ndiff_ele = nmos30_ndiff_ele INSIDE  nmos30_poly_holes_ele
   nmos30_source_ndiff_ele = nmos30_ndiff_ele NOT nmos30_drain_ndiff_ele
//
   //nmos30_drain_ndiff_ele { COPY nmos30_drain_ndiff_ele }
   //nmos30_source_ndiff_ele { COPY nmos30_source_ndiff_ele }
//
   nmos30_lw_ele  = (nmos30_poly_ele AND nmos30_ndiff_ele ) NOT  nmos30_fimp_device_ele
   //nmos30_lw_ele { COPY nmos30_lw_ele}
//
   nmos30_ntub_stripes_ele = NTUB INTERACT nmos30_devlay_ele
   nmos30_subtap_holes_ele = (HOLES nmos30_subtap_ele INNER) INTERACT nmos30_devlay_ele
//
   nmos30_lw_edge_ele = nmos30_lw_ele NOT COIN EDGE nmos30_poly_ele
   nmos30_l_edge_ele = nmos30_lw_edge_ele NOT COIN EDGE nmos30_fimp_device_ele
//
   //nmos30_l_edge_ele { COPY nmos30_l_edge_ele }
//--------------------------------------------
// NMOS30M_L : Minimum CHANNEL length = 0.5
// Minimum CHANNEL length = 0.5
// NMOS30M_L : Minimum CHANNEL length = 0.5 
// NMOS30T_L : Minimum CHANNEL length = 0.5 
   NMOS30_GATE_LENGTH_L_ELEM { @ NMOS30T/NMOS30M Element Rule : Min gate length = 0.5 U
      LENGTH nmos30_l_edge_ele < 0.5
   }
//--------------------------------------------
// NMOS30T_W2: Minimum CHANNEL width/2 = 5
// NMOS30M_W2: Minimum CHANNEL width/2 = 5
//
// NMOS30M_W : Minimum CHANNEL width/2 = 5 
// NMOS30T_W : Minimum CHANNEL width/2 = 5 
   NMOS30_GATE_WIDTH_W2_ELEM { @ NMOS30M/NMOS30T Element Rule W2 : Min gate width/2 = 5 U
      gate_w2 = COINCIDENT INSIDE EDGE nmos30_lw_ele nmos30_poly_ele
      LENGTH gate_w2  < 5
   }
//--------------------------------------------
//
// get long and short edge of drain
   nmos30_drain_ndiff_long_ele  = EXT nmos30_drain_ndiff_ele nmos30_source_ndiff_ele < 3.0 PARA OPPOSITE REGION
   nmos30_drain_ndiff_ledge_ele = nmos30_drain_ndiff_ele COIN OUTSIDE EDGE nmos30_drain_ndiff_long_ele
   nmos30_drain_ndiff_sedge_ele = nmos30_drain_ndiff_ele NOT COIN OUTSIDE EDGE nmos30_drain_ndiff_long_ele
//
// NMOS30M_X4 : DRAIN-NDIFF to SOURCE-DIFF spacing (field plate) = 2 
// NMOS30T_X4 : DRAIN-NDIFF to SOURCE-DIFF spacing (field plate) = 1.8 
   NMOS30M_SPAC_SDDIFF_X4_ELEM { @ NMOS30M Element Rule X4 : DRAIN-NDIFF to SOURCE-DIFF spacing (field plate) = 2
     good = EXT nmos30_drain_ndiff_ele nmos30_source_ndiff_ele == 2 PARA OPPOSITE REGION
     (nmos30_drain_ndiff_long_ele NOT good) AND nmos30m_hvdef
   }
   NMOS30T_SPAC_SDDIFF_X4_ELEM { @ NMOS30T Element Rule X4 : DRAIN-NDIFF to SOURCE-DIFF spacing (field plate) = 1.8
     good = EXT nmos30_drain_ndiff_ele nmos30_source_ndiff_ele == 1.8 PARA OPPOSITE REGION
     (nmos30_drain_ndiff_long_ele NOT good) AND  nmos30t_hvdef
   }
//
// check long drain edge to poly
// NMOS30M_X1 : POLY1 to DRAIN-NDIFF spacing = 0.4 
// NMOS30T_X1 : POLY1 to DRAIN-NDIFF spacing = 0.35 
   good_nmos30t_x1 = EXT nmos30_drain_ndiff_ledge_ele nmos30_poly_ele == 0.35 PARA OPPOSITE REGION
   good_nmos30m_x1 = EXT nmos30_drain_ndiff_ledge_ele nmos30_poly_ele == 0.4 PARA OPPOSITE REGION
   all_nmos30x1  = EXT nmos30_drain_ndiff_ledge_ele nmos30_poly_ele < 1.5 PARA OPPOSITE REGION
//
   NMOS30T_SPAC_POLY_DDIFF_X1_ELEM { @ NMOS30T Element Rule X1 : POLY1 to DRAIN-NDIFF spacing = 0.35 U fixed
     (all_nmos30x1 NOT good_nmos30t_x1) NOT nmos30m_hvdef
   }
//
   NMOS30M_SPAC_POLY_DDIFF_X1_ELEM { @ NMOS30M Element Rule X1 : POLY1 to DRAIN-NDIFF spacing = 0.4 U fixed
     (all_nmos30x1 NOT good_nmos30m_x1) NOT nmos30t_hvdef
   }
//
// not in doc, but add it
// NTUB TO DRAIN-NDIFF spacing = 0.45
// NTUB TO DRAIN-NDIFF spacing = 0.65
   good_nmos30t_x02 = EXT nmos30_drain_ndiff_ele nmos30_ntub_stripes_ele == 0.65 PARA OPPOSITE SINGULAR REGION
   good_nmos30m_x02 = EXT nmos30_drain_ndiff_ele nmos30_ntub_stripes_ele == 0.45 PARA OPPOSITE SINGULAR REGION
   all_nmos30x02     = EXT nmos30_drain_ndiff_ele nmos30_ntub_stripes_ele < 1.5 OVERLAP PARA OPPOSITE REGION
   NMOS30T_SPAC_NTUB_DDIFF_X2_ELEM { @ NMOS30T Element Rule X2 : NTUB TO DRAIN-NDIFF spacing = 0.65 U fixed
     (all_nmos30x02 NOT good_nmos30t_x02) NOT nmos30m_hvdef
   }
//
   NMOS30M_SPAC_NTUB_DDIFF_X2_ELEM { @ NMOS30M Element Rule X2 : NTUB TO DRAIN-NDIFF spacing = 0.45 U fixed
     (all_nmos30x02 NOT good_nmos30m_x02) NOT nmos30t_hvdef
   }
//
// use double value
// NMOS30M_X2 : NTUB spacing/2 = 0.8 
// NMOS30T_X2 : NTUB spacing/2 = 1 
   good_nmos30t_x2 = EXT nmos30_ntub_stripes_ele == 2 PARA OPPOSITE SINGULAR REGION
   good_nmos30m_x2 = EXT nmos30_ntub_stripes_ele == 1.6 PARA OPPOSITE SINGULAR REGION
   all_nmos30x2    = EXT  nmos30_ntub_stripes_ele < 2.5 PARA OPPOSITE REGION
   NMOS30T_SPAC_NTUB_X2_ELEM { @ NMOS30T Element Rule X2 : NTUB spacing/2 = 1
     (all_nmos30x2 NOT good_nmos30t_x2) NOT nmos30m_hvdef
   }
//
   NMOS30M_SPAC_NTUB_X2_ELEM { @ NMOS30M Element Rule X2 : NTUB spacing/2 = 0.8
     (all_nmos30x2 NOT good_nmos30m_x2) NOT nmos30t_hvdef
   }
//
// NMOS30M_X3 : NTUB width = 1.4 
// NMOS30T_X3 : NTUB width = 1.2 
   NMOS30M_WIDTH_NTUB_X3_ELEM { @ NMOS30M Element Rule X3 : NTUB width = 1.4
     good = INT (nmos30_ntub_stripes_ele AND nmos30m_hvdef) == 1.4 PARA OPPOSITE REGION
     all  = INT (nmos30_ntub_stripes_ele AND nmos30m_hvdef) < 2.5 PARA OPPOSITE REGION
     all NOT good
   }
   NMOS30T_WIDTH_NTUB_X3_ELEM { @ NMOS30T Element Rule X3 : NTUB width = 1.2
     good = INT (nmos30_ntub_stripes_ele AND nmos30t_hvdef) == 1.2 PARA OPPOSITE REGION
     all  = INT (nmos30_ntub_stripes_ele AND nmos30t_hvdef) < 2.5 PARA OPPOSITE REGION
     all NOT good
   }
//
// NMOS30M_X5 : SOURCE-DIFF overlap of FIDEF = 1.5 
// NMOS30T_X5 : SOURCE-DIFF overlap of FIDEF = 1.8 
   NMOS30M_OVLP_SDIFF_FIDEF_X5_ELEM { @ NMOS30M Element Rule X5 : SOURCE-DIFF overlap of FIDEF = 1.5                    
     good = INT nmos30_fimp_device_ele nmos30_source_ndiff_ele == 1.5 OPPOSITE PARA ONLY REGION
     all  = INT nmos30_fimp_device_ele nmos30_source_ndiff_ele < 2.5 OPPOSITE PARA ONLY REGION
     (all NOT good) AND nmos30m_hvdef
   }
   NMOS30T_OVLP_SDIFF_FIDEF_X5_ELEM { @ NMOS30T Element Rule X5 : SOURCE-DIFF overlap of FIDEF = 1.8                      
     good = INT nmos30_fimp_device_ele nmos30_source_ndiff_ele == 1.8 OPPOSITE PARA ONLY REGION
     all  = INT nmos30_fimp_device_ele nmos30_source_ndiff_ele < 2.5 OPPOSITE PARA ONLY REGION
     (all NOT good) AND nmos30t_hvdef
   }
//
// obsolete
//  NMOS30_SPAC_PDIFF_FIDEF_X6Y6_ELEM { @ NMOS30M Element Rule X6 Y6 : subtap to iso fidef spacing  = 1.95
//     good = EXT nmos30_fimp_iso_ele nmos30_subtap_ele == _NMOS30M_X6 OPPOSITE PARA ONLY REGION
//     all  = EXT nmos30_fimp_iso_ele nmos30_subtap_ele < 3.5 OPPOSITE PARA ONLY REGION
//     all NOT good
//   }
//   NMOS30_WIDTH_FIDEF_X7Y7_ELEM { @ NMOS30 Element Rule X7 Y7: iso fidef width 5.0             
//     good = INT nmos30_fimp_iso_ele == _NMOS30M_X7 PARA OPPOSITE REGION
//     all  = INT nmos30_fimp_iso_ele < 7.0 PARA OPPOSITE REGION
//     all NOT good
//   }
//
//---------------------------------------
// check short drain edge to poly
// NMOS30M_Y1 : POLY1 to DRAIN-NDIFF spacing = 1 
// NMOS30T_Y1 : POLY1 to DRAIN-NDIFF spacing = 1 
   NMOS30_SPAC_POLY_DDIFF_Y1_ELEM { @ NMOS30M/T Element Rule Y1 : poly1 to drain diff spacing 1 U fixed
     good = EXT nmos30_drain_ndiff_sedge_ele nmos30_poly_ele == 1 PARA OPPOSITE REGION
     all = EXT nmos30_drain_ndiff_sedge_ele nmos30_poly_ele < 3.0 PARA OPPOSITE REGION
     all NOT good
   }
//
// close gap
   nmos30_ntub_stripesc_ele = SIZE nmos30_ntub_stripes_ele BY 1.0 OVERUNDER
// NMOS30M_Y2 : NTUB extension of DRAIN-NDIFF = 3 
// NMOS30T_Y2 : NTUB extension of DRAIN-NDIFF = 3 
   NMOS30_OVLP_NTUB_DDIFF_Y2_ELEM { @ NMOS30M/T Element Rule Y2 : ntub stripe ovlp of drain diff = 3
     good = ENC nmos30_drain_ndiff_sedge_ele nmos30_ntub_stripesc_ele == 3 OPPOSITE PARA ONLY REGION
     all  = ENC nmos30_drain_ndiff_sedge_ele nmos30_ntub_stripesc_ele <  5.0 OPPOSITE PARA ONLY REGION
     all NOT good
   }
//
// make edge shortet to avoid over 45 poly
// NMOS30M_Y3 : POLY1 width of gate connection = 2 
// NMOS30T_Y3 : POLY1 width of gate connection = 2 
   NMOS30_WIDTH_POLY_GATECONN_Y3_ELEM { @ NMOS30M/NMOS30T Element Rule Y3 : poly width of gate connect = 2
     xx = nmos30_drain_ndiff_sedge_ele EXPAND EDGE INSIDE BY 0.1 EXTEND BY -0.15 
     nmos30_drain_ndiff_sedge_ele_s = xx COIN EDGE nmos30_drain_ndiff_ele
     test  = nmos30_drain_ndiff_sedge_ele_s EXPAND EDGE OUTSIDE BY 5.0
     test1 = INSIDE EDGE test nmos30_poly_ele
     NOT LENGTH test1 == 2
   }
//
// NMOS30M_Y4 : FIDEF extension of NTUB = 2.8 
// NMOS30T_Y4 : FIDEF extension of NTUB = 2.8 
   NMOS30_OVLP_FIDEF_NTUB_Y4_ELEM { @ NMOS30M/NMOS30T Element Rule Y4 : fidef ovlp of ntub = 2.8       
     test  = nmos30_drain_ndiff_sedge_ele EXPAND EDGE OUTSIDE BY 7.0
     test1 = INSIDE EDGE test ( nmos30_fimp_device_ele NOT nmos30_ntub_stripesc_ele)
     NOT LENGTH test1 == 2.8
   }
//
// get edge on head of device
// NMOS30M_Y5 : FIDEF to BULK-PDIFF spacing = 1.2 
// NMOS30T_Y5 : FIDEF to BULK-PDIFF spacing = 1.2 
   NMOS30_SPAC_FIDEF_PDIFF_Y5_ELEM { @ NMOS30M/NMSO30T Element Rule Y5 : fidef to bulk pdiff spacing = 1.2  
     fimp_edge_head = CONVEX EDGE nmos30_fimp_device_ele ANGLE1 == 90 ANGLE2 == 90 
     good1 = EXT fimp_edge_head nmos30_subtap_ele == 1.2 PARA OPPOSITE REGION
     all = EXT fimp_edge_head nmos30_subtap_ele < 2.5 PARA OPPOSITE REGION
     all NOT good1 
   }
// NMOS30M_Y8 : POLY1 45-deg corner = 0.5 
// NMOS30M_Y9 : POLY1 45-deg corner = 1.5 
   NMOS30_POLY_CORN_Y8Y9_ELEM { @ NMOS30M/NMSO30T Element Rule Y8 Y9 : poly must be angled
       VERTEX nmos30_poly_ele != 16
   }
// use path length in case of poly cont edge on 45 degree edg
   nmos30_poly_closed_ele = nmos30_poly_ele OR nmos30_poly_holes_ele
// 1.5 * sqrt(2) = 2.12
// 0.5 * sqrt(2) = 0.707
// POLY1 45-deg corner = 0.5 
// POLY1 45-deg corner = 1.5 
   NMOS30_POLY_ANGLE_Y8Y9_ELEM { @ NMOS30M/NMSO30T Element Rule Y8 Y9 : 45 degree poly must have length 0.7 or 2.12* sqrt(2)
     x = ANGLE nmos30_poly_closed_ele > 44.9 < 45.1
     PATH LENGTH x > 2.17
     PATH LENGTH x < 2.08
     y = ANGLE nmos30_poly_holes_ele > 44.9 < 45.1
     PATH LENGTH y > 0.71
     PATH LENGTH y < 0.68
   }
//
// NMOS30M_Y11 : FIDEF 45-deg corner = 0.75 
// NMOS30T_Y11 : FIDEF 45-deg corner = 0.75 
   NMOS30_FIDEF_CORN_Y11_ELEM { @ NMOS30M/NMSO30T Element Rule Y11 : fidef must be angled
       VERTEX nmos30_fimp_device_ele != 12
   }
//
// NMOS30M_Y11 :  FIDEF 45-deg corner = 0.75 
// NMOS30T_Y11 :  FIDEF 45-deg corner = 0.75 
// 1.06 = 0.75 * sqrt(2)
   NMOS30_FIDEF_ANGLE_Y11_ELEM { @ NMOS30M/NMSO30T Element Rule Y11 : fidef edge length = 0.75 * sqrt(2)
       x = ANGLE nmos30_fimp_device_ele > 44.9 < 45.1
       NOT LENGTH x > 1.0  < 1.1
   }
//
// NMOS30M_Y10 :  FIDEF vertex to SOURCE-DIFF spacing = 1.75 
// NMOS30T_Y10 :  FIDEF vertex to SOURCE-DIFF spacing = 1.75 
   NMOS30_SPAC_FIDEF_SDIFF_Y10_ELEM { @ NMOS30M/NMSO30T Element Rule Y10 : fidef vertex to sdiff spacing = 1.75
     // get fimp edge
     fimp_edge = CONVEX EDGE nmos30_fimp_device_ele ANGLE1 == 225  ANGLE2 == 225
     fimp_edge_exp = EXPAND EDGE fimp_edge INSIDE BY 0.1
     good1 = ENC nmos30_source_ndiff_ele fimp_edge_exp == 1.75 PARA OPPOSITE REGION
     all   = ENC nmos30_source_ndiff_ele fimp_edge_exp < 2.5 PARA OPPOSITE REGION
     all NOT good1 
   }
// 
// check for ntub stripes width 1.4 U
   nmos30_hv_devices_all = COPY nmos30_double_all
   NMOS30_MISS_BAD_NTUB_ELEM { @ INFO NMOS30M/NMOS30T : nmos30 must have 2 ntub stripes with 1.4/1.2 U width
    (nmos30_hv_devices_all NOT DIFF) NOT CUT NTUB == 1
    x = NTUB CUT nmos30_double_all
    x1 = INT x == 1.4 PARA OPPOSITE REGION
    x2 = INT x == 1.2 PARA OPPOSITE REGION
    x NOT (x1 OR x2)
   }
//------------------------------------------------------------------
//
// not in doc, extra check
//   NMOS30_BAD_FIDEF_NOTCLOSED { @ NMOS30 Element Rule : fidef iso must be closed ring 
//     NOT DONUT nmos30_fimp_iso_ele
//   }
//
// not in doc, extra check
//
   NMOS30_MISS_FIDEF_HVDEF { @ NMOS30 Element Rule : fidef iso must be enclosed by HVDEF
                             @                       or missing fidef
     FIDEF NOT INSIDE nmos30_hvdef_all 
     nmos30_hvdef_all NOT ENCLOSE FIDEF
   }
//
// obsolete
// not in doc, extra check
// check for illegal layer on fimp iso
//   NMOS30_FIDEF_ISO_ILL_LAYER  { @ NMOS30 Element Rule : fidef iso covered by illegal layer
//     nmos30_fimp_iso_ele AND DIFF
//     nmos30_fimp_iso_ele AND PPLUS
//     nmos30_fimp_iso_ele AND NPLUS
//     nmos30_fimp_iso_ele AND NTUB 
//     nmos30_fimp_iso_ele AND POLY1
//     nmos30_fimp_iso_ele AND POLY2
//     nmos30_fimp_iso_ele AND HRES 
//     nmos30_fimp_iso_ele AND RESDEF
//     nmos30_fimp_iso_ele AND TUBDEF
//     nmos30_fimp_iso_ele AND ZENER 
//     nmos30_fimp_iso_ele AND DIODE 
//     nmos30_fimp_iso_ele AND MIDOX 
//     nmos30_fimp_iso_ele AND NLDD 
//     nmos30_fimp_iso_ele AND NLDD50
//     // ok after laygen    nmos30_fimp_iso_ele AND FIMP 
//   }
//
//-------------------------------------------------------------------------------
// general rules 
//
// Minimum FIDEF width = 1.7
   WIDTH_FIDEF_W1PW { @ W1PW : Minimum FIDEF width = 1.7
       INT FIDEF < 1.7 ABUT<90 SINGULAR REGION
   }
//
// Minimum FIDEF spacing = 1
   SPAC_FIDEF_S1PWPW {@ S1PWPW : Minimum FIDEF spacing = 1
       EXT FIDEF < 1  ABUT>0<90 SPACE SINGULAR REGION
   }
//
// Minimum FIDEF spacing = 1
   SPAC_FIDEF_NOTCH_S1PWPW {@ S1PWPW : Minimum FIDEF spacing = 1 NOTCH
       EXT FIDEF < 1  ABUT>0<90 NOTCH SINGULAR REGION
   }
//
// check distance to fimp ring
// Minimum FIDEF to NTUB spacing = 6.5
   SPAC_FIDEF_NTUB_S1NWPW {@ S1NWPW : Minimum FIDEF to NTUB spacing = 6.5
       EXT FIDEF NTUB < 6.5 ABUT == 0 OVERLAP SINGULAR REGION
   }
//-------------------------------------------------------------------------------
//
// check for min and spacing, fimp and nldd are generated, check it
// but may be degenerated in any way
//
   nmos30_fimp_ele = FIMP AND nmos30_hvdef_all
   nmos30_nldd_ele = NLDD AND nmos30_hvdef_all
//
//-------------------------------------------------------------------------------
// generated, but no error
// must NOT be drawn on this device
//   NMOS30_ILL_FIMP_ELEM { @ NMOS30 Element Rule : illegal FIMP
//      nmos30m_hvdef_ok AND FIMP
//   }
//
// must NOT be drawn on this device
//   NMOS30_ILL_NLDD_ELEM { @ NMOS30 Element Rule : illegal NLDD
//      nmos30m_hvdef_ok AND NLDD
//   }
//
// error
// must NOT be drawn on this device
   NMOS30_ILL_NLDD50_ELEM { @ NMOS30M/NMOS30T Element Rule : NLDD50 is illegal on this device
      (nmos30m_hvdef_ok OR nmos30t_hvdef_ok) AND NLDD50
   }
//
// check for bad FIMP after generated  on device
//-------------------------------------------------
//
   NMOS30_WIDTH_FIMP_ELEM {@ NMOS30 Element Rule : min width generated FIMP   = 1.7
       INT nmos30_fimp_ele < 1.7 ABUT<90 SINGULAR REGION
   }
//
   NMOS30_SPAC_FIMP_ELEM {@ NMOS30 Element Rule : min FIMP generated spac = 1.0
       EXT nmos30_fimp_ele < 1.0  ABUT>0<90 SPACE SINGULAR REGION
   }
//
   NMOS30_SPAC_FIMP_NOTCH_ELEM {@ NMOS30 Element Rule : min FIMP generated spac notch  = 1.0
       EXT nmos30_fimp_ele < 1.0  ABUT>0<90 NOTCH SINGULAR REGION
   }
//
// check for bad NLDD after generated  on device
//-------------------------------------------------
//
   NMOS30_WIDTH_NLDD_ELEM {@ NMOS30 Element Rule : min width generated NLDD   = 0.6
       INT nmos30_nldd_ele < 0.6 ABUT<90 SINGULAR REGION
   }
//
   NMOS30_SPAC_NLDD_ELEM {@ NMOS30 Element Rule : min generated spac NLDD = 0.6
       EXT nmos30_nldd_ele < 0.6  ABUT>0<90 SPACE SINGULAR REGION
   }
//
   NMOS30_SPAC_NLDD_NOTCH_ELEM {@ NMOS30 Element Rule : min NLDD generated spac notch  = 0.6
       EXT nmos30_nldd_ele < 0.6  ABUT>0<90 NOTCH SINGULAR REGION
   }
//-------------------------------------------------------------------------------
//
///////////////////////////////////////////////////////////////////////
//
//                 end of c35 nmos30 DRC/Element check
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
//                0.35 U CMOS C35 RF Element Layouts
//
//       Document:                    Revision: 
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                 5-May-2004       aob      basic check
///////////////////////////////////////////////////////////////////////
//
// all these check make only sense, if device is recogniced
//
//=====================================================================
//                    NMOSRF/PMOSRF ELEMENT rules
//=====================================================================
// these rules are in RF document

// poly and s/d stripes must beconnected for nmosrf/pmosrf devices
//
//
   NMOSRF_OPEN_GATE { @ NMOSRF element rule : gates must be connected
          x = STAMP nmosrf_device_layer BY routingpoly
          nmosrf_device_layer NOT x
   }
   PMOSRF_OPEN_GATE { @ PMOSRF element rule : gates must be connected
          x = STAMP pmosrf_device_layer BY routingpoly
          pmosrf_device_layer NOT x
   }
//
// check for fixed l = 0.35 U
//
   NMOSRF_FIXED_L_ELEM { @ NMOSRF element rule : fixed length = 0.35
        good = INT nmosrf_trans == 0.35 OPPOSITE PARA ONLY REGION
        all  = INT nmosrf_trans < 10.0 OPPOSITE PARA ONLY REGION
        all NOT good
   }
//
   PMOSRF_FIXED_L_ELEM { @ PMOSRF element rule : fixed length = 0.35
        good = INT pmosrf_trans == 0.35 OPPOSITE PARA ONLY REGION
        all  = INT pmosrf_trans < 10.0 OPPOSITE PARA ONLY REGION
        all NOT good
   }
//
   ngaterf_w = nmosrf_trans COINCIDENT INSIDE EDGE POLY1
   pgaterf_w = pmosrf_trans COINCIDENT INSIDE EDGE POLY1
   NMOSRF_FIXED_W_ELEM { @ NMOSRF element rule : Gate width must be 5.0 U or 10 U 
     x = NOT LENGTH ngaterf_w > 4.95 < 5.05
     NOT LENGTH x > 9.95 < 10.05
   }
//
   PMOSRF_FIXED_W_ELEM { @ PMOSRF element rule : Gate width must be 5.0 U or 10 U 
     x = NOT LENGTH pgaterf_w > 4.95 < 5.05
     NOT LENGTH x > 9.95 < 10.05
   }
//
// nmosrf : check for max w = 200 U
// count number of 5 U or 10 U gates
//
   nmosrf_w_edge_good5 = EXPAND EDGE ( LENGTH ngaterf_w > 4.95 < 5.05) OUTSIDE BY 0.05
   nmosrf_w_edge_good10 = EXPAND EDGE ( LENGTH ngaterf_w > 9.95 < 10.05) OUTSIDE BY 0.05
// wmax nmosrf = 200
// 5 U length max = 40 stripes
   nmosrf_trans5_all = nmosrf_trans INTERACT nmosrf_w_edge_good5
   nmosrf_trans5_bad = nmosrf_device_layer ENCLOSE nmosrf_trans5_all > 40
   NMOSRF_FIXED_WMAX5_ELEM { @ NMOSRF element rule : NMOSRF Element rule stripe width 5 U : max width = 200 U
       COPY nmosrf_trans5_bad
   }
// 10 U length max = 20 stripes
   nmosrf_trans10_all = nmosrf_trans INTERACT nmosrf_w_edge_good10
   nmosrf_trans10_bad = nmosrf_device_layer ENCLOSE nmosrf_trans10_all > 20
   NMOSRF_FIXED_WMAX10_ELEM { @ NMOSRF element rule : NMOSRF Element rule stripe width 10 U : max width = 200 U
       COPY nmosrf_trans10_bad
   }
//
// pmosrf : check for max w = 150 U
// count number of 5 U or 10 U gates
//
   pmosrf_w_edge_good5 = EXPAND EDGE ( LENGTH pgaterf_w > 4.95 < 5.05) OUTSIDE BY 0.05
   pmosrf_w_edge_good10 = EXPAND EDGE ( LENGTH pgaterf_w > 9.95 < 10.05) OUTSIDE BY 0.05
// wmax pmosrf = 150
// 5 U length max = 30 stripes
   pmosrf_trans5_all = pmosrf_trans INTERACT pmosrf_w_edge_good5
   pmosrf_trans5_bad = pmosrf_device_layer ENCLOSE pmosrf_trans5_all > 30
   PMOSRF_FIXED_WMAX5_ELEM { @ PMOSRF element rule : PMOSRF Element rule stripe width 5 U : max width = 150 U
       COPY pmosrf_trans5_bad
   }
// 10 U length max = 15 stripes
   pmosrf_trans10_all = pmosrf_trans INTERACT pmosrf_w_edge_good10
   pmosrf_trans10_bad = pmosrf_device_layer ENCLOSE pmosrf_trans10_all > 15
   PMOSRF_FIXED_WMAX10_ELEM { @ PMOSRF element rule : PMOSRF Element rule stripe width 10 U : max width = 150 U
       COPY pmosrf_trans10_bad
   }
//
///////////////////////////////////////////////////////////////////////
//
//                 end of c35 rf element check
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//                        check generated layers
//
///////////////////////////////////////////////////////////////////////
// 11-Sep-2007 : nmos30 extra handling
//               fidef drawn on device !!!
//               no nldd50 on device generated !!!
// 15-Jul-2007 : add nmos30t
///////////////////////////////////////////////////////////////////////
// nmos30m :
// fimp:
//--------
// add fidef to fimp
// FIMP width 1.7/spacing 1.0       (NTUB NOT (SFC OR HVDEF)) OR FIDEF
//
// nldd:
//------
// add nplus from nmos30m
// NLDD width 0.6/spacing 0.6       ((NPLUS NOT MIDOX) NOT (SFC OR HVDEF)) OR (NPLUS INSIDE nmos30m_hvdef_ok) 
//
// nldd50:
//--------
// NLDD50 width 0.6/ spacing 0.6    (NPLUS AND MIDOX) NOT (SFC OR HVDEF)
///////////////////////////////////////////////////////////////////////
//
   GROUP GENLAY MISSING_?
// end group
//
// fimp layer
//
// generate in nmos30m and nmos30t
    MISSING_FIMP { @ Generated Layers: missing FIMP layer
       generated_fimp_out_nmos30  = NTUB NOT (SFCDEF OR HVDEF)
       generated_fimp_in_nmos30  = COPY FIDEF
       generated_fimp = generated_fimp_out_nmos30 OR generated_fimp_in_nmos30 
       generated_fimp XOR FIMP
    }
//
// nldd
// ATTENTION : select nmos30m/nmos30t and add nplus
// generate in nmos30m and nmos30t  with valid text in HVDEF
// no version !!!!
//
   MISSING_NLDD { @ Generated Layers: missing NLDD layer 
       generated_nldd_out_nmos30 = (NPLUS NOT MIDOX) NOT (SFCDEF OR HVDEF) 
       generated_nldd_in_nmos30 =   NPLUS INSIDE (nmos30m_hvdef OR nmos30t_hvdef)
       generated_nldd = generated_nldd_out_nmos30 OR generated_nldd_in_nmos30
       NLDD XOR generated_nldd           
   }
//
// nldd50
//
#IFDEF layer_midox
// do NOT generate inside nmos30m/nmos30t
   MISSING_NLDD50 { @ Generated Layers: missing NLDD50 layer 
       generated_nldd50_out_nmos30m = (NPLUS AND MIDOX ) NOT (SFCDEF OR HVDEF)
       NLDD50 XOR generated_nldd50_out_nmos30m 
   }
#ENDIF
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
//       Rules Document:  ENG-326                    Revision: 1.0
//       Elements Document:  ENG-234                 Revision: 5.0
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                  8-Feb-2007      aob     first version for c35
//                 13-Feb-2007      aob     use met2 spacing 0.6
///////////////////////////////////////////////////////////////////////
//
//                 KEPOUT and IPDEF checks
//
///////////////////////////////////////////////////////////////////////
//
   kepout_or_sfcdef = KEPOUT OR SFCDEF
//   
//   NTUB 5
//   
// NTUB overlapping KEPOUT is not allowed
   ILL_NTUB_OVER_KEPOUT_NWR001 { @ KEPOUT definition : (NTUB AND KEPOUT) is not allowed 
          NTUB AND KEPOUT
   }
// Minimum NTUB spacing to KEPOUT or SFCDEF = 3
   SPAC_NTUB_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing NTUB to (KEPOUT or SFCDEF) = 3
        EXT  NTUB kepout_or_sfcdef < 3 ABUT == 0 REGION
   }
//   
//   DIFF 10
//   
// DIFF overlapping KEPOUT is not allowed
   ILL_DIFF_OVER_KEPOUT_AAR001 { @ KEPOUT definition : (DIFF AND KEPOUT) is not allowed 
          DIFF AND KEPOUT
   }
// Minimum DIFF spacing to KEPOUT or SFCDEF = 0.6
   SPAC_DIFF_KEPOUT_S1AAKO { @ KEPOUT definition : Minimum spacing DIFF to (KEPOUT or SFCDEF) = 0.6
        EXT  DIFF kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   MIDOX 14
//   
// MIDOX overlapping KEPOUT is not allowed
   ILL_MIDOX_OVER_KEPOUT_XMR002 { @ KEPOUT definition : (MIDOX AND KEPOUT) is not allowed 
          MIDOX AND KEPOUT
   }
// Minimum MIDOX spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MIDOX_KEPOUT_S1KOXM { @ KEPOUT definition : Minimum spacing MIDOX to (KEPOUT or SFCDEF) = 0.6
        EXT  MIDOX kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   POLY1 20
//   
// POLY1 overlapping KEPOUT is not allowed
   ILL_POLY1_OVER_KEPOUT_P1R002 { @ KEPOUT definition : (POLY1 AND KEPOUT) is not allowed 
          POLY1 AND KEPOUT
   }
// Minimum POLY1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_POLY1_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing POLY1 to (KEPOUT or SFCDEF) = S1KOP1
        EXT  POLY1 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   NPLUS 23
//   
// NPLUS overlapping KEPOUT is not allowed
   ILL_NPLUS_OVER_KEPOUT_NSR001 { @ KEPOUT definition : (NPLUS AND KEPOUT) is not allowed 
          NPLUS AND KEPOUT
   }
// Minimum NPLUS spacing to KEPOUT or SFCDEF = 0.6
   SPAC_NPLUS_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing NPLUS to (KEPOUT or SFCDEF) = S1KONS
        EXT  NPLUS kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   PPLUS 24
//   
// PPLUS overlapping KEPOUT is not allowed
   ILL_PPLUS_OVER_KEPOUT_PSR001 { @ KEPOUT definition : (PPLUS AND KEPOUT) is not allowed 
          PPLUS AND KEPOUT
   }
// Minimum PPLUS spacing to KEPOUT or SFCDEF = 0.6
   SPAC_PPLUS_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing PPLUS to (KEPOUT or SFCDEF) = 0.6
        EXT  PPLUS kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   HRES 29
//   
// HRES overlapping KEPOUT is not allowed
   ILL_HRES_OVER_KEPOUT_HRR004 { @ KEPOUT definition : (HRES AND KEPOUT) is not allowed 
          HRES AND KEPOUT
   }
// Minimum HRES spacing to KEPOUT or SFCDEF = 0.6
   SPAC_HRES_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing HRES to (KEPOUT or SFCDEF) = 0.6
        EXT  HRES kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   POLY2 30
//   
// POLY2 overlapping KEPOUT is not allowed
   ILL_POLY2_OVER_KEPOUT_P2R002 { @ KEPOUT definition : (POLY2 AND KEPOUT) is not allowed 
          POLY2 AND KEPOUT
   }
// Minimum POLY2 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_POLY2_KEPOUT_S1KOP2 { @ KEPOUT definition : Minimum spacing POLY2 to (KEPOUT or SFCDEF) = 0.6
        EXT  POLY2 kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   CONT 34
//   
// CONT overlapping KEPOUT is not allowed
   ILL_CONT_OVER_KEPOUT_COR002 { @ KEPOUT definition : (CONT AND KEPOUT) is not allowed 
          CONT AND KEPOUT
   }
// Minimum CONT spacing to KEPOUT or SFCDEF = 0.4
   SPAC_CONT_KEPOUT_S1COKO { @ KEPOUT definition : Minimum spacing CONT to (KEPOUT or SFCDEF) = 0.4
        EXT  CONT kepout_or_sfcdef < 0.4 ABUT == 0 REGION
   }
//   
//   MET1 35
//   
// MET1 overlapping KEPOUT is not allowed
   ILL_MET1_OVER_KEPOUT_M1R002 { @ KEPOUT definition : (MET1 AND KEPOUT) is not allowed 
          MET1 AND KEPOUT
   }
// Minimum MET1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_MET1_KEPOUT_S1KOM1 { @ KEPOUT definition : Minimum spacing MET1 to (KEPOUT or SFCDEF) = 0.45
        EXT  MET1 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   VIA 36
//   
// VIA1 overlapping KEPOUT is not allowed
   ILL_VIA_OVER_KEPOUT_V1R002 { @ KEPOUT definition : (VIA AND KEPOUT) is not allowed 
          VIA AND KEPOUT
   }
// Minimum VIA1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA_KEPOUT_S1KOV1 { @ KEPOUT definition : Minimum spacing VIA to (KEPOUT or SFCDEF) = S1KOV1
        EXT  VIA kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET2 37
//   
// MET2 overlapping KEPOUT is not allowed
   ILL_MET2_OVER_KEPOUT_M2R002 { @ KEPOUT definition : (MET2 AND KEPOUT) is not allowed 
          MET2 AND KEPOUT
   }
// Minimum MET2 spacing to KEPOUT or SFCDEF = 0.6 
   SPAC_MET2_KEPOUT_S1KOXX { @ KEPOUT definition : Minimum spacing MET2 to (KEPOUT or SFCDEF) = 0.5   
        //EXT  MET2 kepout_or_sfcdef < 0.6 ABUT == 0 REGION
        EXT  MET2 kepout_or_sfcdef < 0.5 ABUT == 0 REGION
   }
//   
//   VIA2 38
//   
// VIA2 overlapping KEPOUT is not allowed
   ILL_VIA2_OVER_KEPOUT_V2R002 { @ KEPOUT definition : (VIA2 AND KEPOUT) is not allowed 
          VIA2 AND KEPOUT
   }
// Minimum VIA2 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA2_KEPOUT_S1KOV2 { @ KEPOUT definition : Minimum spacing VIA2 to (KEPOUT or SFCDEF) = 0.45
        EXT  VIA2 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET3 39
//   
// MET3 overlapping KEPOUT is not allowed
   ILL_MET3_OVER_KEPOUT_M3R002 { @ KEPOUT definition : (MET3 AND KEPOUT) is not allowed 
          MET3 AND KEPOUT
   }
// Minimum MET3 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MET3_KEPOUT_S1KOM3 { @ KEPOUT definition : Minimum spacing MET3 to (KEPOUT or SFCDEF) = 0.6
        EXT  MET3 kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   PAD 40
//   
// PAD overlapping KEPOUT is not allowed
   ILL_PAD_OVER_KEPOUT_PAR002 { @ KEPOUT definition : (PAD AND KEPOUT) is not allowed 
          PAD AND KEPOUT
   }
// Minimum PAD spacing to KEPOUT or SFCDEF = 9
   SPAC_PAD_KEPOUT_S1KOPA { @ KEPOUT definition : Minimum spacing PAD to (KEPOUT or SFCDEF) = 9
        EXT  PAD kepout_or_sfcdef < 9 ABUT == 0 REGION
   }
//   
//   VIA3 41
//   
// VIA3 overlapping KEPOUT is not allowed
   ILL_VIA3_OVER_KEPOUT_V3R002 { @ KEPOUT definition : (VIA3 AND KEPOUT) is not allowed 
          VIA3 AND KEPOUT
   }
// Minimum VIA3 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA3_KEPOUT_S1KOV3 { @ KEPOUT definition : Minimum spacing VIA3 to (KEPOUT or SFCDEF) = 0.45
        EXT  VIA3 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET4 42
//   
// MET4 overlapping KEPOUT is not allowed
   ILL_MET4_OVER_KEPOUT_M4R002 { @ KEPOUT definition : (MET4 AND KEPOUT) is not allowed 
          MET4 AND KEPOUT
   }
// Minimum MET4 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MET4_KEPOUT_S1KOM4 { @ KEPOUT definition : Minimum spacing MET4 to (KEPOUT or SFCDEF) = 0.6
        EXT  MET4 kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//
//   MET4CAP 
//   
// METCAP overlapping KEPOUT is not allowed
   ILL_METCAP_OVER_KEPOUT_MCR002 { @ KEPOUT definition : (METCAP AND KEPOUT) is not allowed 
          METCAP AND KEPOUT
   }
// Minimum METCAP spacing to KEPOUT or SFCDEF = 0.8
   SPAC_METCAP_KEPOUT_S1MCKO { @ KEPOUT definition : Minimum spacing METCAP to (KEPOUT or SFCDEF) = 0.8
        EXT METCAP kepout_or_sfcdef < 0.8 ABUT == 0 REGION
   }
//   
///////////////////////////////////////////////////////////////////////
//
//                 end of KEPOUT and IPDEF checks
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////
// Owner: Austria Mikro Systeme   //
// HIT-Kit: Digital               //
////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
//       _rules_title (Trace Section)
//
//       Document: ENG-326                      Revision: 1.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                 7-Feb-2002        aob      rpolyh activated
//                12-Feb-2002        aob      nrd/nrs new m4 fixed
//                                            cvar added
//                10-Apr-2002        aob      spirals added
//                25-Apr-2002        aob      vert15 removed
//                13-Jun-2002        aob      cvar changed
//                17-Jun-2002        aob      cvar model changed to mos
//                20-Aug-2002        aob      ad/as corrected for bends
//                27-Sep-2002        aob      spirals added
//                13-Jan-2003        aob      nmos4/pmos4 : aux layer diff
//                                            changed to ndiff_1/pdiff_1
//                                            due to lvsh problems
//                16-Jun-2003        aob      hall added
//                12-May-2003        aob      rf devices added, rf pads added,
//                                            cvar rows,cols chaged
//                13-May-2004        aob      rf pads not supported yet
//                                            device disabled
//                22-Jul-2004        aob      unsupported cvar( single gate added)
//                17-Aug-2004        aob      module switches added
//                                            add dummy devices to avoid any problems
//                                            with missing properties
//                                            and output as drc error
//                15-Jun-2005        aob      rpolyhrf added
//                20-Jul-2005        aob      pexswitch added
//                                            add devices for pex switch
//                 9-Aug-2005        aob      changes for nmos4/pmos4
//                                            due to stacked shorted device problem      
//                 6-Sep-2005        aob      cpolyrf property modified
//                16-Mar-2006        aob      rpoly1 added
//                30-May-2006        aob      cmim added
//                 8-Feb-2007        aob      add met resistors
//                14-Feb-2007        aob      add photo diode
//                27-Apr-2007        aob      pmosrf/nmosrf : as/ad divide by ng
//                 3-Aug-2007        aob      add photo diode process option
//                17-Aug-2007        aob      nmos30m/nmos30t added
///////////////////////////////////////////////////////////////////////
//
//   Device Recognition is done for the following devices
//---------------------------------------------------------------------
//
//   - short(metres), rpoly1, rpoly2, rpoly2rf, rpolyh, rpolyhrf, rdiffn, rdiffp, rnwell
//   - pnpvert10, pnplat2
//   - nmosh, nmos4, pmos4, nmosm4, pmosm4
//   - cpoly, cpolyrf, cvar
//   - nd, pd, nwd, zdiode, photo( phdnwa850)
//   - nmos30m/nmos30t
//   - nmosrf, pmosrf, rfpad( disabled), probe pad
//   - spirals
//   - hall
//   - cmim
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                       DEVICE-RECOGNITION                          //                         
///////////////////////////////////////////////////////////////////////


// create dummy empty layer to generate dymmy device

   LAYER DUMMY2 997
   POLYGON -1.0 -1.0 1.0 1.0 DUMMY2
   dummy_device = SIZE DUMMY2 BY -5.0

//=====================================================================
// RESISTORS - rshort, rpoly1, rpoly2, rpoly2rf, rpolyh, rdiffn, rdiffp, rnwell
//=====================================================================
// no trace prop
//
   DEVICE rx(short) rmet1_device routingmet1(POS) routingmet1(NEG)
   DEVICE rx(short) rmet2_device routingmet2(POS) routingmet2(NEG)
   DEVICE rx(short) rmet3_device routingmet3(POS) routingmet3(NEG)
#IFDEF fourmetal
   DEVICE rx(short) rmet4_device routingmet4(POS) routingmet4(NEG)
#ENDIF
//
// RPOLY1 - 45 degree corners

DEVICE r(rpoly1) pres1 RESTRM(POS) RESTRM(NEG) <pres145>
[
   property L,W
   W = perimeter_coincide_outside(pres1,RESTRM) / 2
   res_l = perimeter(pres1) / 2 - W
   L = res_l - W * bends(pres1) * 0.168  // 45 degree corners !!!
]

// RPOLY - 90 degree corners or no corners

DEVICE r(rpoly1) pres1 RESTRM(POS) RESTRM(NEG)
[
   property L,W
   W = perimeter_coincide_outside(pres1,RESTRM) / 2
   res_l = perimeter(pres1) / 2 - W
   L = res_l - W * bends(pres1) * 0.5    // 90 degree corners !!!
]

#IFDEF layer_poly2

// RPOLY2

// RPOLY2 - 45 degree corners

DEVICE r(rpoly2) pres_norf RESTRM(POS) RESTRM(NEG) <pres45>
[  
   property L,W
   W = perimeter_coincide_outside(pres_norf,RESTRM) / 2
   res_l = perimeter(pres_norf) / 2 - W
   L = res_l - W * bends(pres_norf) * 0.168  // 45 degree corners !!!
]

// RPOLY - 90 degree corners or no corners

DEVICE r(rpoly2) pres_norf RESTRM(POS) RESTRM(NEG)
[  
   property L,W
   W = perimeter_coincide_outside(pres_norf,RESTRM) / 2
   res_l = perimeter(pres_norf) / 2 - W
   L = res_l - W * bends(pres_norf) * 0.5    // 90 degree corners !!!
]
#ELSE
  ILL_RPOLY2_UNAVAILABLE { @ Process Modules : RPOLY2 device not available
         COPY pres_norf
  }
  pres_norf_dummy = pres_norf AND dummy_device
DEVICE r(rpoly2) pres_norf_dummy RESTRM(POS) RESTRM(NEG)
[  
   property L,W
   W = perimeter_coincide_outside(pres_norf_dummy,RESTRM) / 2
   res_l = perimeter(pres_norf_dummy) / 2 - W
   L = res_l - W * bends(pres_norf_dummy) * 0.5    // 90 degree corners !!!
]
#ENDIF

// RPOLY2RF - 45 degree corners
//
// device layer is not res body !!
//
   presrf  = pres INSIDE pres_rf_device

#IFDEF layer_poly2
DEVICE r(rpoly2rf) pres_rf_device RESTRM(POS) RESTRM(NEG) routingnwell(SUB) <pres45> <presrf>
[
   property L,W
   W = perimeter_coincide_outside(presrf,RESTRM) / 2
   res_l = perimeter(presrf) / 2 - W
   x = bends(presrf)
   L = res_l - W * x * 0.168  // 45 degree corners !!!
   // property L,W,bends
   // bends = x/2
]

// RPOLY - 90 degree corners or no corners

DEVICE r(rpoly2rf) pres_rf_device RESTRM(POS) RESTRM(NEG) routingnwell(SUB) <presrf>
[
   property L,W
   W = perimeter_coincide_outside(presrf,RESTRM) / 2
   res_l = perimeter(presrf) / 2 - W
   x = bends(presrf)
   L = res_l - W * x * 0.5    // 90 degree corners !!!
   //property L,W,bends
   //bends = x/2
]
#ELSE
  ILL_RPOLY2RF_UNAVAILABLE { @ Process Modules : RPOLY2RF device not available
         COPY pres_rf_device
  }
  pres_rf_device_dummy = pres_rf_device AND dummy_device
DEVICE r(rpoly2rf) pres_rf_device_dummy RESTRM(POS) RESTRM(NEG)
[  
   property L,W
   W = perimeter_coincide_outside(pres_rf_device_dummy,RESTRM) / 2
   res_l = perimeter(pres_rf_device_dummy) / 2 - W
   L = res_l - W * bends(pres_rf_device_dummy) * 0.5    // 90 degree corners !!!
]
#ENDIF

// RPOLYH

// RPOLYH - 45 degree corners

#IFDEF layer_hres
DEVICE r(rpolyh) presh_norf preshterm(POS) preshterm(NEG) <presh45>
[  
    property L,W
    W = perimeter_coincide_outside(presh_norf,preshterm) / 2
    res_l = perimeter(presh_norf) / 2 - W
    L = res_l - W * bends(presh_norf) * 0.168  // 45 degree corners !!!
]

// RPOLYH - 90 degree corners or no corners

DEVICE r(rpolyh) presh_norf preshterm(POS) preshterm(NEG)
[  
    property L,W
    W = perimeter_coincide_outside(presh_norf,preshterm) / 2
    res_l = perimeter(presh_norf) / 2 - W
    L = res_l - W * bends(presh_norf) * 0.5    // 90 degree corners !!!
]
#ELSE
  ILL_RPOLYH_UNAVAILABLE { @ Process Modules : RPOLYH device not available
         COPY presh_norf
  }
  presh_norf_dummy = presh_norf AND dummy_device
DEVICE r(rpolyh) presh_norf_dummy preshterm(POS) preshterm(NEG)
[  
    property L,W
    W = perimeter_coincide_outside(presh_norf_dummy,preshterm) / 2
    res_l = perimeter(presh_norf_dummy) / 2 - W
    L = res_l - W * bends(presh_norf_dummy) * 0.5    // 90 degree corners !!!
]

#ENDIF

#IFDEF layer_hres
//
// device layer is not res body !!
//
   preshrf  = presh INSIDE presh_rf_device
//
DEVICE r(rpolyhrf) presh_rf_device  preshterm(POS) preshterm(NEG) routingnwell(SUB) <presh45> <preshrf>
[
    property L,W
    W = perimeter_coincide_outside(preshrf    ,preshterm) / 2
    res_l = perimeter(preshrf    ) / 2 - W
    L = res_l - W * bends(preshrf) * 0.168  // 45 degree corners !!!
]

// RPOLYH - 90 degree corners or rf_deviceno corners

DEVICE r(rpolyhrf) presh_rf_device preshterm(POS) preshterm(NEG)  routingnwell(SUB) <preshrf>
[
    property L,W
    W = perimeter_coincide_outside(preshrf ,preshterm) / 2
    res_l = perimeter(preshrf ) / 2 - W
    L = res_l - W * bends(preshrf ) * 0.5    // 90 degree corners !!!
]
#ELSE
  ILL_RPOLYHRF_UNAVAILABLE { @ Process Modules : RPOLYHRF device not available
         COPY presh_rf_device
  }
  presh_rf_device_dummy = presh_rf_device AND dummy_device
DEVICE r(rpolyhrf) presh_rf_device_dummy preshterm(POS) preshterm(NEG) routingnwell(SUB)
[
    property L,W
    W = perimeter_coincide_outside(presh_rf_device_dummy,preshterm) / 2
    res_l = perimeter(presh_rf_device_dummy) / 2 - W
    L = res_l - W * bends(presh_rf_device_dummy) * 0.5    // 90 degree corners !!!
]
#ENDIF

// RDIFFN

// RDIFFN - 45 degree corners

DEVICE r(rdiffn) ndres RESTRM(POS) RESTRM(NEG) <ndres45>
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.168  // 45 degree corners !!!
]

// RDIFFN - 90 degree corners or no corners

DEVICE r(rdiffn) ndres RESTRM(POS) RESTRM(NEG)
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.5    // 90 degree corners !!!
]


// RDIFFN3

// RDIFFN3 - 45 degree corners

DEVICE r(rdiffn3) ndres RESTRM(POS) RESTRM(NEG) substrate(SUB) 
                  <ndres45>
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.168  // 45 degree corners !!!
]

// RDIFFN3 - 90 degree corners or no corners

DEVICE r(rdiffn3) ndres RESTRM(POS) RESTRM(NEG) substrate(SUB)
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.5    // 90 degree corners !!!
]


// RDIFFP

// RDIFFP - 45 degree corners

DEVICE r(rdiffp) pdres RESTRM(POS) RESTRM(NEG) <pdres45>
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.168  // 45 degree corners !!!
]

// RDIFFP - 90 degree corners or no corners

DEVICE r(rdiffp) pdres RESTRM(POS) RESTRM(NEG)
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.5    // 90 degree corners !!!
]


// RDIFFP3

// RDIFFP3 - 45 degree corners

DEVICE r(rdiffp3) pdres RESTRM(POS) RESTRM(NEG) routingnwell(SUB)
                  <pdres45>
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.168  // 45 degree corners !!!
]

// RDIFFP3 - 90 degree corners or no corners

DEVICE r(rdiffp3) pdres RESTRM(POS) RESTRM(NEG) routingnwell(SUB)
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.5    // 90 degree corners !!!
]


// RNWELL

// RNWELL - 45 degree corners

DEVICE r(rnwell) nwres RESTRM(POS) RESTRM(NEG) substrate(SUB)
                 <nwres45>
[
   property L,W
   W = perimeter_coincide_outside(nwres,RESTRM) / 2
   res_l = perimeter(nwres) / 2 - W
   L = res_l - W * bends(nwres) * 0.168  // 45 degree corners !!!
]

// RNWELL - 90 degree corners or no corners

DEVICE r(rnwell) nwres RESTRM(POS) RESTRM(NEG) substrate(SUB)
[
   property L,W
   W = perimeter_coincide_outside(nwres,RESTRM) / 2
   res_l = perimeter(nwres) / 2 - W
   L = res_l - W * bends(nwres) * 0.5    // 90 degree corners !!!
]


//=====================================================================
// BIPOLAR TRANSISTORS - pnpvert, pnplat
//=====================================================================

// PNPVERT vert10

DEVICE Q(pnpvert10) pnpvert10 substrate(C) ndiff(B) pnpvert10_e(E)
[
   property A
   // IC_Station : A = 1
   A = 1e-12
]

// PNP_LAT2

// IC_Station : DEVICE Q(pnplat2) pnplat2_g pnplat2_c(C) routingnwell(B) pnplat2_e(E) 
DEVICE Q(pnplat) pnplat2_g pnplat2_c(C) routingnwell(B) pnplat2_e(E) 
                 substrate(S) routingpoly(G)
[
   property A
   // IC_Station : A = 1
   A = 1e-12
]


//=====================================================================
//  MOS TRANSISTORS - nmosh
//=====================================================================
//
//
#IFDEF layer_midox

// NMOSMH

DEVICE lddn(nmosmh) nmosmh nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS 
   bend_effect = 0.5
   W = (perimeter_coincide(nmosmh,ndiff))
   a = area(nmosmh)
   L = a/W
   if (bends(nmosmh) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosmh) * L
     else
       L = L - bend_effect * bends(nmosmh) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosmh)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]

#ELSE

  nmosmh_dummy = nmosmh AND dummy_device
  ILL_NMOSMH_UNAVAILABLE { @ Process Modules : NMOSMH device not available
         COPY nmosmh
  }

DEVICE lddn(nmosmh) nmosmh_dummy nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W
   W = (perimeter_coincide(nmosmh_dummy,ndiff))
   a = area(nmosmh_dummy)
   L = a/W
]
#ENDIF


// NMOSH

DEVICE lddn(nmosh) nmosh_nomidox nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS 
   bend_effect = 0.5
   W = (perimeter_coincide(nmosh_nomidox,ndiff))
   a = area(nmosh_nomidox)
   L = a/W
   if (bends(nmosh_nomidox) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosh_nomidox) * L
     else
       L = L - bend_effect * bends(nmosh_nomidox) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosh_nomidox)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]
//
///////////////////////////////////////////////////////////////////////
//
// select shorted devices by drc to avoid negative ps/pd 
// use by shape for shorted devices
//
///////////////////////////////////////////////////////////////////////
//
//=====================================================================
//  MOS TRANSISTORS - nmos4, pmos4, nmosm4, pmosm4
//=====================================================================
//
// change model name to find shorted devcies in SPICE netlist
//
#UNDEFINE SHORT_DEVICE_DEBUG
//
   nmos_short   = nmos TOUCH ndiff == 1 BY NET
   nmos_noshort = nmos NOT nmos_short
//
   nmos_midox_short   = nmos_midox TOUCH ndiff == 1 BY NET
   nmos_midox_noshort = nmos_midox NOT nmos_midox_short
//
   pmos_short   = pmos TOUCH pdiff == 1 BY NET
   pmos_noshort = pmos NOT pmos_short
//
   pmos_midox_short   = pmos_midox TOUCH pdiff == 1 BY NET
   pmos_midox_noshort = pmos_midox NOT pmos_midox_short
//
#IFDEF DEVSWITCH
   xnmos_short   { COPY nmos_short }                                      
   //nmos_noshort { COPY nmos_noshort }                                      
   xnmosm_short   { COPY nmos_midox_short }                                      
   //nmos_midox_noshort { COPY nmos_midox_noshort }                                      
   xpmos_short   { COPY pmos_short }                                      
   //pmos_noshort { COPY pmos_noshort }                                      
   xpmosm_short   { COPY pmos_midox_short }                                      
   //pmos_midox_noshort { COPY pmos_midox_noshort }                                      
#ENDIF
//
//  N-MOS
//
// attention : for ad/as/pd/ps do not use corrected w
//
DEVICE mn(nmos4) nmos_noshort routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_noshort,ndiff)
        + perimeter_inside(nmos_noshort,ndiff)) / 2
   L = perimeter_outside(nmos_noshort,ndiff) / 2
   W_orig = W
   if (bends(nmos_noshort) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_noshort) * L
     else
       L = L - bend_effect * bends(nmos_noshort) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
     AS = area(S) * W_orig / pis
     AD = area(D) * W_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_noshort)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_noshort)
//   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
#IFDEF    SHORT_DEVICE_DEBUG
DEVICE mn(nmos4_short) nmos_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ELSE
DEVICE mn(nmos4) nmos_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_short,ndiff)
        + perimeter_inside(nmos_short,ndiff)) / 2
   L = perimeter_outside(nmos_short,ndiff) / 2
   W_orig = W
   if (bends(nmos_short) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_short) * L
     else
       L = L - bend_effect * bends(nmos_short) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
     AS = area(S) * W_orig / pis
     AD = area(D) * W_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_short)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_short)
//   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
// weiter

#IFDEF layer_midox

DEVICE mn(nmosm4) nmos_midox_noshort routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_midox_noshort,ndiff)
        + perimeter_inside(nmos_midox_noshort,ndiff)) / 2
   L = perimeter_outside(nmos_midox_noshort,ndiff) / 2
   W_orig = W
   if (bends(nmos_midox_noshort) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_midox_noshort) * L
     else
       L = L - bend_effect * bends(nmos_midox_noshort) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
    AS = area(S) * W_orig / pis
    AD = area(D) * W_orig / pid
    PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_midox_noshort)
    PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_midox_noshort)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
#IFDEF SHORT_DEVICE_DEBUG
DEVICE mn(nmosm4_short) nmos_midox_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ELSE
DEVICE mn(nmosm4) nmos_midox_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_midox_short,ndiff)
        + perimeter_inside(nmos_midox_short,ndiff)) / 2
   L = perimeter_outside(nmos_midox_short,ndiff) / 2
   W_orig = W
   if (bends(nmos_midox_short) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_midox_short) * L
     else
       L = L - bend_effect * bends(nmos_midox_short) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
    AS = area(S) * W_orig / pis
    AD = area(D) * W_orig / pid
    PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_midox_short)
    PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_midox_short)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]

#ELSE

 nmos_midox_dummy = nmos_midox AND dummy_device

  ILL_NMOSM4_UNAVAILABLE { @ Process Modules : NMOSM4 device not available
         COPY nmos_midox
  }

DEVICE mn(nmosm4) nmos_midox_dummy routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_midox_dummy,ndiff)
        + perimeter_inside(nmos_midox_dummy,ndiff)) / 2
   L = perimeter_outside(nmos_midox_dummy,ndiff) / 2
]
#ENDIF

//  P-MOS

DEVICE mp(pmos4) pmos_noshort routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_noshort,pdiff)
        + perimeter_inside(pmos_noshort,pdiff)) / 2
   L = perimeter_outside(pmos_noshort,pdiff) / 2
   W_orig = W
   if (bends(pmos_noshort) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_noshort) * L
     else
       L = L - bend_effect * bends(pmos_noshort) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_noshort)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_noshort)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
#IFDEF SHORT_DEVICE_DEBUG
DEVICE mp(pmos4_short) pmos_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ELSE
DEVICE mp(pmos4) pmos_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_short,pdiff)
        + perimeter_inside(pmos_short,pdiff)) / 2
   L = perimeter_outside(pmos_short,pdiff) / 2
   W_orig = W
   if (bends(pmos_short) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_short) * L
     else
       L = L - bend_effect * bends(pmos_short) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_short)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_short)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]

#IFDEF layer_midox

DEVICE mp(pmosm4) pmos_midox_noshort routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_midox_noshort,pdiff)
        + perimeter_inside(pmos_midox_noshort,pdiff)) / 2
   L = perimeter_outside(pmos_midox_noshort,pdiff) / 2
   W_orig = W
   if (bends(pmos_midox_noshort) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_midox_noshort) * L
     else
       L = L - bend_effect * bends(pmos_midox_noshort) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_midox_noshort)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_midox_noshort)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
//
#IFDEF SHORT_DEVICE_DEBUG
DEVICE mp(pmosm4_short) pmos_midox_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ELSE
DEVICE mp(pmosm4) pmos_midox_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_midox_short,pdiff)
        + perimeter_inside(pmos_midox_short,pdiff)) / 2
   L = perimeter_outside(pmos_midox_short,pdiff) / 2
   W_orig = W
   if (bends(pmos_midox_short) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_midox_short) * L
     else
       L = L - bend_effect * bends(pmos_midox_short) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_midox_short)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_midox_short)
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]
//
//
#ELSE

  pmos_midox_dummy = pmos_midox AND dummy_device
  ILL_PMOSM4_UNAVAILABLE { @ Process Modules : PMOSM4 device not available
         COPY pmos_midox
  }

DEVICE mn(pmosm4) pmos_midox_dummy routingpoly(G) pdiff(S) pdiff(D) substrate(B) <pdiff_1>
[
   property W,L
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_midox_dummy,pdiff)
        + perimeter_inside(pmos_midox_dummy,pdiff)) / 2
   L = perimeter_outside(pmos_midox_dummy,pdiff) / 2
]
#ENDIF
///////////////////////////////////////////////////////////////////////


//=====================================================================
// CAPACITANCES - cpolya, cpolyrf, cvar
//=====================================================================

// CPOLYA
// ATTENTION : pos/neg is NOT standard for cpolya !!!!!
//             This is on purpose !!!

#IFDEF layer_poly2
DEVICE c(cpolya) cpoly_norf routingpoly(POS) routingpoly2(NEG)
[
   property A,P
   //A = area(cpoly_norf) * 1e+12
   A = area(cpoly_norf)
   //P = perimeter(cpoly_norf) * 1e+6
   P = perimeter(cpoly_norf)
]
#ELSE
  ILL_CPOLYA_UNAVAILABLE { @ Process Modules : CPOLYA device not available
         COPY cpoly_norf
  }
  cpoly_norf_dummy = cpoly_norf AND dummy_device
DEVICE c(cpolya) cpoly_norf_dummy routingpoly(POS) routingpoly2(NEG)
[
   property A,P
   A = area(cpoly_norf_dummy) * 1e+12
   P = perimeter(cpoly_norf_dummy) * 1e+6
]
#ENDIF


// CPOLYRF

cpolyrf_capbody = cpoly INSIDE cpoly_rf_device

#IFDEF layer_poly2

#IFDEF PEXSWITCH
//
// check for neg sqrt ..rounding errors linux
DEVICE c(cpolyrf) cpoly_rf_device routingpoly2_rblock(POS) routingpoly_rblock(NEG) routingnwell(SUB) <cpolyrf_capbody>
[
   property W,L,A,P
   A1 = area(cpolyrf_capbody)
   P1 = perimeter(cpolyrf_capbody)
   A = A1 * 1e+12
   P = P1 * 1e+6
   x1 = P1 * P1 - 16.0 * A1
   if( x1 < 0 ) x1 = 0
   L = (1/4) * ( P1 - (sqrt(x1)))
   W = (1/4) * ( P1 + (sqrt(x1)))
]
//
#ELSE
DEVICE c(cpolyrf) cpoly_rf_device routingpoly2(POS) routingpoly(NEG) routingnwell(SUB) <cpolyrf_capbody>
[
   property W,L,A,P
   A1 = area(cpolyrf_capbody)
   P1 = perimeter(cpolyrf_capbody)
   A = A1 * 1e+12
   P = P1 * 1e+6
   x1 = P1 * P1 - 16.0 * A1
   if( x1 < 0 ) x1 = 0
   L = (1/4) * ( P1 - (sqrt(x1)))
   W = (1/4) * ( P1 + (sqrt(x1)))
]
#ENDIF

#ELSE
  ILL_CPOLYRF_UNAVAILABLE { @ Process Modules : CPOLYRF device not available
         COPY cpoly_rf_device
  }
  cpoly_rf_device_dummy = cpoly_rf_device AND dummy_device
#IFDEF PEXSWITCH
DEVICE c(cpolyrf) cpoly_rf_device_dummy routingpoly2_rblock(POS) routingpoly_rblock(NEG) routingnwell(SUB) <cpolyrf_capbody>
[
   property W,L,A,P
   A = 1
   P = 1
   L = 1
   W = 1
]
#ELSE
DEVICE c(cpolyrf) cpoly_rf_device_dummy routingpoly2(POS) routingpoly(NEG) routingnwell(SUB) <cpolyrf_capbody>
[
   property W,L,A,P
   A = 1
   P = 1
   L = 1
   W = 1
]
#ENDIF
#ENDIF

//
// only single ngate in nwell
//
DEVICE m(cvar) cvar_unsupp_device routingpoly(G) ndiff(S) ndiff(D) substrate(B)
[
   property W,L
   W = (perimeter_coincide(cvar_unsupp_device,ndiff)
        + perimeter_inside(cvar_unsupp_device,ndiff)) / 2
   L = perimeter_outside(cvar_unsupp_device,ndiff) / 2
]
//
// CVAR
//
// device layer is ndiff polygon
// cols are found by counting of poly/ndiff crossings
// rows are found by count of gates
// l = l of one gate
// w = sum of all w of gates
//
//
#IFDEF PEXSWITCH
//
// IC_Station DEVICE m(cvar) cvar_device_layer routingpoly_rblock(G) ndiff(B) substrate(S) <cvar_ndiff_cross> <cvar_ele> 
//
DEVICE m(cvar) cvar_device_layer routingpoly_rblock(G) ndiff(S) ndiff(D) substrate(B) <cvar_ndiff_cross>
   <cvar_ele>
[
   property W, L, cols, rows
   c_elements = count(cvar_ele)
   c_cross = count(cvar_ndiff_cross)/2
   w=perimeter_coincide_inside(cvar_ele, routingpoly_rblock)/2
   l=(perimeter_inside(cvar_ele, routingpoly_rblock)/2)/ c_elements
   rows = c_elements/c_cross
   cols = c_cross
]
#ELSE
//
// IC_Station DEVICE m(cvar) cvar_device_layer routingpoly(G) ndiff(B) substrate(S) <cvar_ndiff_cross> <cvar_ele> 
//
DEVICE m(cvar) cvar_device_layer routingpoly(G) ndiff(S) ndiff(D) substrate(B) <cvar_ndiff_cross>
   <cvar_ele>
[
   property W, L, cols, rows
   c_elements = count(cvar_ele)
   c_cross = count(cvar_ndiff_cross)/2
   w=perimeter_coincide_inside(cvar_ele, routingpoly)/2
   l=(perimeter_inside(cvar_ele, routingpoly)/2)/ c_elements
   rows = c_elements/c_cross
   cols = c_cross
]
#ENDIF

//=====================================================================
// DIODES - nd, pd, nwd, zd, photo
//=====================================================================

// NDIFF-DIODE

DEVICE d(nd) ndiode substrate(POS) ndiff(NEG)
[
   property A,P
   //A = area(ndiode) * 1e+12
   A = area(ndiode)
   //P = perimeter(ndiode) * 1e+6
   P = perimeter(ndiode)
]


// PDIFF-DIODE

DEVICE d(pd) pdiode pdiff(POS) routingnwell(NEG)
[
   property A,P
   //A = area(pdiode) * 1e+12
   A = area(pdiode)
   //P = perimeter(pdiode) * 1e+6
   P = perimeter(pdiode)
]


// NWELL-DIODE

DEVICE d(nwd) nwdiode substrate(POS) routingnwell(NEG)
[
   property A,P
   //A = area(nwdiode) * 1e+12
   A = area(nwdiode)
   //P = perimeter(nwdiode) * 1e+6
   P = perimeter(nwdiode)
]

// ZDIODE

DEVICE d(zd2sm24) zdiode pdiff(POS) ndiff(NEG) substrate(SUB)

//
// PHOTO DIODE
//
//dummy pin
//diode_phdnwa850_pin = EXPAND TEXT "?" OPTDEF_TEXT BY 1.5
//diode_phdnwa850_pin { COPY  diode_phdnwa850_pin }
//
// isolated pin 
//
   CONNECT OPTDEF              
//
// use nwell for w/l 
//
   diode_routingnwell = routingnwell INTERACT diode_phdnwa850 
//
// move text from cell phd up to topcell
//
// EXPAND CELL TEXT "phdnwa850*" PRIMARY
//
#IFDEF layer_devdefopto

DEVICE phd(phdnwa850) diode_phdnwa850 substrate(POS) routingnwell(NEG) OPTDEF(P)
       <diode_routingnwell>
[
   property W,L
   A1 = area(diode_routingnwell)
   P1 = perimeter(diode_routingnwell)
   A = A1 * 1e+12
   P = P1 * 1e+6
   x1 = P1 * P1 - 16.0 * A1
   if( x1 < 0 ) x1 = 0
   L = (1/4) * ( P1 - (sqrt(x1)))
   W = (1/4) * ( P1 + (sqrt(x1)))
]
#ELSE

  diode_phdnwa850_dummy = diode_phdnwa850 AND dummy_device

  ILL_PHDNWA850_UNAVAILABLE { @ Process Modules : PHDNWA850 not availoable for this process modules
         COPY diode_phdnwa850
  }
DEVICE phd(phdnwa850) diode_phdnwa850_dummy substrate(POS) routingnwell(NEG) OPTDEF(P)
[
   property W,L
   W=1
   L=1
]
#ENDIF

//=====================================================================
//                        nmos30m/nmos30t 
//=====================================================================
// split s/d diffs
//
      ndiff_nmos30_all  = ndiff INTERACT (nmos30m_double OR nmos30t_double)
      ndiff_nmos30_1    = nmos30_1 INTERACT (nmos30m_double OR nmos30t_double)
      ndiff_drain  = ndiff_nmos30_all AND ndiff_nmos30_1
      ndiff_source = ndiff_nmos30_all NOT ndiff_nmos30_1 
//
#IFDEF layer_midox
      DEVICE lddn(nmos30m) nmos30m_double ndiff_drain(D) routingpoly(G) ndiff_source(S)
                           substrate(B) <nmos30_ntub> <nmos30_gate_l>
      [
      property L,W,AD,AS,PD,PS
      W  = perimeter_coincide(nmos30m_double,S)
      a  = area(nmos30_gate_l)
      L  = a/W
      AD = area(nmos30_ntub)
      PD = perimeter(nmos30_ntub)
      AS = area(S)
      PS = perimeter_outside(S,nmos30m_double)
      ]
#ELSE
//
  nmos30m_double_dummy = nmos30m_double AND dummy_device
  ILL_NMOS30M_UNAVAILABLE { @ Process Modules : NMOS30M device not available
         COPY nmos30m_double
  }
      DEVICE lddn(nmos30m) nmos30m_double_dummy ndiff_drain(D) routingpoly(G) ndiff_source(S)
                           substrate(B) <nmos30_ntub> <nmos30_gate_l>
      [
      property L,W
      W  = 1
      L  = 1
      ]
#ENDIF
//
      DEVICE lddn(nmos30t) nmos30t_double ndiff_drain(D) routingpoly(G) ndiff_source(S)
                           substrate(B) <nmos30_ntub> <nmos30_gate_l>
      [
      property L,W,AD,AS,PD,PS
      W  = perimeter_coincide(nmos30t_double,S)
      a  = area(nmos30_gate_l)
      L  = a/W
      AD = area(nmos30_ntub)
      PD = perimeter(nmos30_ntub)
      AS = area(S)
      PS = perimeter_outside(S,nmos30t_double)
      ]
//
//=====================================================================
//                        rf nmos/pmos devices
//=====================================================================

// L fixed = 0.5
// W = 5 or 10 U only/stripe
// wmax nmosrf = 200
// wmax pmosrf = 150

// 27-Apr-2007 : as/ad divide by ng


#IFDEF PEXSWITCH
DEVICE mn(nmosrf) nmosrf_device_layer routingpoly_rblock(G) ndiff(S) ndiff(D) substrate(B)
                  <nmosrf_trans> <ndiff_2>
                  BY NET
[
   property W,L,NG,AS,AD
   W = (perimeter_coincide(nmosrf_trans,ndiff_2)
        + perimeter_inside(nmosrf_trans,ndiff_2)) / 2
   L = perimeter_outside(nmosrf_trans  ,ndiff_2) / 2
   nmosrf_elements = count(nmosrf_trans)
   L = L/nmosrf_elements
   W = W/nmosrf_elements
   AS = area(S)/nmosrf_elements
   AD = area(D)/nmosrf_elements
   NG = nmosrf_elements
]
//
DEVICE mp(pmosrf) pmosrf_device_layer routingpoly_rblock(G) pdiff(S) pdiff(D) routingnwell(B)
                  <pmosrf_trans> <pdiff_2>
                  BY NET
[
   property W,L,NG,AS,AD
   W = (perimeter_coincide(pmosrf_trans,pdiff_2)
        + perimeter_inside(pmosrf_trans,pdiff_2)) / 2
   L = perimeter_outside(pmosrf_trans  ,pdiff_2) / 2
   pmosrf_elements = count(pmosrf_trans)
   L = L/pmosrf_elements
   W = W/pmosrf_elements
   NG = pmosrf_elements
   AS = area(S)/pmosrf_elements
   AD = area(D)/pmosrf_elements
]
#ELSE

DEVICE mn(nmosrf) nmosrf_device_layer routingpoly(G) ndiff(S) ndiff(D) substrate(B)
                  <nmosrf_trans> <ndiff_2>
                  BY NET
[
   property W,L,NG,AS,AD
   W = (perimeter_coincide(nmosrf_trans,ndiff_2)
        + perimeter_inside(nmosrf_trans,ndiff_2)) / 2
   L = perimeter_outside(nmosrf_trans  ,ndiff_2) / 2
   nmosrf_elements = count(nmosrf_trans)
   L = L/nmosrf_elements
   W = W/nmosrf_elements
   AS = area(S)/nmosrf_elements
   AD = area(D)/nmosrf_elements
   NG = nmosrf_elements
]
//
DEVICE mp(pmosrf) pmosrf_device_layer routingpoly(G) pdiff(S) pdiff(D) routingnwell(B)
                  <pmosrf_trans> <pdiff_2>
                  BY NET
[
   property W,L,NG,AS,AD
   W = (perimeter_coincide(pmosrf_trans,pdiff_2)
        + perimeter_inside(pmosrf_trans,pdiff_2)) / 2
   L = perimeter_outside(pmosrf_trans  ,pdiff_2) / 2
   pmosrf_elements = count(pmosrf_trans)
   L = L/pmosrf_elements
   W = W/pmosrf_elements
   NG = pmosrf_elements
   AS = area(S)/pmosrf_elements
   AD = area(D)/pmosrf_elements
]
#ENDIF
//
//=====================================================================
//                           rf pads
//=====================================================================
//
// not supported Yet
//
// ld is length of diffusion in diode left and right of pad
//
//   DEVICE rfpad( padvss ) rfpad_gnd PAD(PAD) rfpad_vdd_term(VDD) rfpad_vss_term(SUB)
//                          <rfpad_vdd_term_spac>
//   [
//     property LD
//     LD = (perimeter_coincide(rfpad_vdd_term, rfpad_vdd_term_spac))/2
//   ]
//
//   DEVICE rfpad( padvdd ) rfpad_vdd PAD(PAD) rfpad_vdd_term(VDD) rfpad_vss_term(SUB)
//                          <rfpad_vdd_term_spac>
//   [
//     property LD
//     LD = (perimeter_coincide(rfpad_vdd_term, rfpad_vdd_term_spac))/2
//   ]
//
//=====================================================================
//                            PROBE pads
//=====================================================================
// device without pad window, only metal there

#IFDEF fourmetal

   DEVICE probepad(probe) probe_layer routingmet4(pad)

#ELSE

   DEVICE probepad(probe) probe_layer routingmet3(pad)

#ENDIF

//=====================================================================
//                             SPIRALS 
//=====================================================================
//
// Definition : consist of met2/met3/met4 parts, connected by via2/via3
//              INDDEF layer encloses whole spiral
//              model name is text on INDDEF layer
//              RESTRM layer defines connection, must have text P1/P2 !!!
//              if no name is found, but spiral definition is ok, then
//              model name is unknown
//              there are some checks, if spiral is shorted or bad (open)
//              by external metal
// text convention : text is on m3pin for 3 met spirals, on met4 on 4 met spirals
//                   text is placed in restrm rectangle
//   
// 29 met3 spirals
//
#IFDEF fourmetal
//
// four metal spirals
//
   DEVICE L(SP014S300D) spiral_body_SP014S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP018S300D) spiral_body_SP018S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP020S180D) spiral_body_SP020S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP023S200D) spiral_body_SP023S200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP025C200D) spiral_body_SP025C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP026S200D) spiral_body_SP026S200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028C200D) spiral_body_SP028C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028S300D) spiral_body_SP028S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP030C200D) spiral_body_SP030C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP037S180D) spiral_body_SP037S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP038S300D) spiral_body_SP038S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C200D) spiral_body_SP040C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C300D) spiral_body_SP040C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP045C200D) spiral_body_SP045C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP047S180D) spiral_body_SP047S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP050S155D) spiral_body_SP050S155D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP051C300D) spiral_body_SP051C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP068C300D) spiral_body_SP068C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090C200D) spiral_body_SP090C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090S155D) spiral_body_SP090S155D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP112C300D) spiral_body_SP112C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP140C200D) spiral_body_SP140C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP200C200D) spiral_body_SP200C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
   DEVICE L(SY014C165D) spiral_body_SY014C165D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY015C200D) spiral_body_SY015C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY016C180D) spiral_body_SY016C180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY017C165D) spiral_body_SY017C165D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY019C180D) spiral_body_SY019C180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY028C160D) spiral_body_SY028C160D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
#ELSE
//
// 3 metal spirals
//
   DEVICE L(SP014S300C) spiral_body_SP014S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP018S300C) spiral_body_SP018S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP020S180C) spiral_body_SP020S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP023S200C) spiral_body_SP023S200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP025C200C) spiral_body_SP025C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP026S200C) spiral_body_SP026S200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028C200C) spiral_body_SP028C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028S300C) spiral_body_SP028S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP030C200C) spiral_body_SP030C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP037S180C) spiral_body_SP037S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP038S300C) spiral_body_SP038S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C200C) spiral_body_SP040C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C300C) spiral_body_SP040C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP045C200C) spiral_body_SP045C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP047S180C) spiral_body_SP047S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP050S155C) spiral_body_SP050S155C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP051C300C) spiral_body_SP051C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP068C300C) spiral_body_SP068C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090C200C) spiral_body_SP090C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090S155C) spiral_body_SP090S155C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP112C300C) spiral_body_SP112C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP140C200C) spiral_body_SP140C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP200C200C) spiral_body_SP200C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
   DEVICE L(SY014C165C) spiral_body_SY014C165C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY015C200C) spiral_body_SY015C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY016C180C) spiral_body_SY016C180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY017C165C) spiral_body_SY017C165C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY019C180C) spiral_body_SY019C180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY028C160C) spiral_body_SY028C160C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
#ENDIF
//
// if not found, should be any spiral name, but terminals must exist
//
   DEVICE L(spiral_unknown) spiral_body_unknown spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
//=====================================================================
//                             HALL
//=====================================================================
//
   DEVICE hall(HALLC35) hall_body_HALLC35 hall_term_a(A) hall_term_b(B) hall_term_c(C) hall_term_d(D)
                        hall_term_s(S) hall_term_p1(P1) hall_term_p2(P2)
//
//=====================================================================
// CAPACITANCES - cmim
//=====================================================================
//
// metcap is cap between metcap layer and met2
//
#IFDEF layer_metcap
//
//
DEVICE c(cmim) cmim_norf routingmetcap(POS) routingmet2(NEG)
[
   property A,P
   A = area(routingmetcap) * 1e+12
   P = perimeter(routingmetcap) * 1e+6
]
//

#ELSE

  ILL_CMIM_UNAVAILABLE { @ Process Modules : CMIM device not available
         COPY cmim
  }
  cmim_dummy = cmim AND dummy_device

DEVICE c(cmim) cmim_dummy routingmetcap(POS) routingmet2(NEG)
[
   property A,P
   A = area(routingmetcap) * 1e+12
   P = perimeter(routingmetcap) * 1e+6
]

#ENDIF

///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5 
//
//       _rules_title (Trace Section)
//
//       Document: ENG-183                      Revision: 1.0
//
//       Created with ams_tech on by
//
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//                21-Jul-2005        aob      basic version    
//                 9-Aug-2005        aob      nmosh added
///////////////////////////////////////////////////////////////////////
//
//   Device Recognition is done for the following devices
//---------------------------------------------------------------------
//
//   - nmosl4, pmosl4, nmosml4, pmosml4
//   - nmoshl4 , nmosmhl4
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//                     LVT  DEVICE-RECOGNITION                       //
///////////////////////////////////////////////////////////////////////

#IFDEF layer_lvtdef

//
//----------------------- hv devices -----------------------
//

#IFDEF layer_midox

// NMOSMHL4

DEVICE lddn(nmosmhl4) nmosmh_lvt nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS
   bend_effect = 0.5
   W = (perimeter_coincide(nmosmh_lvt,ndiff))
   a = area(nmosmh_lvt)
   L = a/W
   if (bends(nmosmh_lvt) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosmh_lvt) * L
     else
       L = L - bend_effect * bends(nmosmh_lvt) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosmh_lvt)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]

#ELSE

  nmosmh_dummy_lvt = nmosmh_lvt AND dummy_device
  ILL_NMOSMHL4_UNAVAILABLE { @ Process Modules : NMOSMHL4 device not available
         COPY nmosmh
  }

DEVICE lddn(nmosmhl4) nmosmh_dummy_lvt nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W
   W = (perimeter_coincide(nmosmh_dummy_lvt,ndiff))
   a = area(nmosmh_dummy_lvt)
   L = a/W
]
#ENDIF


// NMOSHL4

DEVICE lddn(nmoshl4) nmosh_nomidox_lvt nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS
   bend_effect = 0.5
   W = (perimeter_coincide(nmosh_nomidox_lvt,ndiff))
   a = area(nmosh_nomidox_lvt)
   L = a/W
   if (bends(nmosh_nomidox_lvt) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosh_nomidox_lvt) * L
     else
       L = L - bend_effect * bends(nmosh_nomidox_lvt) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosh_nomidox_lvt)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]
//

//
//----------------------- nmos, pmos devices -----------------------
//

// shorted stacked devices cause bad negative ps/pd in case of shorted devices 
// extra handling for lvt devices 

// there is some overhead in property computation ( pis==0, pid==0) because
// of splitting of devices

nmos_lvt_short   = nmos_lvt TOUCH ndiff == 1 BY NET
nmos_lvt_noshort = nmos_lvt NOT nmos_lvt_short
//
DEVICE mn(nmosl4) nmos_lvt_noshort routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_lvt_noshort  ,ndiff)
        + perimeter_inside(nmos_lvt_noshort  ,ndiff)) / 2
   L = perimeter_outside(nmos_lvt_noshort  ,ndiff) / 2
   W_orig = W
   if (bends(nmos_lvt_noshort  ) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_lvt_noshort  ) * L
     else
       L = L - bend_effect * bends(nmos_lvt_noshort  ) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_lvt_noshort  ))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_lvt_noshort  ))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_lvt_noshort  )
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_lvt_noshort )
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
#IFDEF    SHORT_DEVICE_DEBUG
DEVICE mn(nmosl4_short) nmos_lvt_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ELSE
DEVICE mn(nmosl4) nmos_lvt_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_lvt_short  ,ndiff)
        + perimeter_inside(nmos_lvt_short  ,ndiff)) / 2
   L = perimeter_outside(nmos_lvt_short  ,ndiff) / 2
   W_orig = W
   if (bends(nmos_lvt_short  ) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_lvt_short  ) * L
     else
       L = L - bend_effect * bends(nmos_lvt_short  ) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_lvt_short  ))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_lvt_short  ))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_lvt_short  )
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_lvt_short )
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
nmos_mlvt_short   = nmos_mlvt TOUCH ndiff == 1 BY NET
nmos_mlvt_noshort = nmos_mlvt NOT nmos_mlvt_short

DEVICE mn(nmosml4) nmos_mlvt_noshort routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_mlvt_noshort  ,ndiff)
        + perimeter_inside(nmos_mlvt_noshort  ,ndiff)) / 2
   L = perimeter_outside(nmos_mlvt_noshort  ,ndiff) / 2
   W_orig = W
   if (bends(nmos_mlvt_noshort  ) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_mlvt_noshort  ) * L
     else
       L = L - bend_effect * bends(nmos_mlvt_noshort  ) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_mlvt_noshort  ))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_mlvt_noshort  ))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_mlvt_noshort  )
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_mlvt_noshort  )
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
#IFDEF    SHORT_DEVICE_DEBUG
DEVICE mn(nmosml4_short) nmos_mlvt_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ELSE
DEVICE mn(nmosml4) nmos_mlvt_short routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_mlvt_short  ,ndiff)
        + perimeter_inside(nmos_mlvt_short  ,ndiff)) / 2
   L = perimeter_outside(nmos_mlvt_short  ,ndiff) / 2
   W_orig = W
   if (bends(nmos_mlvt_short  ) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_mlvt_short  ) * L
     else
       L = L - bend_effect * bends(nmos_mlvt_short  ) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_mlvt_short  ))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_mlvt_short  ))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_mlvt_short  )
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_mlvt_short  )
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
pmos_lvt_short   = pmos_lvt TOUCH pdiff == 1 BY NET
pmos_lvt_noshort = pmos_lvt NOT pmos_lvt_short
//
DEVICE mp(pmosl4) pmos_lvt_noshort routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_lvt_noshort,pdiff)
        + perimeter_inside(pmos_lvt_noshort,pdiff)) / 2
   L = perimeter_outside(pmos_lvt_noshort,pdiff) / 2
   W_orig = W
   if (bends(pmos_lvt_noshort) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_lvt_noshort) * L
     else
       L = L - bend_effect * bends(pmos_lvt_noshort) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_lvt_noshort))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_lvt_noshort))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_lvt_noshort)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_lvt_noshort)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
#IFDEF    SHORT_DEVICE_DEBUG
DEVICE mp(pmosl4_short) pmos_lvt_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ELSE
DEVICE mp(pmosl4) pmos_lvt_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_lvt_short,pdiff)
        + perimeter_inside(pmos_lvt_short,pdiff)) / 2
   L = perimeter_outside(pmos_lvt_short,pdiff) / 2
   W_orig = W
   if (bends(pmos_lvt_short) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_lvt_short) * L
     else
       L = L - bend_effect * bends(pmos_lvt_short) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_lvt_short))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_lvt_short))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_lvt_short)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_lvt_short)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = W
]
pmos_mlvt_short   = pmos_mlvt TOUCH pdiff == 1 BY NET
pmos_mlvt_noshort = pmos_mlvt NOT pmos_mlvt_short
DEVICE mp(pmosml4) pmos_mlvt_noshort routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_mlvt_noshort,pdiff)
        + perimeter_inside(pmos_mlvt_noshort,pdiff)) / 2
   L = perimeter_outside(pmos_mlvt_noshort,pdiff) / 2
   W_orig = W
   if (bends(pmos_mlvt_noshort) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_mlvt_noshort) * L
     else
       L = L - bend_effect * bends(pmos_mlvt_noshort) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_mlvt_noshort))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_mlvt_noshort))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_mlvt_noshort)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_mlvt_noshort)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = 1
]
#IFDEF    SHORT_DEVICE_DEBUG
DEVICE mp(pmosml4_short) pmos_mlvt_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ELSE
DEVICE mp(pmosml4) pmos_mlvt_short routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1> BY SHAPE
#ENDIF
[
   property W,L,AS,AD,PS,PD,NRS,NRD,M
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_mlvt_short,pdiff)
        + perimeter_inside(pmos_mlvt_short,pdiff)) / 2
   L = perimeter_outside(pmos_mlvt_short,pdiff) / 2
   W_orig = W
   if (bends(pmos_mlvt_short) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_mlvt_short) * L
     else
       L = L - bend_effect * bends(pmos_mlvt_short) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_mlvt_short))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_mlvt_short))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_mlvt_short)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_mlvt_short)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
   M = 1
   WTOT = 1
]

#IFDEF DEVSWITCH
   xnmosl4_short   { COPY nmos_lvt_short }
   xnmosml4_short   { COPY nmos_mlvt_short }
   xpmosl4_short   { COPY pmos_lvt_short }
   xpmosml4_short   { COPY pmos_mlvt_short }
#ENDIF

#ELSE
//
  ILL_NMOSHL4_UNAVAILABLE { @ Process Modules : nmoshl4 device not available
         COPY nmosh_nomidox_lvt 
  }
  ILL_NMOSMHL4_UNAVAILABLE { @ Process Modules : nmosmhl4 device not available
         COPY nmosmh_lvt 
  }
//
  ILL_NMOSL4_UNAVAILABLE { @ Process Modules : nmosl4 device not available
         COPY nmos_lvt 
  }
  ILL_NMOSML4_UNAVAILABLE { @ Process Modules : nmosml4 device not available
         COPY nmos_mlvt 
  }
//
  ILL_PMOSL4_UNAVAILABLE { @ Process Modules : pmosl4 device not available
         COPY pmos_lvt 
  }
  ILL_PMOSML4_UNAVAILABLE { @ Process Modules : pmosml4 device not available
         COPY pmos_mlvt 
  }
//
#ENDIF
// 
///////////////////////////////////////////////////////////////////////
//
//   end of CALIBRE technology file    end of CALIBRE technology file
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//  start of XCALIBRE technology file   start of XCALIBRE technology file
//
///////////////////////////////////////////////////////////////////////
//  3-Mar-03   aob    created and modified
//  6-Mar-03   aob    wellcap added , cap order MASK added 
//                    nwdiode_shield added
// 11-Mar-03   aob    trans_shield added
// 14-May-03   aob    remove all parasitic caps poly1/poly2
//
// ok CAPACITANCE CROSSOVER PLATE routingpoly routingpoly2 MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF pdiff
//     MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF ndiff
//     MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF
//     routingmet1 MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF
//     routingmet2 MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF
//     routingmet3 MASK
// ok CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF
//     routingmet4 MASK
//
//  15-Mar-05  aob  : dummy statements for trans_shield and nwdiode_shield due
//                    to transition from xcalibre to xrc
//                    resistance connection metal1/diffcon added
//  20-Jul-05  aob  : pexswitch added
//  31-May-2006 aob : routingmetcap metcap added from s35  ... met4 only
//
///////////////////////////////////////////////////////////////////////
//  Done by Ahmed Gharieb (ahmed_gharieb@mentor.com)
///////////////////////////////////////////////////////////////////////

#IFDEF fourmetal

//==========================================================================
//                             c35b4_worst   
//==========================================================================
// Comments: use max thickness for connect layer and worst(min) for oxid
//           21-Jan-03 : rmet3 = rmet2
//==========================================================================



#IFDEF PEXSWITCH
CAPACITANCE ORDER nwdiode_shield routingnwell ndiff pdiff trans_shield 
                  routingpoly routingpoly_rblock routingpoly2 routingpoly2_rblock  routingmet1 routingmet1_rblock
                  routingmet2 routingmet2_rblock cmim_shield routingmetcap 
                  routingmet3 routingmet4 MASK //ghe - modified shielding
#ELSE
CAPACITANCE ORDER nwdiode_shield routingnwell ndiff pdiff trans_shield routingpoly routingpoly2 routingmet1
                  routingmet2 cmim_shield routingmetcap routingmet3 routingmet4 MASK
#ENDIF // pexswitch


// dummy statements for xrc transition : see MENTOR doc
//
// trans_shield not necessary because between 2 layers with capacitance statements ( app Note 0335 )
// nwdiode_shield is necessary
//
CAPACITANCE CROSSOVER PLATE trans_shield routingpoly MASK
[
    PROPERTY C
    C = 0
]
CAPACITANCE CROSSOVER PLATE nwdiode_shield routingnwell MASK
[
    PROPERTY C
    C = 0
]
CAPACITANCE CROSSOVER PLATE cmim_shield routingmet2 MASK
[
    PROPERTY C
    C = 0
]
//
//=========================================================================
// worst case 

// sheet resistances
//
// RMET_      = MET1 sheet resistance [mW/o]                           
// RMET_max   = 120                              
// RMET2_     = MET2 sheet resistance [mW/o]                            
// RMET2_max  = 120                               
// RMET3_     = MET3 sheet resistance [mW/o]                            
// RMET3_max  = 120                               
// RMET4_     = MET4 sheet resistance [mW/o]                            
// RMET4_max  = 100                               
// RPOLY_     = POLY1 sheet resistance [W/o]                           
// RPOLY_max  = 11                              
// RPOLY2_     = POLY2 sheet resistance [W/o]                           
// RPOLY2_max  = 60                              
//
RESISTANCE SHEET routingmet4 [ 0.1  0 ] MASK 
RESISTANCE SHEET routingmet3 [ 0.12  0 ] MASK 
RESISTANCE SHEET routingmet2 [ 0.12  0 ] MASK 
RESISTANCE SHEET routingmet1 [ 0.12  0 ] MASK 
RESISTANCE SHEET routingpoly [ 11  0 ] MASK 
RESISTANCE SHEET routingpoly2 [ 60  0 ] MASK 
//
// resistance connection
//
// RVIA_      = VIA resistance 0.5x0.5m [W/via]
// RVIA_max   = 3
// RVIA2_     = VIA2 resistance 0.5x0.5m [W/via]
// RVIA2_max  = 3
// RVIA3_    = VIA3 resistance 0.5x0.5m [W/via]
// RVIA3_max = 3
// RCNTMP2_   = MET1-POLY2 cont. resistance 0.4x0.4m [W/cnt]
// RCNTMP2_max = 40
// RCNTMP_     = MET1-POLY1 cont. resistance 0.4x0.4m [W/cnt]
// RCNTMP_max  = 10
// RCNTMDP_    = MET1-PDIFF cont. resistance 0.4x0.4m [W/cnt]
// RCNTMDP_max = 150
// RCNTMDN_    = MET1-NDIFF cont. resistance 0.4x0.4m [W/cnt]
// RCNTMDN_max = 100

RESISTANCE CONNECTION routingmet4 routingmet3 [ 0.75 0 ] MASK 
RESISTANCE CONNECTION routingmet3 routingmet2 [ 0.75 0 ] MASK 
RESISTANCE CONNECTION routingmet2 routingmet1 [ 0.75 0 ] MASK // 6/4
RESISTANCE CONNECTION routingmet1 routingpoly2 [ 6.4 0 ] MASK // 40/6.25 
RESISTANCE CONNECTION routingmet1 routingpoly [ 1.6 0 ] MASK   // 20/6.25 
//metal1-p+ cnt.res.1/1 = RCNTMDP =150*0.4^2
RESISTANCE CONNECTION routingmet1 pdiff [ 24 0 ] MASK
//metal1-n+ cnt.res.1/1 = RCNTMDN =100*0.4^2
RESISTANCE CONNECTION routingmet1 ndiff [ 16 0 ] MASK
//
//==========================================================================
//
// Generated on Sun Jan  5 11:25:14 2003 by xCalibrate v9.3_1.1 Fri Dec 13 15:14:57 PST 2002
//
// Generated on Sun Jan  5 11:25:14 2003 by xCalibrate v9.3_1.1 Fri Dec 13 15:14:57 PST 2002
//
// Comments: 
//
// Technology name: c35b4_worst
// Precision: 1000
// DBU Size: 1e-09
// DB Magnification: 1
// Capacitance Units: ff
// Background Dielectric: 1
// Stacking Mode: Unconditional
//
// Following line(s) should be in your rulesfile
// UNIT CAPACITANCE ff
// Above line(s) should be in your rulesfile
//
// 
// Background dielectric = 1
// 
// Profile = field
// Layers =  (field_base field_base_diel routingpoly routingpoly_diel routingpoly2 routingpoly2_diel routingmet1 routingmet1_diel routingmet2 routingmet2_diel routingmet3 routingmet3_diel routingmet4 routingmet4_diel)
// 
//     Z-COORD              NAME TYPE THICKNESS   DIEL   WIDTH   SPACE  
//                                                                
//  --- 6.4990  ---------------------------------------------------
//  |           routingmet4_diel   D    1.0000   7.9000      
//  --- 5.4990  ---------------------------------------------------
//  |                routingmet4   C    1.0750           0.6000  0.6000 
//  --- 4.4240  ---------------------------------------------------
//  |           routingmet3_diel   D    0.4200   4.1000      
//  --- 4.0040  ---------------------------------------------------
//  |                routingmet3   C    0.7400           0.6000  0.5000 
//  --- 3.2640  ---------------------------------------------------
//  |           routingmet2_diel   D    0.4200   4.1000      
//  --- 2.8440  ---------------------------------------------------
//  |                routingmet2   C    0.7400           0.6000  0.5000 
//  --- 2.1040  ---------------------------------------------------
//  |           routingmet1_diel   D    0.4200   4.1000      
//  --- 1.6840  ---------------------------------------------------
//  |                routingmet1   C    0.7650           0.5000  0.4500 
//  --- 0.9190  ---------------------------------------------------
//  |           routingpoly2_diel   D    0.1070   4.0000      
//  --- 0.8120  ---------------------------------------------------
//  |               routingpoly2   C    0.2150           0.6500  0.5000 
//  --- 0.5970  ---------------------------------------------------
//  |           routingpoly_diel   D    0.0370   4.0000      
//  --- 0.5600  ---------------------------------------------------
//  |                routingpoly   C    0.3000           0.3500  0.4500 
//  --- 0.2600  ---------------------------------------------------
//  |            field_base_diel   D    0.2600   3.9000      
//  --- 0.0000  ---------------------------------------------------
//  |                 field_base   B    1.0000
//  --- -1.0000 ---------------------------------------------------
// 
// Background dielectric = 1
// 
// Profile = active
// Layers =  (active_base active_base_diel routingmet1 routingmet1_diel routingmet2 routingmet2_diel routingmet3 routingmet3_diel routingmet4 routingmet4_diel)
// 
//     Z-COORD              NAME TYPE THICKNESS   DIEL   WIDTH   SPACE  
//                                                                
//  --- 5.9840  ---------------------------------------------------
//  |           routingmet4_diel   D    1.0000   7.9000      
//  --- 4.9840  ---------------------------------------------------
//  |                routingmet4   C    1.0750           0.6000  0.6000 
//  --- 3.9090  ---------------------------------------------------
//  |           routingmet3_diel   D    0.4200   4.1000      
//  --- 3.4890  ---------------------------------------------------
//  |                routingmet3   C    0.7400           0.6000  0.5000 
//  --- 2.7490  ---------------------------------------------------
//  |           routingmet2_diel   D    0.4200   4.1000      
//  --- 2.3290  ---------------------------------------------------
//  |                routingmet2   C    0.7400           0.6000  0.5000 
//  --- 1.5890  ---------------------------------------------------
//  |           routingmet1_diel   D    0.4200   4.1000      
//  --- 1.1690  ---------------------------------------------------
//  |                routingmet1   C    0.7650           0.5000  0.4500 
//  --- 0.4040  ---------------------------------------------------
//  |           active_base_diel   D    0.4040   3.9000      
//  --- 0.0000  ---------------------------------------------------
//  |                active_base   B    1.0000
//  --- -1.0000 ---------------------------------------------------
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingpoly
//
CAPACITANCE INTRINSIC PLATE routingpoly MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE INTRINSIC PLATE routingpoly2 MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet1
//
CAPACITANCE INTRINSIC PLATE routingmet1 MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet2
//
CAPACITANCE INTRINSIC PLATE routingmet2 MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet3
//
CAPACITANCE INTRINSIC PLATE routingmet3 MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet4
//
CAPACITANCE INTRINSIC PLATE routingmet4 MASK
[
    PROPERTY C
    C = 0.00815072 * area()
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingpoly
//
CAPACITANCE INTRINSIC FRINGE routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0532483 * (1 - exp(-1.34175 * (distance() + 0.142997)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565925
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingpoly
//
CAPACITANCE NEARBODY routingpoly WITH SHIELD routingpoly MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.04118 - 1.38136 * (distance())) + 0.0135736 / pow(distance() , 1.09077)) * 1.1381 * pow((width1() + width2()) / 2 , 0.215443)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0423004 * (1 - exp(-0.889624 * (distance() + 0.163635)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0453339
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE NEARBODY routingpoly2 WITH SHIELD routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.77614 - 0.924211 * (distance())) + 0.018676 / pow(distance() , 0.92485)) * 0.888335 * pow((width1() + width2()) / 2 , 0.233595)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0454584 * (1 - exp(-0.56303 * (distance() + 0.146881)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499153
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet1
//
CAPACITANCE NEARBODY routingmet1 WITH SHIELD routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.20262 - 0.740624 * (distance())) + 0.0206707 / pow(distance() , 0.964583)) * 1.81054 * pow((width1() + width2()) / 2 , 0.113378)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348043 * (1 - exp(-0.340747 * (distance() + 0.425008)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0398451
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet2
//
CAPACITANCE NEARBODY routingmet2 WITH SHIELD routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.37497 - 0.402422 * (distance())) + 0.0319658 / pow(distance() , 0.84077)) * 1.45257 * pow((width1() + width2()) / 2 , 0.143986)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0300392 * (1 - exp(-0.22725 * (distance() + 0.969108)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.03587
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet3
//
CAPACITANCE NEARBODY routingmet3 WITH SHIELD routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.69431 - 0.214499 * (distance())) + 0.032278 / pow(distance() , 0.892845)) * 1.27911 * pow((width1() + width2()) / 2 , 0.18492)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0598403 * (1 - exp(-0.0631048 * (distance() + 0.921632)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0368314
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet4
//
CAPACITANCE NEARBODY routingmet4 WITH SHIELD routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.9381 - 0.317585 * (distance())) + 0.0522599 / pow(distance() , 0.908128)) * 1.9524 * pow((width1() + width2()) / 2 , 0.0700987)
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed 
//CAPACITANCE CROSSOVER PLATE routingpoly routingpoly2 MASK
//[
//    PROPERTY C
//    C = 0.957189 * area()
//]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet1 MASK
[
    PROPERTY C
    C = 0.0986518 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet2 MASK
[
    PROPERTY C
    C = 0.0233756 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet3 MASK
[
    PROPERTY C
    C = 0.0133808 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet4 MASK
[
    PROPERTY C
    C = 0.00937307 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet1 MASK
[
    PROPERTY C
    C = 0.330991 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet2 MASK
[
    PROPERTY C
    C = 0.0280392 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet3 MASK
[
    PROPERTY C
    C = 0.0147887 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet4 MASK
[
    PROPERTY C
    C = 0.0100428 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingmet1 routingmet2 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingmet1 routingmet3 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER PLATE routingmet1 routingmet4 MASK
[
    PROPERTY C
    C = 0.0132487 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingmet2 routingmet3 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER PLATE routingmet2 routingmet4 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER PLATE routingmet3 routingmet4 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03214 - 5.62812 * (distance())) + 0.00065288 / pow(distance() , 2.12136)) * 0.849821 * pow((width1() + width2()) / 2 , 0.00833925)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0703073
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00072417 * (distance()) + 0.11128) * (1.18567 - exp(-(0.330112 * (distance()) + 6.01309) * (enclose() + 0.109354 * (distance()) + 0.560448) - (-0.0031829 * (distance()) + -0.935435) * (enclose() + -0.227676 * (distance()) + -1.74479) * (enclose() + -0.227676 * (distance()) + -1.74479)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0574504 * (1.18567 - exp(-7.66365 * (enclose() + 1.10722) - -0.95135 * (enclose() + -2.88317) * (enclose() + -2.88317)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0246626 * (1 - exp(-4.60903 * (distance() + -0.0717568)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0255046
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30766 - 3.57322 * (distance())) + 0.00091407 / pow(distance() , 1.8011)) * 1.04967 * pow((width1() + width2()) / 2 , 0.00862509)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0276821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00133421 * (distance()) + 0.0947724) * (0.590638 - exp(-(1.33191 * (distance()) + 1.41068) * (enclose() + -0.0410965 * (distance()) + 0.487351) - (-0.170231 * (distance()) + -0.158494) * (enclose() + 0.0927245 * (distance()) + 0.511557) * (enclose() + 0.0927245 * (distance()) + 0.511557)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0440507 * (0.590638 - exp(-8.07023 * (enclose() + 0.281868) - -1.00965 * (enclose() + 0.97518) * (enclose() + 0.97518)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329226 * (1 - exp(-3.10879 * (distance() + -0.0889366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0339331
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.94424 - 1.7925 * (distance())) + 0.00357802 / pow(distance() , 1.72832)) * 1.04296 * pow((width1() + width2()) / 2 , 0.0990315)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00059321 * (distance()) + 0.0273051) * (0.87914 - exp(-(0.0246106 * (distance()) + 0.716701) * (enclose() + 0.590434 * (distance()) + -0.181639) - (0.0126597 * (distance()) + -0.130102) * (enclose() + -1.12924 * (distance()) + 0.857723) * (enclose() + -1.12924 * (distance()) + 0.857723)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0121695 * (0.87914 - exp(-0.839754 * (enclose() + 2.77053) - -0.0668035 * (enclose() + -4.78848) * (enclose() + -4.78848)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433651 * (1 - exp(-1.69337 * (distance() + 0.0312548)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454312
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.31662 - 1.40731 * (distance())) + 0.00596482 / pow(distance() , 1.50427)) * 1.1051 * pow((width1() + width2()) / 2 , 0.151405)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751819
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00056907 * (distance()) + 0.0175334) * (0.928289 - exp(-(0.0588486 * (distance()) + 0.340669) * (enclose() + 0.813125 * (distance()) + -0.508852) - (0.0013806 * (distance()) + -0.0300689) * (enclose() + -1.88705 * (distance()) + 0.97368) * (enclose() + -1.88705 * (distance()) + 0.97368)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00734403 * (0.928289 - exp(-0.634912 * (enclose() + 3.55677) - -0.0231659 * (enclose() + -8.46157) * (enclose() + -8.46157)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.046742 * (1 - exp(-1.46684 * (distance() + 0.0886804)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498613
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.45893 - 1.28234 * (distance())) + 0.00882865 / pow(distance() , 1.35797)) * 1.02123 * pow((width1() + width2()) / 2 , 0.176268)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00564609
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00044717 * (distance()) + 0.0169127) * (0.714796 - exp(-(-0.0229817 * (distance()) + 0.320382) * (enclose() + 2.48319 * (distance()) + -1.43302) - (-0.00996399 * (distance()) + 0.0096513) * (enclose() + 0.341381 * (distance()) + -7.59785) * (enclose() + 0.341381 * (distance()) + -7.59785)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00733842 * (0.714796 - exp(-0.205474 * (enclose() + 10.9829) - -0.0401687 * (enclose() + -5.89095) * (enclose() + -5.89095)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0482997 * (1 - exp(-1.39936 * (distance() + 0.118367)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0523407
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88841 - 3.6518 * (distance())) + 0.00073205 / pow(distance() , 2.06432)) * 1.18797 * pow((width1() + width2()) / 2 , 0.0112007)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509744
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00032081 * (distance()) + 0.0940125) * (1.02405 - exp(-(2.60904 * (distance()) + 2.12041) * (enclose() + -0.0133109 * (distance()) + 0.133988) - (-0.0195914 * (distance()) + 0.0602649) * (enclose() + 0.0248593 * (distance()) + 2.0515) * (enclose() + 0.0248593 * (distance()) + 2.0515)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0478083 * (1.02405 - exp(-15.1656 * (enclose() + 0.0674335) - -0.0376921 * (enclose() + 2.1758) * (enclose() + 2.1758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0145893 * (1 - exp(-3.1831 * (distance() + -0.0608293)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150047
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.90711 - 1.57677 * (distance())) + 0.00228218 / pow(distance() , 1.79643)) * 1.0814 * pow((width1() + width2()) / 2 , 0.0422125)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153166
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00067108 * (distance()) + 0.0382259) * (0.854775 - exp(-(-0.0195501 * (distance()) + 0.670691) * (enclose() + 0.921985 * (distance()) + -0.324567) - (0.0268178 * (distance()) + -0.25127) * (enclose() + -0.787422 * (distance()) + 0.228141) * (enclose() + -0.787422 * (distance()) + 0.228141)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0174352 * (0.854775 - exp(-0.572941 * (enclose() + 4.28536) - -0.117181 * (enclose() + -3.70897) * (enclose() + -3.70897)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284418 * (1 - exp(-1.35207 * (distance() + -0.0531136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0291869
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.06824 - 1.15439 * (distance())) + 0.0052183 / pow(distance() , 1.52648)) * 0.976453 * pow((width1() + width2()) / 2 , 0.0992957)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0100895
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00078214 * (distance()) + 0.0252269) * (0.887579 - exp(-(0.0294899 * (distance()) + 0.346855) * (enclose() + 0.955562 * (distance()) + -0.617052) - (0.00264508 * (distance()) + -0.0546774) * (enclose() + -1.26235 * (distance()) + 0.475899) * (enclose() + -1.26235 * (distance()) + 0.475899)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106581 * (0.887579 - exp(-0.494305 * (enclose() + 4.16076) - -0.041452 * (enclose() + -5.83585) * (enclose() + -5.83585)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.033175 * (1 - exp(-1.04673 * (distance() + 0.0259002)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0348207
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.19376 - 0.999264 * (distance())) + 0.00804456 / pow(distance() , 1.3321)) * 0.92757 * pow((width1() + width2()) / 2 , 0.141047)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00762268
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00032315 * (distance()) + 0.0236557) * (0.657312 - exp(-(-0.0281134 * (distance()) + 0.327877) * (enclose() + 2.83039 * (distance()) + -1.63104) - (-0.00915175 * (distance()) + 0.00847617) * (enclose() + 0.494566 * (distance()) + -8.6338) * (enclose() + 0.494566 * (distance()) + -8.6338)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.01102 * (0.657312 - exp(-0.18731 * (enclose() + 12.5209) - -0.0372826 * (enclose() + -6.16097) * (enclose() + -6.16097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0354892 * (1 - exp(-0.950385 * (distance() + 0.0781097)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0380715
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.67663 - 1.58304 * (distance())) + 0.00379437 / pow(distance() , 1.89416)) * 1.51649 * pow((width1() + width2()) / 2 , 0.0136467)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0434111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0004589 * (distance()) + 0.132663) * (0.637158 - exp(-(0.750364 * (distance()) + 0.407317) * (enclose() + -0.0731466 * (distance()) + 0.931012) - (-0.0871715 * (distance()) + 0.023843) * (enclose() + 0.0751287 * (distance()) + 1.34571) * (enclose() + 0.0751287 * (distance()) + 1.34571)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0651842 * (0.637158 - exp(-4.15914 * (enclose() + 0.565279) - -0.412015 * (enclose() + 1.72135) * (enclose() + 1.72135)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245562 * (1 - exp(-1.1464 * (distance() + -0.10083)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0251716
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78979 - 1.05779 * (distance())) + 0.00747423 / pow(distance() , 1.63943)) * 1.38467 * pow((width1() + width2()) / 2 , 0.0394983)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222844
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00141089 * (distance()) + 0.0436567) * (1.17942 - exp(-(0.0440702 * (distance()) + 0.934807) * (enclose() + -0.0309741 * (distance()) + 0.590978) - (0.00783802 * (distance()) + -0.126844) * (enclose() + -0.39932 * (distance()) + 2.68549) * (enclose() + -0.39932 * (distance()) + 2.68549)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0183011 * (1.17942 - exp(-1.15516 * (enclose() + 0.436107) - -0.0876539 * (enclose() + 0.68889) * (enclose() + 0.68889)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324189 * (1 - exp(-0.750344 * (distance() + -0.0383901)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032951
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.927 - 0.876312 * (distance())) + 0.0115866 / pow(distance() , 1.43705)) * 1.3102 * pow((width1() + width2()) / 2 , 0.0599189)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157949
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00224679 * (distance()) + 0.0443502) * (0.904313 - exp(-(0.0180779 * (distance()) + 0.115945) * (enclose() + 1.872 * (distance()) + -0.368864) - (-0.013945 * (distance()) + -0.00230186) * (enclose() + -0.381288 * (distance()) + -1.95374) * (enclose() + -0.381288 * (distance()) + -1.95374)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0165581 * (0.904313 - exp(-0.206335 * (enclose() + 8.99114) - -0.0720269 * (enclose() + -3.86018) * (enclose() + -3.86018)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.036174 * (1 - exp(-0.632733 * (distance() + 0.0197621)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0371162
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91411 - 1.14383 * (distance())) + 0.00724364 / pow(distance() , 1.66701)) * 1.39181 * pow((width1() + width2()) / 2 , 0.0448741)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495976
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00709514 * (distance()) + 0.201546) * (0.564903 - exp(-(1.17783 * (distance()) + 1.0172) * (enclose() + 0.455213 * (distance()) + 0.648814) - (0.00625353 * (distance()) + -0.32588) * (enclose() + 1.454 * (distance()) + 0.737585) * (enclose() + 1.454 * (distance()) + 0.737585)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0830352 * (0.564903 - exp(-6.90635 * (enclose() + 2.92488) - -0.294612 * (enclose() + 8.00758) * (enclose() + 8.00758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0146953 * (1 - exp(-0.839699 * (distance() + -0.0628989)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151846
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.86055 - 0.791515 * (distance())) + 0.010838 / pow(distance() , 1.50245)) * 1.28103 * pow((width1() + width2()) / 2 , 0.0534518)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0273849
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00568176 * (distance()) + 0.0911377) * (0.429515 - exp(-(0.305497 * (distance()) + 0.319373) * (enclose() + 0.244579 * (distance()) + 2.38465) - (-0.00772209 * (distance()) + -0.00354054) * (enclose() + 0.796568 * (distance()) + 6.93653) * (enclose() + 0.796568 * (distance()) + 6.93653)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0597732 * (0.429515 - exp(-1.84686 * (enclose() + 3.60755) - -0.042151 * (enclose() + 10.9194) * (enclose() + 10.9194)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingmet2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0214879 * (1 - exp(-0.500809 * (distance() + 0.0145442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0213048
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.12621 - 0.979329 * (distance())) + 0.0103541 / pow(distance() , 1.48686)) * 1.38182 * pow((width1() + width2()) / 2 , 0.0735323)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0532257
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00321193 * (distance()) + 0.142626) * (0.621462 - exp(-(0.585393 * (distance()) + 0.447325) * (enclose() + -0.08276 * (distance()) + 1.10232) - (-0.054939 * (distance()) + -0.041049) * (enclose() + 0.141284 * (distance()) + 1.00059) * (enclose() + 0.141284 * (distance()) + 1.00059)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0793428 * (0.621462 - exp(-3.37429 * (enclose() + 0.68852) - -0.315744 * (enclose() + 1.70701) * (enclose() + 1.70701)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE INTRINSIC FRINGE routingmet3 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0106688 * (1 - exp(-0.733325 * (distance() + -0.00680873)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0112152
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-5.00259 - 1.21869 * (distance())) + 0.0110136 / pow(distance() , 1.05648)) * 0.924947 * pow((width1() + width2()) / 2 , 0.388207)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.08914 * (1 - exp(-1.60725 * (distance() + 0.540905)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.097991
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00637868 * (distance()) + 0.127323) * (1.11894 - exp(-(-0.651 * (distance()) + 5.46941) * (enclose() + -0.0692445 * (distance()) + 0.723153) - (0.00107881 * (distance()) + -0.50793) * (enclose() + 0.337062 * (distance()) + -2.59359) * (enclose() + 0.337062 * (distance()) + -2.59359)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.08914 * (1 - exp(-1.60725 * (distance() + 0.540905)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0796082 * (1.11894 - exp(-2.21441 * (enclose() + 0.376931) - -0.502536 * (enclose() + -0.90828) * (enclose() + -0.90828)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.34122 - 1.00186 * (distance())) + 0.0149695 / pow(distance() , 1.06012)) * 2.07535 * pow((width1() + width2()) / 2 , 0.124887)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0606031 * (1 - exp(-0.869275 * (distance() + 0.136267)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0681194
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0170572 * (distance()) + 0.247987) * (0.697173 - exp(-(0.630212 * (distance()) + 0.626792) * (enclose() + 0.301594 * (distance()) + 0.61224) - (0.00817141 * (distance()) + -0.221502) * (enclose() + 1.17586 * (distance()) + 0.489297) * (enclose() + 1.17586 * (distance()) + 0.489297)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0606031 * (1 - exp(-0.869275 * (distance() + 0.136267)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0813505 * (0.697173 - exp(-3.77785 * (enclose() + 2.12021) - -0.180645 * (enclose() + 6.3686) * (enclose() + 6.3686)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.26476 - 0.516981 * (distance())) + 0.0311268 / pow(distance() , 0.874981)) * 1.40281 * pow((width1() + width2()) / 2 , 0.137677)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0387844 * (1 - exp(-0.421096 * (distance() + 0.282879)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.045958
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0204367 * (distance()) + 0.233086) * (0.715292 - exp(-(0.246235 * (distance()) + 0.407593) * (enclose() + 0.838261 * (distance()) + 2.05812) - (0.00048205 * (distance()) + -0.0426606) * (enclose() + 2.38684 * (distance()) + 3.65792) * (enclose() + 2.38684 * (distance()) + 3.65792)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0387844 * (1 - exp(-0.421096 * (distance() + 0.282879)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0654512 * (0.715292 - exp(-1.63877 * (enclose() + 6.24943) - -0.0402503 * (enclose() + 15.5921) * (enclose() + 15.5921)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.76404 - 0.241122 * (distance())) + 0.0312727 / pow(distance() , 0.893195)) * 1.31924 * pow((width1() + width2()) / 2 , 0.181248)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0326632 * (1 - exp(-0.254861 * (distance() + 0.808996)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0401856
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00193543 * (distance()) + 0.072975) * (0.643839 - exp(-(0.103213 * (distance()) + 0.120972) * (enclose() + -0.19606 * (distance()) + 2.44602) - (-0.00524952 * (distance()) + 0.00053777) * (enclose() + -0.0542608 * (distance()) + 4.26425) * (enclose() + -0.0542608 * (distance()) + 4.26425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0326632 * (1 - exp(-0.254861 * (distance() + 0.808996)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0413261 * (0.643839 - exp(-0.637037 * (enclose() + 1.46572) - -0.0257098 * (enclose() + 3.99295) * (enclose() + 3.99295)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.83303 - 0.337891 * (distance())) + 0.0510728 / pow(distance() , 0.92459)) * 1.9361 * pow((width1() + width2()) / 2 , 0.0675897)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0665166 * (1 - exp(-0.0645997 * (distance() + 0.840154)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.039857
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00632068 * (distance()) + 0.0117873) * (0.88357 - exp(-(0.265222 * (distance()) + 0.144155) * (enclose() + -0.881917 * (distance()) + 0.0632331) - (0.0110067 * (distance()) + -0.00540432) * (enclose() + -0.897645 * (distance()) + -7.09166) * (enclose() + -0.897645 * (distance()) + -7.09166)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0665166 * (1 - exp(-0.0645997 * (distance() + 0.840154)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0204312 * (0.88357 - exp(-1.36418 * (enclose() + -3.99359) - 0.0452265 * (enclose() + -11.2208) * (enclose() + -11.2208)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.51236 - 1.14531 * (distance())) + 0.0128618 / pow(distance() , 1.1202)) * 2.06696 * pow((width1() + width2()) / 2 , 0.144038)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0844621 * (1 - exp(-1.11757 * (distance() + 0.296732)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0922484
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00858241 * (distance()) + 0.174322) * (0.739488 - exp(-(0.21416 * (distance()) + 1.42363) * (enclose() + 0.0450344 * (distance()) + 0.0372621) - (-0.0145291 * (distance()) + 0.074824) * (enclose() + 0.496919 * (distance()) + 2.8953) * (enclose() + 0.496919 * (distance()) + 2.8953)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0844621 * (1 - exp(-1.11757 * (distance() + 0.296732)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.108617 * (0.739488 - exp(-2.49443 * (enclose() + 0.262434) - 0.0021785 * (enclose() + 5.3799) * (enclose() + 5.3799)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.20581 - 0.581823 * (distance())) + 0.0298732 / pow(distance() , 0.898403)) * 1.39068 * pow((width1() + width2()) / 2 , 0.137134)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0410339 * (1 - exp(-0.475403 * (distance() + 0.22715)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.048127
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0338137 * (distance()) + 0.404305) * (0.349708 - exp(-(0.197217 * (distance()) + 0.59642) * (enclose() + 0.16461 * (distance()) + 2.79409) - (0.00280315 * (distance()) + -0.0703893) * (enclose() + 1.15095 * (distance()) + 3.16371) * (enclose() + 1.15095 * (distance()) + 3.16371)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0410339 * (1 - exp(-0.475403 * (distance() + 0.22715)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.117618 * (0.349708 - exp(-1.5825 * (enclose() + 3.61714) - -0.0563736 * (enclose() + 8.91846) * (enclose() + 8.91846)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.78919 - 0.257058 * (distance())) + 0.0311346 / pow(distance() , 0.89549)) * 1.31682 * pow((width1() + width2()) / 2 , 0.181851)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0339294 * (1 - exp(-0.272355 * (distance() + 0.742199)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0412897
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00680582 * (distance()) + 0.118765) * (0.313718 - exp(-(0.0491694 * (distance()) + 0.130942) * (enclose() + -1.76148 * (distance()) + 5.19701) - (0.00014352 * (distance()) + 0.00237084) * (enclose() + 3.70423 * (distance()) + 10.9017) * (enclose() + 3.70423 * (distance()) + 10.9017)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0339294 * (1 - exp(-0.272355 * (distance() + 0.742199)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.076397 * (0.313718 - exp(-0.376789 * (enclose() + -3.61039) - 0.00308844 * (enclose() + 29.4228) * (enclose() + 29.4228)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.78974 - 0.345623 * (distance())) + 0.0501977 / pow(distance() , 0.93572)) * 1.93184 * pow((width1() + width2()) / 2 , 0.0665879)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0685101 * (1 - exp(-0.0670931 * (distance() + 0.794408)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0409605
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00411421 * (distance()) + 0.0222994) * (0.982613 - exp(-(0.124256 * (distance()) + 0.0964609) * (enclose() + -0.686012 * (distance()) + 0.487762) - (0.00219139 * (distance()) + -0.0021316) * (enclose() + -0.983822 * (distance()) + -11.1014) * (enclose() + -0.983822 * (distance()) + -11.1014)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0685101 * (1 - exp(-0.0670931 * (distance() + 0.794408)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0206124 * (0.982613 - exp(-0.668038 * (enclose() + -2.66789) - 0.00794879 * (enclose() + -15.627) * (enclose() + -15.627)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.44345 - 0.961043 * (distance())) + 0.0190338 / pow(distance() , 1.00669)) * 1.76914 * pow((width1() + width2()) / 2 , 0.151072)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0584152 * (1 - exp(-0.836219 * (distance() + 0.142758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0668232
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0186823 * (distance()) + 0.36092) * (0.407099 - exp(-(0.517936 * (distance()) + 0.802604) * (enclose() + 0.155015 * (distance()) + 1.23135) - (0.0112802 * (distance()) + -0.228748) * (enclose() + 0.951289 * (distance()) + 0.829262) * (enclose() + 0.951289 * (distance()) + 0.829262)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0584152 * (1 - exp(-0.836219 * (distance() + 0.142758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.133754 * (0.407099 - exp(-3.39228 * (enclose() + 2.00643) - -0.172347 * (enclose() + 5.58571) * (enclose() + 5.58571)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.99645 - 0.328392 * (distance())) + 0.0285491 / pow(distance() , 0.903375)) * 1.43541 * pow((width1() + width2()) / 2 , 0.177039)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0393187 * (1 - exp(-0.376361 * (distance() + 0.452214)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479303
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0156531 * (distance()) + 0.126281) * (0.301231 - exp(-(-0.0808611 * (distance()) + 0.124944) * (enclose() + 3.07081 * (distance()) + 4.56842) - (0.0008519 * (distance()) + 0.0323541) * (enclose() + 2.1363 * (distance()) + 3.27874) * (enclose() + 2.1363 * (distance()) + 3.27874)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0393187 * (1 - exp(-0.376361 * (distance() + 0.452214)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.102273 * (0.301231 - exp(0.279362 * (enclose() + 19.9225) - 0.0366136 * (enclose() + 13.9602) * (enclose() + 13.9602)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.62004 - 0.383857 * (distance())) + 0.0475204 / pow(distance() , 0.97197)) * 1.91789 * pow((width1() + width2()) / 2 , 0.0630405)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0692095 * (1 - exp(-0.0900198 * (distance() + 0.611794)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0464775
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00576489 * (distance()) + 0.125275) * (1.01771 - exp(-(0.0123402 * (distance()) + 0.14025) * (enclose() + 0.0705468 * (distance()) + 0.379771) - (-0.00126363 * (distance()) + -0.0143742) * (enclose() + -0.660481 * (distance()) + 3.01228) * (enclose() + -0.660481 * (distance()) + 3.01228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0692095 * (1 - exp(-0.0900198 * (distance() + 0.611794)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0493783 * (1.01771 - exp(-0.197015 * (enclose() + 0.704286) - -0.0201869 * (enclose() + -0.0259326) * (enclose() + -0.0259326)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.32218 - 0.460342 * (distance())) + 0.0252233 / pow(distance() , 1.01337)) * 1.36038 * pow((width1() + width2()) / 2 , 0.203245)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.059503 * (1 - exp(-0.769384 * (distance() + 0.248254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0699591
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00113668 * (distance()) + 0.269841) * (0.391614 - exp(-(0.398024 * (distance()) + 0.852515) * (enclose() + -0.0535901 * (distance()) + 1.40373) - (-0.00038229 * (distance()) + -0.175474) * (enclose() + 0.38665 * (distance()) + 1.18296) * (enclose() + 0.38665 * (distance()) + 1.18296)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.059503 * (1 - exp(-0.769384 * (distance() + 0.248254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.137762 * (0.391614 - exp(-2.84264 * (enclose() + 1.13578) - -0.177385 * (enclose() + 3.11621) * (enclose() + 3.11621)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.40021 - 0.511879 * (distance())) + 0.00329924 / pow(distance() , 3.5412)) * 2.101 * pow((width1() + width2()) / 2 , 0.0573586)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0671841 * (1 - exp(-0.175369 * (distance() + 0.32051)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.058199
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0318234 * (distance()) + 0.633796) * (0.226662 - exp(-(0.0797746 * (distance()) + 0.476108) * (enclose() + -0.101113 * (distance()) + 4.35349) - (0.00237161 * (distance()) + -0.049964) * (enclose() + 0.551418 * (distance()) + 3.66128) * (enclose() + 0.551418 * (distance()) + 3.66128)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0671841 * (1 - exp(-0.175369 * (distance() + 0.32051)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.243704 * (0.226662 - exp(-0.843071 * (enclose() + 3.88837) - -0.0390546 * (enclose() + 6.1978) * (enclose() + 6.1978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.87588 - 0.633155 * (distance())) + 0.0315388 / pow(distance() , 1.28594)) * 1.71019 * pow((width1() + width2()) / 2 , 0.0624372)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0921218 * (1 - exp(-0.460974 * (distance() + 0.163661)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0952909
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0215115 * (distance()) + 0.338812) * (0.710716 - exp(-(0.331219 * (distance()) + 0.360998) * (enclose() + 0.0710321 * (distance()) + 0.894836) - (0.0105761 * (distance()) + -0.168526) * (enclose() + 0.701669 * (distance()) + 0.322147) * (enclose() + 0.701669 * (distance()) + 0.322147)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0921218 * (1 - exp(-0.460974 * (distance() + 0.163661)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.11993 * (0.710716 - exp(-1.88461 * (enclose() + 1.22158) - -0.119876 * (enclose() + 3.54982) * (enclose() + 3.54982)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-0.278016 - 10.5416 * (distance())) + 0.00073225 / pow(distance() , 2.05737)) * 0.321054 * pow((width1() + width2()) / 2 , -0.0105425)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0356963 * (1 - exp(-0.0837853 * (distance() + 35.293)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0349583
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00011729 * (distance()) + 0.0775906) * (0.869097 - exp(-(1.07321 * (distance()) + 4.51126) * (enclose() + -0.0113258 * (distance()) + 0.0945618) - (1.08975 * (distance()) + 4.55044) * (enclose() + -0.0101125 * (distance()) + 0.316133) * (enclose() + -0.0101125 * (distance()) + 0.316133)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0356963 * (1 - exp(-0.0837853 * (distance() + 35.293)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0390885 * (0.869097 - exp(-9.87731 * (enclose() + 0.0379328) - 9.99919 * (enclose() + 0.26557) * (enclose() + 0.26557)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet1 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0586905 * (1 - exp(-0.150143 * (distance() + 25.5192)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0592104
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00013864 * (distance()) + 0.09846) * (1.16224 - exp(-(0.116386 * (distance()) + 5.96574) * (enclose() + 0.0474842 * (distance()) + 0.882643) - (0.0219531 * (distance()) + -2.98041) * (enclose() + -0.05665 * (distance()) + -1.24646) * (enclose() + -0.05665 * (distance()) + -1.24646)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0586905 * (1 - exp(-0.150143 * (distance() + 25.5192)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0495766 * (1.16224 - exp(-6.54767 * (enclose() + 1.12006) - -2.87064 * (enclose() + -1.52971) * (enclose() + -1.52971)) + 8.61331e-06)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.30687 - 2.33038 * (distance())) + 0.00207102 / pow(distance() , 1.87447)) * 0.90289 * pow((width1() + width2()) / 2 , 0.0914307)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00744179 * (1 - exp(-2.28542 * (distance() + 0.0543648)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0078002
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00027718 * (distance()) + 0.0205277) * (0.747693 - exp(-(-0.014985 * (distance()) + 1.06584) * (enclose() + 0.794627 * (distance()) + -0.177667) - (0.0138086 * (distance()) + -0.131572) * (enclose() + -1.38097 * (distance()) + 0.129239) * (enclose() + -1.38097 * (distance()) + 0.129239)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00744179 * (1 - exp(-2.28542 * (distance() + 0.0543648)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0095709 * (0.747693 - exp(-0.990915 * (enclose() + 3.79547) - -0.062529 * (enclose() + -6.77561) * (enclose() + -6.77561)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet2 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0775868 * (1 - exp(-2.42179 * (distance() + 0.269013)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0807054
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00164012 * (distance()) + 0.127582) * (1.14382 - exp(-(0.982349 * (distance()) + 1.50244) * (enclose() + -0.231162 * (distance()) + 1.069) - (1.1766 * (distance()) + -5.04587) * (enclose() + -0.125851 * (distance()) + -0.498729) * (enclose() + -0.125851 * (distance()) + -0.498729)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0775868 * (1 - exp(-2.42179 * (distance() + 0.269013)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0678913 * (1.14382 - exp(-6.41418 * (enclose() + -0.08681) - 0.83713 * (enclose() + -1.12798) * (enclose() + -1.12798)) + 8.82833e-05)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.45437 - 1.49675 * (distance())) + 0.00617275 / pow(distance() , 1.59886)) * 0.630251 * pow((width1() + width2()) / 2 , 0.197215)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00441348 * (1 - exp(-1.74923 * (distance() + 0.165899)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00475185
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00034027 * (distance()) + 0.0115484) * (0.845701 - exp(-(0.0224463 * (distance()) + 0.450839) * (enclose() + 1.23258 * (distance()) + -0.4878) - (0.00284678 * (distance()) + -0.0451249) * (enclose() + -1.69575 * (distance()) + -0.71865) * (enclose() + -1.69575 * (distance()) + -0.71865)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00441348 * (1 - exp(-1.74923 * (distance() + 0.165899)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00492352 * (0.845701 - exp(-0.563071 * (enclose() + 5.6751) - -0.030891 * (enclose() + -9.1974) * (enclose() + -9.1974)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet3 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0820794 * (1 - exp(-1.89479 * (distance() + 0.410513)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0867029
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00401027 * (distance()) + 0.125152) * (1.15175 - exp(-(-0.094523 * (distance()) + 3.70227) * (enclose() + -0.0913475 * (distance()) + 0.724685) - (0.30565 * (distance()) + -2.17114) * (enclose() + 0.0351625 * (distance()) + -1.00408) * (enclose() + 0.0351625 * (distance()) + -1.00408)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0820794 * (1 - exp(-1.89479 * (distance() + 0.410513)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0726017 * (1.15175 - exp(-3.22966 * (enclose() + 0.267948) - -0.64289 * (enclose() + -0.828268) * (enclose() + -0.828268)) + 0.000282895)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet4
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.88157 - 1.22546 * (distance())) + 0.00796952 / pow(distance() , 1.41539)) * 0.69899 * pow((width1() + width2()) / 2 , 0.257942)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00979945 * (1 - exp(-0.0287068 * (distance() + 9.66038)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00344698
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00292518 * (distance()) + 0.0422184) * (0.938303 - exp(-(-0.00571363 * (distance()) + 0.0928949) * (enclose() + 0.531128 * (distance()) + -0.143759) - (0.0013631 * (distance()) + -0.0167264) * (enclose() + -0.188228 * (distance()) + 0.107631) * (enclose() + -0.188228 * (distance()) + 0.107631)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00979945 * (1 - exp(-0.0287068 * (distance() + 9.66038)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0137963 * (0.938303 - exp(-0.0643268 * (enclose() + 2.51188) - -0.0099109 * (enclose() + -0.833509) * (enclose() + -0.833509)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet4
//
// removed
// CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet4 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0839593 * (1 - exp(-1.74927 * (distance() + 0.47025)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0896355
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.0054595 * (distance()) + 0.126965) * (1.11927 - exp(-(-0.641309 * (distance()) + 5.71917) * (enclose() + -0.0652208 * (distance()) + 0.642416) - (-0.0022259 * (distance()) + -0.554541) * (enclose() + 0.316401 * (distance()) + -2.37768) * (enclose() + 0.316401 * (distance()) + -2.37768)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0839593 * (1 - exp(-1.74927 * (distance() + 0.47025)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0771312 * (1.11927 - exp(-2.51262 * (enclose() + 0.316312) - -0.56567 * (enclose() + -0.795675) * (enclose() + -0.795675)) + 0.00053904)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.50088 - 2.14166 * (distance())) + 0.0023672 / pow(distance() , 1.98603)) * 1.57052 * pow((width1() + width2()) / 2 , 0.00423969)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0370742 * (1 - exp(-1.67422 * (distance() + -0.100632)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.038031
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00269484 * (distance()) + 0.609502) * (0.121967 - exp(-(-0.212504 * (distance()) + 0.0490324) * (enclose() + 7.74396 * (distance()) + 10.1085) - (0.00166371 * (distance()) + 0.0727015) * (enclose() + 4.19838 * (distance()) + 4.42875) * (enclose() + 4.19838 * (distance()) + 4.42875)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0370742 * (1 - exp(-1.67422 * (distance() + -0.100632)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.298014 * (0.121967 - exp(1.01349 * (enclose() + 48.8283) - 0.0810201 * (enclose() + 25.4207) * (enclose() + 25.4207)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0399387 * (1 - exp(-1.69578 * (distance() + -0.0881041)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0408421
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00522216 * (distance()) + 0.108124) * (0.957804 - exp(-(3.6918 * (distance()) + 1.3055) * (enclose() + 1.73858 * (distance()) + 0.104184) - (0.00151171 * (distance()) + -0.42545) * (enclose() + 3.95048 * (distance()) + 0.616575) * (enclose() + 3.95048 * (distance()) + 0.616575)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0399387 * (1 - exp(-1.69578 * (distance() + -0.0881041)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0410066 * (0.957804 - exp(-19.7645 * (enclose() + 8.79708) - -0.417891 * (enclose() + 20.369) * (enclose() + 20.369)) + 0.000154516)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.84132 - 1.31986 * (distance())) + 0.00581648 / pow(distance() , 1.74203)) * 1.4617 * pow((width1() + width2()) / 2 , 0.0414683)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0176941 * (1 - exp(-0.939576 * (distance() + -0.0678801)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.018389
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-6.88574e-05 * (distance()) + 0.0341579) * (1.003 - exp(-(-0.00083511 * (distance()) + 1.03467) * (enclose() + 0.0516752 * (distance()) + 0.394697) - (0.0663903 * (distance()) + -0.196954) * (enclose() + -0.291488 * (distance()) + 1.8445) * (enclose() + -0.291488 * (distance()) + 1.8445)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0176941 * (1 - exp(-0.939576 * (distance() + -0.0678801)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0169068 * (1.003 - exp(-1.03049 * (enclose() + 0.653073) - 0.134998 * (enclose() + 0.38706) * (enclose() + 0.38706)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0482008 * (1 - exp(-1.11848 * (distance() + 0.00553758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0500856
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00986422 * (distance()) + 0.170167) * (0.790507 - exp(-(1.59173 * (distance()) + 0.97494) * (enclose() + 0.895078 * (distance()) + 0.37334) - (0.00301388 * (distance()) + -0.295317) * (enclose() + 2.31672 * (distance()) + 0.761281) * (enclose() + 2.31672 * (distance()) + 0.761281)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0482008 * (1 - exp(-1.11848 * (distance() + 0.00553758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.060423 * (0.790507 - exp(-8.93359 * (enclose() + 4.84873) - -0.280248 * (enclose() + 12.3449) * (enclose() + 12.3449)) + 0.00061332)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1,routingmet4
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.04854 - 1.09135 * (distance())) + 0.00941581 / pow(distance() , 1.51692)) * 1.4034 * pow((width1() + width2()) / 2 , 0.0668814)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0120134 * (1 - exp(-0.781937 * (distance() + -0.0124425)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0126763
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0001744 * (distance()) + 0.0315794) * (0.728533 - exp(-(-0.0257081 * (distance()) + 0.238289) * (enclose() + 5.92781 * (distance()) + -1.65107) - (-0.0132219 * (distance()) + 0.0059364) * (enclose() + 0.71005 * (distance()) + -9.39413) * (enclose() + 0.71005 * (distance()) + -9.39413)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0120134 * (1 - exp(-0.781937 * (distance() + -0.0124425)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0162257 * (0.728533 - exp(-0.109748 * (enclose() + 27.988) - -0.0601731 * (enclose() + -5.84388) * (enclose() + -5.84388)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0518482 * (1 - exp(-0.971509 * (distance() + 0.0585862)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0545623
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0141091 * (distance()) + 0.224088) * (0.669733 - exp(-(1.02632 * (distance()) + 0.935259) * (enclose() + 0.548695 * (distance()) + 0.616336) - (0.00508777 * (distance()) + -0.260095) * (enclose() + 1.6492 * (distance()) + 0.901347) * (enclose() + 1.6492 * (distance()) + 0.901347)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0518482 * (1 - exp(-0.971509 * (distance() + 0.0585862)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0767713 * (0.669733 - exp(-6.06686 * (enclose() + 3.35981) - -0.234656 * (enclose() + 9.14735) * (enclose() + 9.14735)) + 0.00136923)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.85208 - 1.29316 * (distance())) + 0.00531446 / pow(distance() , 1.78907)) * 1.48538 * pow((width1() + width2()) / 2 , 0.0298862)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0456281 * (1 - exp(-1.08989 * (distance() + -0.0188415)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0470889
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00707534 * (distance()) + 0.20091) * (0.536673 - exp(-(1.7982 * (distance()) + 1.48047) * (enclose() + 0.816792 * (distance()) + 0.765532) - (0.00334676 * (distance()) + -0.349174) * (enclose() + 2.17361 * (distance()) + 1.32368) * (enclose() + 2.17361 * (distance()) + 1.32368)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0456281 * (1 - exp(-1.08989 * (distance() + -0.0188415)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0827666 * (0.536673 - exp(-10.4715 * (enclose() + 4.84949) - -0.33244 * (enclose() + 12.1917) * (enclose() + 12.1917)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0181645 * (1 - exp(-0.949971 * (distance() + -0.0899595)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0187517
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00890232 * (distance()) + 0.14889) * (0.372079 - exp(-(0.17257 * (distance()) + 0.515051) * (enclose() + -0.18039 * (distance()) + 1.96121) - (-0.00605953 * (distance()) + -0.0801381) * (enclose() + 0.0573357 * (distance()) + 1.48651) * (enclose() + 0.0573357 * (distance()) + 1.48651)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0181645 * (1 - exp(-0.949971 * (distance() + -0.0899595)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0521892 * (0.372079 - exp(-1.3779 * (enclose() + 1.05926) - -0.110436 * (enclose() + 1.77319) * (enclose() + 1.77319)) + 0.000568049)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78865 - 0.886673 * (distance())) + 0.00910936 / pow(distance() , 1.59872)) * 1.28514 * pow((width1() + width2()) / 2 , 0.0424621)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0251546 * (1 - exp(-0.590225 * (distance() + -0.0330192)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0252024
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0047585 * (distance()) + 0.0931067) * (0.395583 - exp(-(-0.0832686 * (distance()) + 0.0744424) * (enclose() + 5.21571 * (distance()) + 7.22604) - (-0.00071339 * (distance()) + 0.0395184) * (enclose() + 3.38958 * (distance()) + 2.16131) * (enclose() + 3.38958 * (distance()) + 2.16131)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0251546 * (1 - exp(-0.590225 * (distance() + -0.0330192)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0584496 * (0.395583 - exp(0.341901 * (enclose() + 33.3046) - 0.0359515 * (enclose() + 19.1092) * (enclose() + 19.1092)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0254096 * (1 - exp(-0.594901 * (distance() + -0.0296593)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0255591
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0117867 * (distance()) + 0.133461) * (0.83208 - exp(-(0.971338 * (distance()) + 0.54842) * (enclose() + 3.07214 * (distance()) + 1.32041) - (0.00010045 * (distance()) + -0.0652559) * (enclose() + 6.82061 * (distance()) + 3.14179) * (enclose() + 6.82061 * (distance()) + 3.14179)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0254096 * (1 - exp(-0.594901 * (distance() + -0.0296593)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0372637 * (0.83208 - exp(-5.40511 * (enclose() + 16.6811) - -0.0647537 * (enclose() + 37.2448) * (enclose() + 37.2448)) + 0.00179254)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.0181 - 1.05244 * (distance())) + 0.00919141 / pow(distance() , 1.55193)) * 1.36664 * pow((width1() + width2()) / 2 , 0.0615969)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0494895 * (1 - exp(-0.92556 * (distance() + 0.0430036)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0516761
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0205621 * (distance()) + 0.587715) * (0.139362 - exp(-(-0.080174 * (distance()) + -0.00404507) * (enclose() + 13.4948 * (distance()) + 21.1802) - (0.00061771 * (distance()) + 0.0374595) * (enclose() + 4.75801 * (distance()) + 7.15762) * (enclose() + 4.75801 * (distance()) + 7.15762)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0494895 * (1 - exp(-0.92556 * (distance() + 0.0430036)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.345263 * (0.139362 - exp(0.404915 * (enclose() + 88.6542) - 0.0405481 * (enclose() + 30.9477) * (enclose() + 30.9477)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.012358 * (1 - exp(-0.773724 * (distance() + -0.0319257)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0129174
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00342606 * (distance()) + 0.0783936) * (0.389137 - exp(-(0.070223 * (distance()) + 0.125271) * (enclose() + -2.74561 * (distance()) + 3.34294) - (0.00010205 * (distance()) + 0.00223777) * (enclose() + 7.05556 * (distance()) + 11.2974) * (enclose() + 7.05556 * (distance()) + 11.2974)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.012358 * (1 - exp(-0.773724 * (distance() + -0.0319257)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0306316 * (0.389137 - exp(-0.476386 * (enclose() + -10.3851) - 0.00274802 * (enclose() + 46.5752) * (enclose() + 46.5752)) + 0.00133709)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.44689 - 2.53366 * (distance())) + 0.00173579 / pow(distance() , 2.07533)) * 1.5463 * pow((width1() + width2()) / 2 , 0.00407902)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0329468 * (1 - exp(-1.98403 * (distance() + -0.10679)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0336755
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00396564 * (distance()) + 0.172736) * (0.41743 - exp(-(0.895844 * (distance()) + 1.39149) * (enclose() + -0.0503947 * (distance()) + 0.750627) - (-0.0404482 * (distance()) + -0.433657) * (enclose() + 0.167198 * (distance()) + 0.606012) * (enclose() + 0.167198 * (distance()) + 0.606012)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0329468 * (1 - exp(-1.98403 * (distance() + -0.10679)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0764539 * (0.41743 - exp(-5.87071 * (enclose() + 0.498654) - -0.635898 * (enclose() + 1.442) * (enclose() + 1.442)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0633345 * (1 - exp(-2.17803 * (distance() + 0.0284393)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0646204
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00021551 * (distance()) + 0.12658) * (0.993084 - exp(-(-2.01675 * (distance()) + 9.67366) * (enclose() + -0.115808 * (distance()) + 0.435251) - (1.32093 * (distance()) + -3.4165) * (enclose() + -0.13339 * (distance()) + 1.08172) * (enclose() + -0.13339 * (distance()) + 1.08172)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0633345 * (1 - exp(-2.17803 * (distance() + 0.0284393)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0627512 * (0.993084 - exp(0.41009 * (enclose() + -0.143789) - 3.18815 * (enclose() + 0.41477) * (enclose() + 0.41477)) + 9.52556e-05)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.85242 - 1.50972 * (distance())) + 0.00503212 / pow(distance() , 1.82079)) * 1.38727 * pow((width1() + width2()) / 2 , 0.0450366)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0151193 * (1 - exp(-1.15179 * (distance() + -0.0772718)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0156727
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00107316 * (distance()) + 0.0414089) * (0.849163 - exp(-(0.00115858 * (distance()) + 0.434726) * (enclose() + 1.20754 * (distance()) + -0.408285) - (0.0143718 * (distance()) + -0.167931) * (enclose() + -0.857905 * (distance()) + 0.135028) * (enclose() + -0.857905 * (distance()) + 0.135028)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0151193 * (1 - exp(-1.15179 * (distance() + -0.0772718)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0180215 * (0.849163 - exp(-0.440519 * (enclose() + 5.62941) - -0.096072 * (enclose() + -4.1545) * (enclose() + -4.1545)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0724627 * (1 - exp(-1.43378 * (distance() + 0.160215)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0745127
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00727196 * (distance()) + 0.258781) * (0.627426 - exp(-(1.56695 * (distance()) + 1.87374) * (enclose() + 0.178918 * (distance()) + 0.386586) - (0.0312103 * (distance()) + -0.781517) * (enclose() + 0.78049 * (distance()) + 0.379264) * (enclose() + 0.78049 * (distance()) + 0.379264)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0724627 * (1 - exp(-1.43378 * (distance() + 0.160215)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.111211 * (0.627426 - exp(-9.70849 * (enclose() + 1.28118) - -0.625466 * (enclose() + 4.28171) * (enclose() + 4.28171)) + 0.00040202)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet4
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.14497 - 1.20795 * (distance())) + 0.00829857 / pow(distance() , 1.59349)) * 1.36403 * pow((width1() + width2()) / 2 , 0.0814906)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0100798 * (1 - exp(-0.959261 * (distance() + -0.0143944)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0106975
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00061797 * (distance()) + 0.0257636) * (0.873504 - exp(-(0.0721547 * (distance()) + 0.274838) * (enclose() + 0.926717 * (distance()) + -0.561258) - (-8.02883e-05 * (distance()) + -0.0133472) * (enclose() + -2.56022 * (distance()) + 1.55203) * (enclose() + -2.56022 * (distance()) + 1.55203)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0100798 * (1 - exp(-0.959261 * (distance() + -0.0143944)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0113369 * (0.873504 - exp(-0.635611 * (enclose() + 4.07233) - -0.0137486 * (enclose() + -11.2491) * (enclose() + -11.2491)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0761089 * (1 - exp(-1.2414 * (distance() + 0.234572)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0793423
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00375599 * (distance()) + 0.202307) * (0.675397 - exp(-(0.522729 * (distance()) + 1.37917) * (enclose() + -0.0199402 * (distance()) + 0.531675) - (-0.025416 * (distance()) + 0.00694564) * (enclose() + 0.240172 * (distance()) + 1.51908) * (enclose() + 0.240172 * (distance()) + 1.51908)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0761089 * (1 - exp(-1.2414 * (distance() + 0.234572)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.110543 * (0.675397 - exp(-3.99282 * (enclose() + 0.431974) - -0.120134 * (enclose() + 2.71994) * (enclose() + 2.71994)) + 0.000955436)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.75969 - 1.39531 * (distance())) + 0.00424647 / pow(distance() , 1.89431)) * 1.4886 * pow((width1() + width2()) / 2 , 0.024683)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0441086 * (1 - exp(-1.15545 * (distance() + -0.0381798)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0448798
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (7.56257e-05 * (distance()) + 0.123141) * (0.703091 - exp(-(0.697963 * (distance()) + 0.400345) * (enclose() + -0.0650312 * (distance()) + 0.847824) - (-0.0818277 * (distance()) + 0.0102135) * (enclose() + 0.0920123 * (distance()) + 1.12901) * (enclose() + 0.0920123 * (distance()) + 1.12901)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0441086 * (1 - exp(-1.15545 * (distance() + -0.0381798)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0617596 * (0.703091 - exp(-3.89016 * (enclose() + 0.522668) - -0.398925 * (enclose() + 1.58907) * (enclose() + 1.58907)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0202885 * (1 - exp(-1.03176 * (distance() + -0.108489)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0206525
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0130239 * (distance()) + 0.543902) * (0.0816356 - exp(-(0.0963081 * (distance()) + 0.214844) * (enclose() + -4.04229 * (distance()) + 6.14366) - (0.00064078 * (distance()) + 0.00663372) * (enclose() + 4.8146 * (distance()) + 11.6565) * (enclose() + 4.8146 * (distance()) + 11.6565)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0202885 * (1 - exp(-1.03176 * (distance() + -0.108489)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.239391 * (0.0816356 - exp(-0.696384 * (enclose() + -14.0678) - 0.00983762 * (enclose() + 35.7295) * (enclose() + 35.7295)) + 0.000382859)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.81794 - 0.942616 * (distance())) + 0.00731592 / pow(distance() , 1.68045)) * 1.38548 * pow((width1() + width2()) / 2 , 0.0377895)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0237586 * (1 - exp(-0.642628 * (distance() + -0.056485)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0237298
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00115802 * (distance()) + 0.0364868) * (1.0648 - exp(-(0.0484182 * (distance()) + 0.409004) * (enclose() + -0.418805 * (distance()) + 0.562535) - (0.00609066 * (distance()) + -0.0061047) * (enclose() + -0.246792 * (distance()) + 9.8146) * (enclose() + -0.246792 * (distance()) + 9.8146)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0237586 * (1 - exp(-0.642628 * (distance() + -0.056485)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0211384 * (1.0648 - exp(-0.651095 * (enclose() + -1.53149) - 0.0243486 * (enclose() + 8.58064) * (enclose() + 8.58064)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0278221 * (1 - exp(-0.656261 * (distance() + -0.0543475)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0277779
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0133605 * (distance()) + 0.160479) * (0.67263 - exp(-(0.719118 * (distance()) + 0.733005) * (enclose() + 1.47674 * (distance()) + 1.57006) - (0.00046099 * (distance()) + -0.0870689) * (enclose() + 3.60877 * (distance()) + 3.16703) * (enclose() + 3.60877 * (distance()) + 3.16703)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0278221 * (1 - exp(-0.656261 * (distance() + -0.0543475)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0468383 * (0.67263 - exp(-4.32859 * (enclose() + 8.95376) - -0.084764 * (enclose() + 21.2109) * (enclose() + 21.2109)) + 0.0013938)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.96358 - 1.08691 * (distance())) + 0.00804018 / pow(distance() , 1.6201)) * 1.38182 * pow((width1() + width2()) / 2 , 0.0585931)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0486548 * (1 - exp(-0.949855 * (distance() + 0.0268902)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0503367
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00522487 * (distance()) + 0.192102) * (0.573171 - exp(-(0.825251 * (distance()) + 0.674108) * (enclose() + 0.193431 * (distance()) + 0.691469) - (0.0129542 * (distance()) + -0.336567) * (enclose() + 0.934098 * (distance()) + 0.183865) * (enclose() + 0.934098 * (distance()) + 0.183865)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0486548 * (1 - exp(-0.949855 * (distance() + 0.0268902)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0829888 * (0.573171 - exp(-4.80036 * (enclose() + 1.65862) - -0.271796 * (enclose() + 4.85435) * (enclose() + 4.85435)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0132594 * (1 - exp(-0.80309 * (distance() + -0.0480871)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0137667
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00172395 * (distance()) + 0.0391347) * (0.891512 - exp(-(0.0242137 * (distance()) + 0.301606) * (enclose() + 0.482945 * (distance()) + -0.188264) - (0.00502476 * (distance()) + -0.0569435) * (enclose() + -1.13579 * (distance()) + 1.06815) * (enclose() + -1.13579 * (distance()) + 1.06815)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0132594 * (1 - exp(-0.80309 * (distance() + -0.0480871)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0152575 * (0.891512 - exp(-0.422675 * (enclose() + 2.22646) - -0.0318197 * (enclose() + -4.6108) * (enclose() + -4.6108)) + 0.00109704)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.49292 - 2.10954 * (distance())) + 0.00240605 / pow(distance() , 1.92201)) * 1.54772 * pow((width1() + width2()) / 2 , 0.00470028)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0373365 * (1 - exp(-1.62183 * (distance() + -0.0933231)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.038206
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00661412 * (distance()) + 0.160227) * (0.574668 - exp(-(2.02191 * (distance()) + 1.32176) * (enclose() + 0.672211 * (distance()) + 0.421474) - (0.00663295 * (distance()) + -0.463569) * (enclose() + 1.85783 * (distance()) + 0.57754) * (enclose() + 1.85783 * (distance()) + 0.57754)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0373365 * (1 - exp(-1.62183 * (distance() + -0.0933231)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0635782 * (0.574668 - exp(-11.4313 * (enclose() + 3.78253) - -0.430404 * (enclose() + 9.86669) * (enclose() + 9.86669)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0372101 * (1 - exp(-1.65859 * (distance() + -0.1011)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0380815
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00188776 * (distance()) + 0.108961) * (0.726472 - exp(-(0.811573 * (distance()) + 0.469423) * (enclose() + -0.0550121 * (distance()) + 0.700117) - (-0.0934239 * (distance()) + 0.0210296) * (enclose() + 0.109348 * (distance()) + 0.959495) * (enclose() + 0.109348 * (distance()) + 0.959495)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0372101 * (1 - exp(-1.65859 * (distance() + -0.1011)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0497611 * (0.726472 - exp(-4.52729 * (enclose() + 0.425057) - -0.44609 * (enclose() + 1.50623) * (enclose() + 1.50623)) + 0.000171823)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.87544 - 1.27383 * (distance())) + 0.00544369 / pow(distance() , 1.79258)) * 1.4921 * pow((width1() + width2()) / 2 , 0.0379671)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0179659 * (1 - exp(-0.940849 * (distance() + -0.088947)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0186354
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00157001 * (distance()) + 0.0478803) * (0.883045 - exp(-(0.0179398 * (distance()) + 0.342895) * (enclose() + 1.17645 * (distance()) + -0.364051) - (0.00495631 * (distance()) + -0.131911) * (enclose() + -0.741458 * (distance()) + 0.13188) * (enclose() + -0.741458 * (distance()) + 0.13188)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0179659 * (1 - exp(-0.940849 * (distance() + -0.088947)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0200151 * (0.883045 - exp(-0.432594 * (enclose() + 5.5182) - -0.107129 * (enclose() + -3.57541) * (enclose() + -3.57541)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingmet1,routingmet2,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0457469 * (1 - exp(-1.08274 * (distance() + -0.0164983)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0473762
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0107025 * (distance()) + 0.22078) * (0.539067 - exp(-(1.10143 * (distance()) + 0.998337) * (enclose() + 0.452564 * (distance()) + 0.704775) - (0.00686582 * (distance()) + -0.308093) * (enclose() + 1.47232 * (distance()) + 0.767067) * (enclose() + 1.47232 * (distance()) + 0.767067)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0457469 * (1 - exp(-1.08274 * (distance() + -0.0164983)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0836338 * (0.539067 - exp(-6.50549 * (enclose() + 2.9676) - -0.273764 * (enclose() + 8.12867) * (enclose() + 8.12867)) + 0.000586364)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet1 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.87588 - 1.28229 * (distance())) + 0.00548566 / pow(distance() , 1.77939)) * 1.49577 * pow((width1() + width2()) / 2 , 0.0369456)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0457468 * (1 - exp(-1.08273 * (distance() + -0.0164972)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0473762
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00043397 * (distance()) + 0.0912952) * (1.01764 - exp(-(-0.00166134 * (distance()) + 0.304529) * (enclose() + 2.40692 * (distance()) + 0.426402) - (-0.0446204 * (distance()) + -0.107069) * (enclose() + -0.296547 * (distance()) + -1.41781) * (enclose() + -0.296547 * (distance()) + -1.41781)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0457468 * (1 - exp(-1.08273 * (distance() + -0.0164972)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0445627 * (1.01764 - exp(-0.296222 * (enclose() + 12.461) - -0.330171 * (enclose() + -2.90055) * (enclose() + -2.90055)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingmet1,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.017966 * (1 - exp(-0.940856 * (distance() + -0.0889506)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0186355
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00016199 * (distance()) + 0.0428899) * (0.803518 - exp(-(-0.0448485 * (distance()) + 1.13147) * (enclose() + 0.0504401 * (distance()) + 0.531717) - (0.0722537 * (distance()) + -0.215145) * (enclose() + -0.381628 * (distance()) + 1.83762) * (enclose() + -0.381628 * (distance()) + 1.83762)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.017966 * (1 - exp(-0.940856 * (distance() + -0.0889506)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0218499 * (0.803518 - exp(-0.907227 * (enclose() + 0.783918) - 0.146123 * (enclose() + -0.07052) * (enclose() + -0.07052)) + 0.000595268)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.49501 - 2.10408 * (distance())) + 0.00237464 / pow(distance() , 1.94188)) * 1.54637 * pow((width1() + width2()) / 2 , 0.00476484)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0373294 * (1 - exp(-1.64312 * (distance() + -0.0995558)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0381504
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00014609 * (distance()) + 0.293438) * (0.250109 - exp(-(-0.0923653 * (distance()) + 0.00291233) * (enclose() + 11.347 * (distance()) + 8.08616) - (0.0034997 * (distance()) + 0.0872532) * (enclose() + 2.78223 * (distance()) + 3.62278) * (enclose() + 2.78223 * (distance()) + 3.62278)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0373294 * (1 - exp(-1.64312 * (distance() + -0.0995558)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.147084 * (0.250109 - exp(0.458914 * (enclose() + 64.8212) - 0.104752 * (enclose() + 17.5339) * (enclose() + 17.5339)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingmet2,routingmet3,routingmet4
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0372134 * (1 - exp(-1.66243 * (distance() + -0.102814)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0380263
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00522816 * (distance()) + 0.121395) * (0.77061 - exp(-(2.04332 * (distance()) + 0.854333) * (enclose() + 0.735837 * (distance()) + 0.133558) - (0.00599271 * (distance()) + -0.446003) * (enclose() + 1.9728 * (distance()) + 0.089546) * (enclose() + 1.9728 * (distance()) + 0.089546)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0372134 * (1 - exp(-1.66243 * (distance() + -0.102814)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0476271 * (0.77061 - exp(-11.0709 * (enclose() + 3.81274) - -0.416039 * (enclose() + 9.95355) * (enclose() + 9.95355)) + 0.000164327)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0236158 * exp(-13.6781 * (distance()) - (0.701382 * (distance())) / (distance()))) / pow(distance() , 0.483916)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingpoly routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0225096 * exp(-4.9047 * (distance()) - (0.573281 * (distance())) / (distance()))) / pow(distance() , 0.125862)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingpoly routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0738238 * exp(-1.69164 * (distance()) - (1.60302 * (distance())) / (distance()))) / pow(distance() , -0.0472797)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingpoly routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.062752 * exp(-0.948443 * (distance()) - (1.64467 * (distance())) / (distance()))) / pow(distance() , -0.0196616)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet4
//
CAPACITANCE NEARBODY routingpoly routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0540065 * exp(-0.686299 * (distance()) - (1.4753 * (distance())) / (distance()))) / pow(distance() , -0.0213612)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.00359728 * exp(-7.47059 * (distance()) - (1.97621 * (distance())) / (distance()))) / pow(distance() , 1.0249)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0495721 * exp(-2.29684 * (distance()) - (0.859134 * (distance())) / (distance()))) / pow(distance() , -0.100227)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0473906 * exp(-1.11881 * (distance()) - (1.14817 * (distance())) / (distance()))) / pow(distance() , -0.0434502)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet4
//
CAPACITANCE NEARBODY routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0582638 * exp(-0.860731 * (distance()) - (1.31133 * (distance())) / (distance()))) / pow(distance() , -0.0550434)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0278881 * exp(-6.36311 * (distance()) - (-0.610764 * (distance())) / (distance()))) / pow(distance() , -0.176996)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0756433 * exp(-1.78863 * (distance()) - (1.46383 * (distance())) / (distance()))) / pow(distance() , -0.069272)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet1,routingmet4
//
CAPACITANCE NEARBODY routingmet1 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0714317 * exp(-1.02905 * (distance()) - (1.52147 * (distance())) / (distance()))) / pow(distance() , -0.0396137)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0253484 * exp(-5.95857 * (distance()) - (-0.459787 * (distance())) / (distance()))) / pow(distance() , -0.123903)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet2,routingmet4
//
CAPACITANCE NEARBODY routingmet2 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0722602 * exp(-1.73536 * (distance()) - (1.558 * (distance())) / (distance()))) / pow(distance() , -0.0480164)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet3,routingmet4
//
CAPACITANCE NEARBODY routingmet3 routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0802188 * exp(-6.68109 * (distance()) - (-0.184648 * (distance())) / (distance()))) / pow(distance() , -0.279915)
]
//
// Done by Ahmed Gharieb (ahmed_gharieb@mentor.com)
//
CAPACITANCE CROSSOVER PLATE routingpoly pdiff  MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 pdiff  MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 pdiff  MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 pdiff  MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 pdiff  MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet4 pdiff  MASK
[
    PROPERTY C
    C = 0.00815072 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0532483 * (1 - exp(-1.34175 * (distance() + 0.142997)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565925
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.04118 - 1.38136 * (distance())) + 0.0135736 / pow(distance() , 1.09077)) * 1.1381 * pow((width1() + width2()) / 2 , 0.215443)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0423004 * (1 - exp(-0.889624 * (distance() + 0.163635)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0453339
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.77614 - 0.924211 * (distance())) + 0.018676 / pow(distance() , 0.92485)) * 0.888335 * pow((width1() + width2()) / 2 , 0.233595)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0454584 * (1 - exp(-0.56303 * (distance() + 0.146881)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499153
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.20262 - 0.740624 * (distance())) + 0.0206707 / pow(distance() , 0.964583)) * 1.81054 * pow((width1() + width2()) / 2 , 0.113378)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348043 * (1 - exp(-0.340747 * (distance() + 0.425008)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0398451
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.37497 - 0.402422 * (distance())) + 0.0319658 / pow(distance() , 0.84077)) * 1.45257 * pow((width1() + width2()) / 2 , 0.143986)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0300392 * (1 - exp(-0.22725 * (distance() + 0.969108)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.03587
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.69431 - 0.214499 * (distance())) + 0.032278 / pow(distance() , 0.892845)) * 1.27911 * pow((width1() + width2()) / 2 , 0.18492)
]
CAPACITANCE CROSSOVER FRINGE routingmet4 pdiff MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0598403 * (1 - exp(-0.0631048 * (distance() + 0.921632)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0368314
    }
]
CAPACITANCE NEARBODY routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.9381 - 0.317585 * (distance())) + 0.0522599 / pow(distance() , 0.908128)) * 1.9524 * pow((width1() + width2()) / 2 , 0.0700987)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03214 - 5.62812 * (distance())) + 0.00065288 / pow(distance() , 2.12136)) * 0.849821 * pow((width1() + width2()) / 2 , 0.00833925)
]
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF pdiff MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0703073
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00072417 * (distance()) + 0.11128) * (1.18567 - exp(-(0.330112 * (distance()) + 6.01309) * (enclose() + 0.109354 * (distance()) + 0.560448) - (-0.0031829 * (distance()) + -0.935435) * (enclose() + -0.227676 * (distance()) + -1.74479) * (enclose() + -0.227676 * (distance()) + -1.74479)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0574504 * (1.18567 - exp(-7.66365 * (enclose() + 1.10722) - -0.95135 * (enclose() + -2.88317) * (enclose() + -2.88317)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0246626 * (1 - exp(-4.60903 * (distance() + -0.0717568)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0255046
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30766 - 3.57322 * (distance())) + 0.00091407 / pow(distance() , 1.8011)) * 1.04967 * pow((width1() + width2()) / 2 , 0.00862509)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0276821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00133421 * (distance()) + 0.0947724) * (0.590638 - exp(-(1.33191 * (distance()) + 1.41068) * (enclose() + -0.0410965 * (distance()) + 0.487351) - (-0.170231 * (distance()) + -0.158494) * (enclose() + 0.0927245 * (distance()) + 0.511557) * (enclose() + 0.0927245 * (distance()) + 0.511557)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0440507 * (0.590638 - exp(-8.07023 * (enclose() + 0.281868) - -1.00965 * (enclose() + 0.97518) * (enclose() + 0.97518)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329226 * (1 - exp(-3.10879 * (distance() + -0.0889366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0339331
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.94424 - 1.7925 * (distance())) + 0.00357802 / pow(distance() , 1.72832)) * 1.04296 * pow((width1() + width2()) / 2 , 0.0990315)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00059321 * (distance()) + 0.0273051) * (0.87914 - exp(-(0.0246106 * (distance()) + 0.716701) * (enclose() + 0.590434 * (distance()) + -0.181639) - (0.0126597 * (distance()) + -0.130102) * (enclose() + -1.12924 * (distance()) + 0.857723) * (enclose() + -1.12924 * (distance()) + 0.857723)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0121695 * (0.87914 - exp(-0.839754 * (enclose() + 2.77053) - -0.0668035 * (enclose() + -4.78848) * (enclose() + -4.78848)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433651 * (1 - exp(-1.69337 * (distance() + 0.0312548)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454312
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.31662 - 1.40731 * (distance())) + 0.00596482 / pow(distance() , 1.50427)) * 1.1051 * pow((width1() + width2()) / 2 , 0.151405)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751819
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00056907 * (distance()) + 0.0175334) * (0.928289 - exp(-(0.0588486 * (distance()) + 0.340669) * (enclose() + 0.813125 * (distance()) + -0.508852) - (0.0013806 * (distance()) + -0.0300689) * (enclose() + -1.88705 * (distance()) + 0.97368) * (enclose() + -1.88705 * (distance()) + 0.97368)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00734403 * (0.928289 - exp(-0.634912 * (enclose() + 3.55677) - -0.0231659 * (enclose() + -8.46157) * (enclose() + -8.46157)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.046742 * (1 - exp(-1.46684 * (distance() + 0.0886804)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498613
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.45893 - 1.28234 * (distance())) + 0.00882865 / pow(distance() , 1.35797)) * 1.02123 * pow((width1() + width2()) / 2 , 0.176268)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00564609
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00044717 * (distance()) + 0.0169127) * (0.714796 - exp(-(-0.0229817 * (distance()) + 0.320382) * (enclose() + 2.48319 * (distance()) + -1.43302) - (-0.00996399 * (distance()) + 0.0096513) * (enclose() + 0.341381 * (distance()) + -7.59785) * (enclose() + 0.341381 * (distance()) + -7.59785)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00733842 * (0.714796 - exp(-0.205474 * (enclose() + 10.9829) - -0.0401687 * (enclose() + -5.89095) * (enclose() + -5.89095)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0482997 * (1 - exp(-1.39936 * (distance() + 0.118367)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0523407
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88841 - 3.6518 * (distance())) + 0.00073205 / pow(distance() , 2.06432)) * 1.18797 * pow((width1() + width2()) / 2 , 0.0112007)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509744
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00032081 * (distance()) + 0.0940125) * (1.02405 - exp(-(2.60904 * (distance()) + 2.12041) * (enclose() + -0.0133109 * (distance()) + 0.133988) - (-0.0195914 * (distance()) + 0.0602649) * (enclose() + 0.0248593 * (distance()) + 2.0515) * (enclose() + 0.0248593 * (distance()) + 2.0515)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0478083 * (1.02405 - exp(-15.1656 * (enclose() + 0.0674335) - -0.0376921 * (enclose() + 2.1758) * (enclose() + 2.1758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0145893 * (1 - exp(-3.1831 * (distance() + -0.0608293)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150047
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.90711 - 1.57677 * (distance())) + 0.00228218 / pow(distance() , 1.79643)) * 1.0814 * pow((width1() + width2()) / 2 , 0.0422125)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153166
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00067108 * (distance()) + 0.0382259) * (0.854775 - exp(-(-0.0195501 * (distance()) + 0.670691) * (enclose() + 0.921985 * (distance()) + -0.324567) - (0.0268178 * (distance()) + -0.25127) * (enclose() + -0.787422 * (distance()) + 0.228141) * (enclose() + -0.787422 * (distance()) + 0.228141)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0174352 * (0.854775 - exp(-0.572941 * (enclose() + 4.28536) - -0.117181 * (enclose() + -3.70897) * (enclose() + -3.70897)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284418 * (1 - exp(-1.35207 * (distance() + -0.0531136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0291869
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.06824 - 1.15439 * (distance())) + 0.0052183 / pow(distance() , 1.52648)) * 0.976453 * pow((width1() + width2()) / 2 , 0.0992957)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0100895
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00078214 * (distance()) + 0.0252269) * (0.887579 - exp(-(0.0294899 * (distance()) + 0.346855) * (enclose() + 0.955562 * (distance()) + -0.617052) - (0.00264508 * (distance()) + -0.0546774) * (enclose() + -1.26235 * (distance()) + 0.475899) * (enclose() + -1.26235 * (distance()) + 0.475899)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106581 * (0.887579 - exp(-0.494305 * (enclose() + 4.16076) - -0.041452 * (enclose() + -5.83585) * (enclose() + -5.83585)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.033175 * (1 - exp(-1.04673 * (distance() + 0.0259002)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0348207
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.19376 - 0.999264 * (distance())) + 0.00804456 / pow(distance() , 1.3321)) * 0.92757 * pow((width1() + width2()) / 2 , 0.141047)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00762268
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00032315 * (distance()) + 0.0236557) * (0.657312 - exp(-(-0.0281134 * (distance()) + 0.327877) * (enclose() + 2.83039 * (distance()) + -1.63104) - (-0.00915175 * (distance()) + 0.00847617) * (enclose() + 0.494566 * (distance()) + -8.6338) * (enclose() + 0.494566 * (distance()) + -8.6338)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.01102 * (0.657312 - exp(-0.18731 * (enclose() + 12.5209) - -0.0372826 * (enclose() + -6.16097) * (enclose() + -6.16097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0354892 * (1 - exp(-0.950385 * (distance() + 0.0781097)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0380715
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.67663 - 1.58304 * (distance())) + 0.00379437 / pow(distance() , 1.89416)) * 1.51649 * pow((width1() + width2()) / 2 , 0.0136467)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0434111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0004589 * (distance()) + 0.132663) * (0.637158 - exp(-(0.750364 * (distance()) + 0.407317) * (enclose() + -0.0731466 * (distance()) + 0.931012) - (-0.0871715 * (distance()) + 0.023843) * (enclose() + 0.0751287 * (distance()) + 1.34571) * (enclose() + 0.0751287 * (distance()) + 1.34571)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0651842 * (0.637158 - exp(-4.15914 * (enclose() + 0.565279) - -0.412015 * (enclose() + 1.72135) * (enclose() + 1.72135)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245562 * (1 - exp(-1.1464 * (distance() + -0.10083)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0251716
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78979 - 1.05779 * (distance())) + 0.00747423 / pow(distance() , 1.63943)) * 1.38467 * pow((width1() + width2()) / 2 , 0.0394983)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222844
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00141089 * (distance()) + 0.0436567) * (1.17942 - exp(-(0.0440702 * (distance()) + 0.934807) * (enclose() + -0.0309741 * (distance()) + 0.590978) - (0.00783802 * (distance()) + -0.126844) * (enclose() + -0.39932 * (distance()) + 2.68549) * (enclose() + -0.39932 * (distance()) + 2.68549)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0183011 * (1.17942 - exp(-1.15516 * (enclose() + 0.436107) - -0.0876539 * (enclose() + 0.68889) * (enclose() + 0.68889)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324189 * (1 - exp(-0.750344 * (distance() + -0.0383901)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032951
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.927 - 0.876312 * (distance())) + 0.0115866 / pow(distance() , 1.43705)) * 1.3102 * pow((width1() + width2()) / 2 , 0.0599189)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157949
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00224679 * (distance()) + 0.0443502) * (0.904313 - exp(-(0.0180779 * (distance()) + 0.115945) * (enclose() + 1.872 * (distance()) + -0.368864) - (-0.013945 * (distance()) + -0.00230186) * (enclose() + -0.381288 * (distance()) + -1.95374) * (enclose() + -0.381288 * (distance()) + -1.95374)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0165581 * (0.904313 - exp(-0.206335 * (enclose() + 8.99114) - -0.0720269 * (enclose() + -3.86018) * (enclose() + -3.86018)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.036174 * (1 - exp(-0.632733 * (distance() + 0.0197621)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0371162
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91411 - 1.14383 * (distance())) + 0.00724364 / pow(distance() , 1.66701)) * 1.39181 * pow((width1() + width2()) / 2 , 0.0448741)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495976
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00709514 * (distance()) + 0.201546) * (0.564903 - exp(-(1.17783 * (distance()) + 1.0172) * (enclose() + 0.455213 * (distance()) + 0.648814) - (0.00625353 * (distance()) + -0.32588) * (enclose() + 1.454 * (distance()) + 0.737585) * (enclose() + 1.454 * (distance()) + 0.737585)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0830352 * (0.564903 - exp(-6.90635 * (enclose() + 2.92488) - -0.294612 * (enclose() + 8.00758) * (enclose() + 8.00758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0146953 * (1 - exp(-0.839699 * (distance() + -0.0628989)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151846
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.86055 - 0.791515 * (distance())) + 0.010838 / pow(distance() , 1.50245)) * 1.28103 * pow((width1() + width2()) / 2 , 0.0534518)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0273849
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00568176 * (distance()) + 0.0911377) * (0.429515 - exp(-(0.305497 * (distance()) + 0.319373) * (enclose() + 0.244579 * (distance()) + 2.38465) - (-0.00772209 * (distance()) + -0.00354054) * (enclose() + 0.796568 * (distance()) + 6.93653) * (enclose() + 0.796568 * (distance()) + 6.93653)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0597732 * (0.429515 - exp(-1.84686 * (enclose() + 3.60755) - -0.042151 * (enclose() + 10.9194) * (enclose() + 10.9194)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0214879 * (1 - exp(-0.500809 * (distance() + 0.0145442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0213048
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.12621 - 0.979329 * (distance())) + 0.0103541 / pow(distance() , 1.48686)) * 1.38182 * pow((width1() + width2()) / 2 , 0.0735323)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0532257
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00321193 * (distance()) + 0.142626) * (0.621462 - exp(-(0.585393 * (distance()) + 0.447325) * (enclose() + -0.08276 * (distance()) + 1.10232) - (-0.054939 * (distance()) + -0.041049) * (enclose() + 0.141284 * (distance()) + 1.00059) * (enclose() + 0.141284 * (distance()) + 1.00059)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0793428 * (0.621462 - exp(-3.37429 * (enclose() + 0.68852) - -0.315744 * (enclose() + 1.70701) * (enclose() + 1.70701)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0106688 * (1 - exp(-0.733325 * (distance() + -0.00680873)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0112152
    }
]
CAPACITANCE CROSSOVER PLATE routingpoly ndiff  MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 ndiff  MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 ndiff  MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 ndiff  MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 ndiff  MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet4 ndiff  MASK
[
    PROPERTY C
    C = 0.00815072 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0532483 * (1 - exp(-1.34175 * (distance() + 0.142997)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565925
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.04118 - 1.38136 * (distance())) + 0.0135736 / pow(distance() , 1.09077)) * 1.1381 * pow((width1() + width2()) / 2 , 0.215443)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0423004 * (1 - exp(-0.889624 * (distance() + 0.163635)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0453339
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.77614 - 0.924211 * (distance())) + 0.018676 / pow(distance() , 0.92485)) * 0.888335 * pow((width1() + width2()) / 2 , 0.233595)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0454584 * (1 - exp(-0.56303 * (distance() + 0.146881)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499153
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.20262 - 0.740624 * (distance())) + 0.0206707 / pow(distance() , 0.964583)) * 1.81054 * pow((width1() + width2()) / 2 , 0.113378)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348043 * (1 - exp(-0.340747 * (distance() + 0.425008)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0398451
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.37497 - 0.402422 * (distance())) + 0.0319658 / pow(distance() , 0.84077)) * 1.45257 * pow((width1() + width2()) / 2 , 0.143986)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0300392 * (1 - exp(-0.22725 * (distance() + 0.969108)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.03587
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.69431 - 0.214499 * (distance())) + 0.032278 / pow(distance() , 0.892845)) * 1.27911 * pow((width1() + width2()) / 2 , 0.18492)
]
CAPACITANCE CROSSOVER FRINGE routingmet4 ndiff MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0598403 * (1 - exp(-0.0631048 * (distance() + 0.921632)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0368314
    }
]
CAPACITANCE NEARBODY routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.9381 - 0.317585 * (distance())) + 0.0522599 / pow(distance() , 0.908128)) * 1.9524 * pow((width1() + width2()) / 2 , 0.0700987)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03214 - 5.62812 * (distance())) + 0.00065288 / pow(distance() , 2.12136)) * 0.849821 * pow((width1() + width2()) / 2 , 0.00833925)
]
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF ndiff MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0703073
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00072417 * (distance()) + 0.11128) * (1.18567 - exp(-(0.330112 * (distance()) + 6.01309) * (enclose() + 0.109354 * (distance()) + 0.560448) - (-0.0031829 * (distance()) + -0.935435) * (enclose() + -0.227676 * (distance()) + -1.74479) * (enclose() + -0.227676 * (distance()) + -1.74479)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682435 * (1 - exp(-4.79764 * (distance() + 0.042981)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0574504 * (1.18567 - exp(-7.66365 * (enclose() + 1.10722) - -0.95135 * (enclose() + -2.88317) * (enclose() + -2.88317)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0246626 * (1 - exp(-4.60903 * (distance() + -0.0717568)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0255046
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30766 - 3.57322 * (distance())) + 0.00091407 / pow(distance() , 1.8011)) * 1.04967 * pow((width1() + width2()) / 2 , 0.00862509)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0276821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00133421 * (distance()) + 0.0947724) * (0.590638 - exp(-(1.33191 * (distance()) + 1.41068) * (enclose() + -0.0410965 * (distance()) + 0.487351) - (-0.170231 * (distance()) + -0.158494) * (enclose() + 0.0927245 * (distance()) + 0.511557) * (enclose() + 0.0927245 * (distance()) + 0.511557)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268211 * (1 - exp(-3.07541 * (distance() + -0.104858)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0440507 * (0.590638 - exp(-8.07023 * (enclose() + 0.281868) - -1.00965 * (enclose() + 0.97518) * (enclose() + 0.97518)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329226 * (1 - exp(-3.10879 * (distance() + -0.0889366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0339331
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.94424 - 1.7925 * (distance())) + 0.00357802 / pow(distance() , 1.72832)) * 1.04296 * pow((width1() + width2()) / 2 , 0.0990315)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00059321 * (distance()) + 0.0273051) * (0.87914 - exp(-(0.0246106 * (distance()) + 0.716701) * (enclose() + 0.590434 * (distance()) + -0.181639) - (0.0126597 * (distance()) + -0.130102) * (enclose() + -1.12924 * (distance()) + 0.857723) * (enclose() + -1.12924 * (distance()) + 0.857723)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0121695 * (0.87914 - exp(-0.839754 * (enclose() + 2.77053) - -0.0668035 * (enclose() + -4.78848) * (enclose() + -4.78848)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433651 * (1 - exp(-1.69337 * (distance() + 0.0312548)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454312
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.31662 - 1.40731 * (distance())) + 0.00596482 / pow(distance() , 1.50427)) * 1.1051 * pow((width1() + width2()) / 2 , 0.151405)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751819
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00056907 * (distance()) + 0.0175334) * (0.928289 - exp(-(0.0588486 * (distance()) + 0.340669) * (enclose() + 0.813125 * (distance()) + -0.508852) - (0.0013806 * (distance()) + -0.0300689) * (enclose() + -1.88705 * (distance()) + 0.97368) * (enclose() + -1.88705 * (distance()) + 0.97368)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00734403 * (0.928289 - exp(-0.634912 * (enclose() + 3.55677) - -0.0231659 * (enclose() + -8.46157) * (enclose() + -8.46157)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.046742 * (1 - exp(-1.46684 * (distance() + 0.0886804)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498613
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.45893 - 1.28234 * (distance())) + 0.00882865 / pow(distance() , 1.35797)) * 1.02123 * pow((width1() + width2()) / 2 , 0.176268)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00564609
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00044717 * (distance()) + 0.0169127) * (0.714796 - exp(-(-0.0229817 * (distance()) + 0.320382) * (enclose() + 2.48319 * (distance()) + -1.43302) - (-0.00996399 * (distance()) + 0.0096513) * (enclose() + 0.341381 * (distance()) + -7.59785) * (enclose() + 0.341381 * (distance()) + -7.59785)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00733842 * (0.714796 - exp(-0.205474 * (enclose() + 10.9829) - -0.0401687 * (enclose() + -5.89095) * (enclose() + -5.89095)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0482997 * (1 - exp(-1.39936 * (distance() + 0.118367)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0523407
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88841 - 3.6518 * (distance())) + 0.00073205 / pow(distance() , 2.06432)) * 1.18797 * pow((width1() + width2()) / 2 , 0.0112007)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509744
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00032081 * (distance()) + 0.0940125) * (1.02405 - exp(-(2.60904 * (distance()) + 2.12041) * (enclose() + -0.0133109 * (distance()) + 0.133988) - (-0.0195914 * (distance()) + 0.0602649) * (enclose() + 0.0248593 * (distance()) + 2.0515) * (enclose() + 0.0248593 * (distance()) + 2.0515)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0496915 * (1 - exp(-3.34591 * (distance() + 0.0124691)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0478083 * (1.02405 - exp(-15.1656 * (enclose() + 0.0674335) - -0.0376921 * (enclose() + 2.1758) * (enclose() + 2.1758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0145893 * (1 - exp(-3.1831 * (distance() + -0.0608293)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150047
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.90711 - 1.57677 * (distance())) + 0.00228218 / pow(distance() , 1.79643)) * 1.0814 * pow((width1() + width2()) / 2 , 0.0422125)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153166
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00067108 * (distance()) + 0.0382259) * (0.854775 - exp(-(-0.0195501 * (distance()) + 0.670691) * (enclose() + 0.921985 * (distance()) + -0.324567) - (0.0268178 * (distance()) + -0.25127) * (enclose() + -0.787422 * (distance()) + 0.228141) * (enclose() + -0.787422 * (distance()) + 0.228141)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0174352 * (0.854775 - exp(-0.572941 * (enclose() + 4.28536) - -0.117181 * (enclose() + -3.70897) * (enclose() + -3.70897)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284418 * (1 - exp(-1.35207 * (distance() + -0.0531136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0291869
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.06824 - 1.15439 * (distance())) + 0.0052183 / pow(distance() , 1.52648)) * 0.976453 * pow((width1() + width2()) / 2 , 0.0992957)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0100895
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00078214 * (distance()) + 0.0252269) * (0.887579 - exp(-(0.0294899 * (distance()) + 0.346855) * (enclose() + 0.955562 * (distance()) + -0.617052) - (0.00264508 * (distance()) + -0.0546774) * (enclose() + -1.26235 * (distance()) + 0.475899) * (enclose() + -1.26235 * (distance()) + 0.475899)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106581 * (0.887579 - exp(-0.494305 * (enclose() + 4.16076) - -0.041452 * (enclose() + -5.83585) * (enclose() + -5.83585)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.033175 * (1 - exp(-1.04673 * (distance() + 0.0259002)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0348207
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.19376 - 0.999264 * (distance())) + 0.00804456 / pow(distance() , 1.3321)) * 0.92757 * pow((width1() + width2()) / 2 , 0.141047)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00762268
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00032315 * (distance()) + 0.0236557) * (0.657312 - exp(-(-0.0281134 * (distance()) + 0.327877) * (enclose() + 2.83039 * (distance()) + -1.63104) - (-0.00915175 * (distance()) + 0.00847617) * (enclose() + 0.494566 * (distance()) + -8.6338) * (enclose() + 0.494566 * (distance()) + -8.6338)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.01102 * (0.657312 - exp(-0.18731 * (enclose() + 12.5209) - -0.0372826 * (enclose() + -6.16097) * (enclose() + -6.16097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0354892 * (1 - exp(-0.950385 * (distance() + 0.0781097)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0380715
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.67663 - 1.58304 * (distance())) + 0.00379437 / pow(distance() , 1.89416)) * 1.51649 * pow((width1() + width2()) / 2 , 0.0136467)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0434111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0004589 * (distance()) + 0.132663) * (0.637158 - exp(-(0.750364 * (distance()) + 0.407317) * (enclose() + -0.0731466 * (distance()) + 0.931012) - (-0.0871715 * (distance()) + 0.023843) * (enclose() + 0.0751287 * (distance()) + 1.34571) * (enclose() + 0.0751287 * (distance()) + 1.34571)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0651842 * (0.637158 - exp(-4.15914 * (enclose() + 0.565279) - -0.412015 * (enclose() + 1.72135) * (enclose() + 1.72135)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245562 * (1 - exp(-1.1464 * (distance() + -0.10083)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0251716
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78979 - 1.05779 * (distance())) + 0.00747423 / pow(distance() , 1.63943)) * 1.38467 * pow((width1() + width2()) / 2 , 0.0394983)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222844
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00141089 * (distance()) + 0.0436567) * (1.17942 - exp(-(0.0440702 * (distance()) + 0.934807) * (enclose() + -0.0309741 * (distance()) + 0.590978) - (0.00783802 * (distance()) + -0.126844) * (enclose() + -0.39932 * (distance()) + 2.68549) * (enclose() + -0.39932 * (distance()) + 2.68549)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0183011 * (1.17942 - exp(-1.15516 * (enclose() + 0.436107) - -0.0876539 * (enclose() + 0.68889) * (enclose() + 0.68889)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324189 * (1 - exp(-0.750344 * (distance() + -0.0383901)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032951
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.927 - 0.876312 * (distance())) + 0.0115866 / pow(distance() , 1.43705)) * 1.3102 * pow((width1() + width2()) / 2 , 0.0599189)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157949
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00224679 * (distance()) + 0.0443502) * (0.904313 - exp(-(0.0180779 * (distance()) + 0.115945) * (enclose() + 1.872 * (distance()) + -0.368864) - (-0.013945 * (distance()) + -0.00230186) * (enclose() + -0.381288 * (distance()) + -1.95374) * (enclose() + -0.381288 * (distance()) + -1.95374)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0165581 * (0.904313 - exp(-0.206335 * (enclose() + 8.99114) - -0.0720269 * (enclose() + -3.86018) * (enclose() + -3.86018)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.036174 * (1 - exp(-0.632733 * (distance() + 0.0197621)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0371162
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91411 - 1.14383 * (distance())) + 0.00724364 / pow(distance() , 1.66701)) * 1.39181 * pow((width1() + width2()) / 2 , 0.0448741)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495976
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00709514 * (distance()) + 0.201546) * (0.564903 - exp(-(1.17783 * (distance()) + 1.0172) * (enclose() + 0.455213 * (distance()) + 0.648814) - (0.00625353 * (distance()) + -0.32588) * (enclose() + 1.454 * (distance()) + 0.737585) * (enclose() + 1.454 * (distance()) + 0.737585)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0830352 * (0.564903 - exp(-6.90635 * (enclose() + 2.92488) - -0.294612 * (enclose() + 8.00758) * (enclose() + 8.00758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0146953 * (1 - exp(-0.839699 * (distance() + -0.0628989)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151846
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.86055 - 0.791515 * (distance())) + 0.010838 / pow(distance() , 1.50245)) * 1.28103 * pow((width1() + width2()) / 2 , 0.0534518)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0273849
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00568176 * (distance()) + 0.0911377) * (0.429515 - exp(-(0.305497 * (distance()) + 0.319373) * (enclose() + 0.244579 * (distance()) + 2.38465) - (-0.00772209 * (distance()) + -0.00354054) * (enclose() + 0.796568 * (distance()) + 6.93653) * (enclose() + 0.796568 * (distance()) + 6.93653)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0597732 * (0.429515 - exp(-1.84686 * (enclose() + 3.60755) - -0.042151 * (enclose() + 10.9194) * (enclose() + 10.9194)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0214879 * (1 - exp(-0.500809 * (distance() + 0.0145442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0213048
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.12621 - 0.979329 * (distance())) + 0.0103541 / pow(distance() , 1.48686)) * 1.38182 * pow((width1() + width2()) / 2 , 0.0735323)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0532257
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00321193 * (distance()) + 0.142626) * (0.621462 - exp(-(0.585393 * (distance()) + 0.447325) * (enclose() + -0.08276 * (distance()) + 1.10232) - (-0.054939 * (distance()) + -0.041049) * (enclose() + 0.141284 * (distance()) + 1.00059) * (enclose() + 0.141284 * (distance()) + 1.00059)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.050679 * (1 - exp(-0.889285 * (distance() + 0.0632742)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0793428 * (0.621462 - exp(-3.37429 * (enclose() + 0.68852) - -0.315744 * (enclose() + 1.70701) * (enclose() + 1.70701)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0106688 * (1 - exp(-0.733325 * (distance() + -0.00680873)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0112152
    }
]
CAPACITANCE CROSSOVER PLATE routingpoly routingnwell MASK 
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 routingnwell MASK 
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 routingnwell MASK 
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 routingnwell MASK 
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 routingnwell MASK 
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet4 routingnwell MASK 
[
    PROPERTY C
    C = 0.00815072 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0532483 * (1 - exp(-1.34175 * (distance() + 0.142997)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565925
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0423004 * (1 - exp(-0.889624 * (distance() + 0.163635)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0453339
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0454584 * (1 - exp(-0.56303 * (distance() + 0.146881)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499153
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348043 * (1 - exp(-0.340747 * (distance() + 0.425008)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0398451
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0300392 * (1 - exp(-0.22725 * (distance() + 0.969108)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.03587
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet4 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0598403 * (1 - exp(-0.0631048 * (distance() + 0.921632)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0368314
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingpoly2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0246626 * (1 - exp(-4.60903 * (distance() + -0.0717568)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0255046
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet1 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329226 * (1 - exp(-3.10879 * (distance() + -0.0889366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0339331
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433651 * (1 - exp(-1.69337 * (distance() + 0.0312548)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454312
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.046742 * (1 - exp(-1.46684 * (distance() + 0.0886804)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498613
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0482997 * (1 - exp(-1.39936 * (distance() + 0.118367)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0523407
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet1 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0145893 * (1 - exp(-3.1831 * (distance() + -0.0608293)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150047
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284418 * (1 - exp(-1.35207 * (distance() + -0.0531136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0291869
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.033175 * (1 - exp(-1.04673 * (distance() + 0.0259002)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0348207
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0354892 * (1 - exp(-0.950385 * (distance() + 0.0781097)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0380715
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245562 * (1 - exp(-1.1464 * (distance() + -0.10083)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0251716
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324189 * (1 - exp(-0.750344 * (distance() + -0.0383901)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032951
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.036174 * (1 - exp(-0.632733 * (distance() + 0.0197621)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0371162
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0146953 * (1 - exp(-0.839699 * (distance() + -0.0628989)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151846
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0214879 * (1 - exp(-0.500809 * (distance() + 0.0145442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0213048
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0106688 * (1 - exp(-0.733325 * (distance() + -0.00680873)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0112152
    }
]

//---------------------------------------------------------------------
// n-well over base layer area and perimeter (CJNW,CJSWNW) //ghe

CAPACITANCE INTRINSIC PLATE routingnwell
 [ PROPERTY C
   C = 0.11 * AREA()
 ] MASK
CAPACITANCE INTRINSIC FRINGE routingnwell
 [ PROPERTY C
   C = 0.53 * LENGTH()
 ] MASK

//---------------------------------------------------------------------
//==========================================================================
//                      copied from b35d4_worst
//==========================================================================
// copied from s35d4 worst metcap only

CAPACITANCE INTRINSIC PLATE routingmetcap MASK
[
    PROPERTY C
    C = 0.0124303 * area()
]
CAPACITANCE INTRINSIC FRINGE routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348639 * (1 - exp(-0.202137 * (distance() + 0.503041)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0370247
    }
]
CAPACITANCE NEARBODY routingmetcap WITH SHIELD routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.50032 - 0.306956 * (distance())) + 0.0320333 / pow(distance() , 0.632668)) * 0.799532 * pow((width1() + width2()) / 2 , 0.137594)
]
CAPACITANCE CROSSOVER PLATE routingpoly routingmetcap MASK
[
    PROPERTY C
    C = 0.0155163 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmetcap MASK
[
    PROPERTY C
    C = 0.017442 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 routingmetcap MASK
[
    PROPERTY C
    C = 0.0300857 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 routingmetcap MASK
[
    PROPERTY C
    C = 0.779 * area()
]
CAPACITANCE CROSSOVER PLATE routingmetcap routingmet3 MASK
[
    PROPERTY C
    C = 0.162787 * area()
]
CAPACITANCE CROSSOVER PLATE routingmetcap routingmet4 MASK
[
    PROPERTY C
    C = 0.0266335 * area()
]
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.16948 - 1.46925 * (distance())) + 0.00529227 / pow(distance() , 1.5981)) * 1.0354 * pow((width1() + width2()) / 2 , 0.138586)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00838435
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00064516 * (distance()) + 0.0196773) * (0.940018 - exp(-(0.0498317 * (distance()) + 0.45828) * (enclose() + 0.534151 * (distance()) + -0.326029) - (0.00493154 * (distance()) + -0.0635957) * (enclose() + -1.3065 * (distance()) + 1.08337) * (enclose() + -1.3065 * (distance()) + 1.08337)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00822575 * (0.940018 - exp(-0.707439 * (enclose() + 2.34473) - -0.038938 * (enclose() + -5.44913) * (enclose() + -5.44913)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0458599 * (1 - exp(-1.50391 * (distance() + 0.0782329)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0483778
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.04794 - 1.24381 * (distance())) + 0.00417245 / pow(distance() , 1.60601)) * 1.02486 * pow((width1() + width2()) / 2 , 0.0825399)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0113161
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00086538 * (distance()) + 0.0294173) * (0.859768 - exp(-(0.0140524 * (distance()) + 0.403244) * (enclose() + 0.983466 * (distance()) + -0.487953) - (0.00711743 * (distance()) + -0.0960181) * (enclose() + -1.05311 * (distance()) + 0.290928) * (enclose() + -1.05311 * (distance()) + 0.290928)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125452 * (0.859768 - exp(-0.473506 * (enclose() + 4.42938) - -0.0604309 * (enclose() + -4.97462) * (enclose() + -4.97462)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0320318 * (1 - exp(-1.10842 * (distance() + 0.0044356)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0334332
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.74426 - 1.16706 * (distance())) + 0.00577739 / pow(distance() , 1.75265)) * 1.43892 * pow((width1() + width2()) / 2 , 0.0295963)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0256771
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00160737 * (distance()) + 0.0993621) * (0.454987 - exp(-(-0.0496403 * (distance()) + 0.0308965) * (enclose() + 6.54606 * (distance()) + 4.77843) - (0.00158747 * (distance()) + 0.0608077) * (enclose() + 1.84423 * (distance()) + 2.50816) * (enclose() + 1.84423 * (distance()) + 2.50816)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0536995 * (0.454987 - exp(0.217305 * (enclose() + 37.5087) - 0.0687451 * (enclose() + 11.7293) * (enclose() + 11.7293)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0304295 * (1 - exp(-0.835018 * (distance() + -0.0699359)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0306969
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.02322 - 1.33945 * (distance())) + 0.00582213 / pow(distance() , 1.79978)) * 1.30648 * pow((width1() + width2()) / 2 , 0.0598264)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0971571
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00508102 * (distance()) + 0.203942) * (0.801395 - exp(-(0.898776 * (distance()) + 1.62184) * (enclose() + -0.224452 * (distance()) + 0.0995137) - (0.00671556 * (distance()) + 0.0926532) * (enclose() + 0.997434 * (distance()) + 2.51245) * (enclose() + 0.997434 * (distance()) + 2.51245)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.114674 * (0.801395 - exp(-6.11572 * (enclose() + -1.02275) - 0.126231 * (enclose() + 7.49962) * (enclose() + 7.49962)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingmet2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0114176 * (1 - exp(-1.11944 * (distance() + -0.0561774)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0118811
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.28718 - 1.09435 * (distance())) + 0.00774122 / pow(distance() , 1.67388)) * 0.710539 * pow((width1() + width2()) / 2 , 0.0103477)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0533118
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00017335 * (distance()) + 0.103584) * (0.962186 - exp(-(1.20734 * (distance()) + 1.65767) * (enclose() + 0.0859913 * (distance()) + 0.283289) - (-0.00212998 * (distance()) + -0.630102) * (enclose() + 0.458405 * (distance()) + 0.393214) * (enclose() + 0.458405 * (distance()) + 0.393214)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.051376 * (0.962186 - exp(-7.4529 * (enclose() + 0.696047) - -0.640326 * (enclose() + 2.59356) * (enclose() + 2.59356)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingmetcap INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0139532 * (1 - exp(-0.0466974 * (distance() + 6.38408)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.00558447
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.00439 - 0.772828 * (distance())) + 0.00628635 / pow(distance() , 1.46294)) * 1.00986 * pow((width1() + width2()) / 2 , 0.00345354)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0263932
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0033127 * (distance()) + 0.104541) * (0.418485 - exp(-(0.33105 * (distance()) + 0.472719) * (enclose() + 5.3218e-05 * (distance()) + 1.73153) - (-0.0182584 * (distance()) + -0.0294399) * (enclose() + 0.329794 * (distance()) + 2.59543) * (enclose() + 0.329794 * (distance()) + 2.59543)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.060221 * (0.418485 - exp(-2.06176 * (enclose() + 1.73179) - -0.11708 * (enclose() + 4.17844) * (enclose() + 4.17844)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE INTRINSIC FRINGE routingmetcap INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0125763 * (1 - exp(-0.621617 * (distance() + -0.090366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.012779
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.50286 - 0.332984 * (distance())) + 0.0304026 / pow(distance() , 0.654872)) * 0.780007 * pow((width1() + width2()) / 2 , 0.147304)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.036063 * (1 - exp(-0.247976 * (distance() + 0.414256)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0411965
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0338304 * (distance()) + 0.381985) * (0.369661 - exp(-(0.0759546 * (distance()) + 0.346961) * (enclose() + -0.00033924 * (distance()) + 3.89817) - (0.00165865 * (distance()) + -0.0338005) * (enclose() + 0.930248 * (distance()) + 3.68599) * (enclose() + 0.930248 * (distance()) + 3.68599)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.036063 * (1 - exp(-0.247976 * (distance() + 0.414256)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.1098 * (0.369661 - exp(-0.711543 * (enclose() + 3.89654) - -0.025839 * (enclose() + 8.15118) * (enclose() + 8.15118)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.57583 - 0.352183 * (distance())) + 0.0279556 / pow(distance() , 0.66066)) * 0.818498 * pow((width1() + width2()) / 2 , 0.152552)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0368708 * (1 - exp(-0.272812 * (distance() + 0.381691)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0424672
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00932379 * (distance()) + 0.11284) * (0.336789 - exp(-(0.123673 * (distance()) + 0.211196) * (enclose() + -0.182239 * (distance()) + 3.17055) - (-0.00409246 * (distance()) + 0.00528077) * (enclose() + 0.26065 * (distance()) + 5.33813) * (enclose() + 0.26065 * (distance()) + 5.33813)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0368708 * (1 - exp(-0.272812 * (distance() + 0.381691)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0787971 * (0.336789 - exp(-0.804826 * (enclose() + 2.2958) - -0.014363 * (enclose() + 6.58925) * (enclose() + 6.58925)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.63821 - 0.414799 * (distance())) + 0.026626 / pow(distance() , 0.716623)) * 0.741511 * pow((width1() + width2()) / 2 , 0.178804)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0412326 * (1 - exp(-0.419237 * (distance() + 0.26222)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0490232
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0078377 * (distance()) + 0.0935581) * (0.520572 - exp(-(0.223885 * (distance()) + 0.247637) * (enclose() + 0.00126507 * (distance()) + 1.71015) - (-0.00987984 * (distance()) + 0.00954047) * (enclose() + 0.546808 * (distance()) + 3.05963) * (enclose() + 0.546808 * (distance()) + 3.05963)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0412326 * (1 - exp(-0.419237 * (distance() + 0.26222)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0655895 * (0.520572 - exp(-1.32228 * (enclose() + 1.71622) - -0.0378828 * (enclose() + 5.68431) * (enclose() + 5.68431)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.14215 - 0.382816 * (distance())) + 0.0203457 / pow(distance() , 0.832809)) * 0.431112 * pow((width1() + width2()) / 2 , 0.325187)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.114061 * (1 - exp(-0.171156 * (distance() + 5.91244)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.104681
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00773763 * (distance()) + 0.124186) * (1.1327 - exp(-(-0.599383 * (distance()) + 4.45396) * (enclose() + -0.119965 * (distance()) + -0.929512) - (-0.053372 * (distance()) + 0.391196) * (enclose() + 0.254449 * (distance()) + 3.47) * (enclose() + 0.254449 * (distance()) + 3.47)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.114061 * (1 - exp(-0.171156 * (distance() + 5.91244)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0806633 * (1.1327 - exp(-1.57692 * (enclose() + -1.50534) - 0.13501 * (enclose() + 4.69136) * (enclose() + 4.69136)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.30668 - 0.927519 * (distance())) + 0.0155118 / pow(distance() , 1.11428)) * 1.75405 * pow((width1() + width2()) / 2 , 0.145692)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0696593 * (1 - exp(-0.963704 * (distance() + 0.213795)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0769855
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00717446 * (distance()) + 0.224789) * (0.684805 - exp(-(0.81824 * (distance()) + 0.838343) * (enclose() + 0.126956 * (distance()) + 0.492679) - (0.0218727 * (distance()) + -0.428362) * (enclose() + 0.739192 * (distance()) + 0.123527) * (enclose() + 0.739192 * (distance()) + 0.123527)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0696593 * (1 - exp(-0.963704 * (distance() + 0.213795)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0944583 * (0.684805 - exp(-4.92954 * (enclose() + 1.12746) - -0.318999 * (enclose() + 3.81949) * (enclose() + 3.81949)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet4 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 10 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.05587 - 0.283538 * (distance())) + 0.082988 / pow(distance() , 1.41721)) * 1.21691 * pow((width1() + width2()) / 2 , 0.0282544)
]
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0554603 * (1 - exp(-0.222433 * (distance() + 0.235122)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0573306
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0153333 * (distance()) + 0.011562) * (1.17774 - exp(-(-0.121798 * (distance()) + 1.11912) * (enclose() + 0.0377238 * (distance()) + 0.154871) - (0.0212171 * (distance()) + -0.1499) * (enclose() + 0.40472 * (distance()) + -0.957022) * (enclose() + 0.40472 * (distance()) + -0.957022)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0554603 * (1 - exp(-0.222433 * (distance() + 0.235122)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0441143 * (1.17774 - exp(-0.51013 * (enclose() + 0.34349) - -0.0438145 * (enclose() + 1.06658) * (enclose() + 1.06658)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.40426 - 1.67309 * (distance())) + 0.00493524 / pow(distance() , 1.66801)) * 0.677177 * pow((width1() + width2()) / 2 , 0.16731)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmetcap INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00507719 * (1 - exp(-1.8572 * (distance() + 0.134066)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00546604
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00034898 * (distance()) + 0.0134846) * (0.819482 - exp(-(0.0179469 * (distance()) + 0.568886) * (enclose() + 1.04237 * (distance()) + -0.373955) - (0.00523113 * (distance()) + -0.0666763) * (enclose() + -1.54943 * (distance()) + -0.367435) * (enclose() + -1.54943 * (distance()) + -0.367435)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00507719 * (1 - exp(-1.8572 * (distance() + 0.134066)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00586985 * (0.819482 - exp(-0.658621 * (enclose() + 4.8379) - -0.0405206 * (enclose() + -8.11458) * (enclose() + -8.11458)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmetcap MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0810875 * (1 - exp(-1.99368 * (distance() + 0.375468)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0856791
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00410564 * (distance()) + 0.12749) * (1.11913 - exp(-(-0.203655 * (distance()) + 4.06932) * (enclose() + -0.0859388 * (distance()) + 0.752031) - (0.268723 * (distance()) + -2.0714) * (enclose() + 0.051323 * (distance()) + -1.10656) * (enclose() + 0.051323 * (distance()) + -1.10656)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0810875 * (1 - exp(-1.99368 * (distance() + 0.375468)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0740091 * (1.11913 - exp(-3.05105 * (enclose() + 0.322337) - -0.727785 * (enclose() + -0.849945) * (enclose() + -0.849945)) + 0.00021711)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.74463 - 1.46504 * (distance())) + 0.00432073 / pow(distance() , 1.87552)) * 1.49323 * pow((width1() + width2()) / 2 , 0.0283056)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmetcap INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0209269 * (1 - exp(-1.05929 * (distance() + -0.0931746)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0214108
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00069097 * (distance()) + 0.137683) * (0.299629 - exp(-(-0.0884008 * (distance()) + 0.0435442) * (enclose() + 7.97336 * (distance()) + 9.47183) - (0.00083637 * (distance()) + 0.0463825) * (enclose() + 3.43802 * (distance()) + 3.3801) * (enclose() + 3.43802 * (distance()) + 3.3801)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0209269 * (1 - exp(-1.05929 * (distance() + -0.0931746)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0671141 * (0.299629 - exp(0.39846 * (enclose() + 49.3386) - 0.0505644 * (enclose() + 20.5702) * (enclose() + 20.5702)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0461699 * (1 - exp(-1.21472 * (distance() + -0.0204077)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0472275
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00786116 * (distance()) + 0.142385) * (0.883825 - exp(-(1.91002 * (distance()) + 0.867697) * (enclose() + 1.01774 * (distance()) + 0.165541) - (0.00269298 * (distance()) + -0.325026) * (enclose() + 2.54868 * (distance()) + 0.449373) * (enclose() + 2.54868 * (distance()) + 0.449373)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0461699 * (1 - exp(-1.21472 * (distance() + -0.0204077)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0515396 * (0.883825 - exp(-10.4178 * (enclose() + 5.25424) - -0.311561 * (enclose() + 13.1928) * (enclose() + 13.1928)) + 0.000371186)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.82684 - 1.55027 * (distance())) + 0.00459309 / pow(distance() , 1.92032)) * 1.26792 * pow((width1() + width2()) / 2 , 0.0393552)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0913102 * (1 - exp(-1.50237 * (distance() + 0.306848)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0941121
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.013786 * (distance()) + 0.681295) * (0.238498 - exp(-(1.01493 * (distance()) + 1.96928) * (enclose() + -0.391906 * (distance()) + 0.662322) - (0.00398442 * (distance()) + 0.023089) * (enclose() + 2.28195 * (distance()) + 4.73958) * (enclose() + 2.28195 * (distance()) + 4.73958)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0913102 * (1 - exp(-1.50237 * (distance() + 0.306848)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.375112 * (0.238498 - exp(-7.04393 * (enclose() + -1.29721) - 0.0430111 * (enclose() + 16.1493) * (enclose() + 16.1493)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0143674 * (1 - exp(-1.24732 * (distance() + -0.0866334)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0148363
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00580036 * (distance()) + 0.0656517) * (0.910693 - exp(-(1.47907 * (distance()) + 0.281097) * (enclose() + 2.73048 * (distance()) + -0.361024) - (0.00032184 * (distance()) + -0.114368) * (enclose() + 6.02182 * (distance()) + -0.0671667) * (enclose() + 6.02182 * (distance()) + -0.0671667)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0143674 * (1 - exp(-1.24732 * (distance() + -0.0866334)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0183249 * (0.910693 - exp(-7.67645 * (enclose() + 13.2914) - -0.112759 * (enclose() + 30.0419) * (enclose() + 30.0419)) + 0.000291195)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.15656 - 1.29972 * (distance())) + 0.00658904 / pow(distance() , 1.71936)) * 0.691375 * pow((width1() + width2()) / 2 , 0.00971335)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0609113 * (1 - exp(-0.196429 * (distance() + 4.27171)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0511304
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00020279 * (distance()) + 0.0905711) * (0.996675 - exp(-(-0.0411251 * (distance()) + 1.09617) * (enclose() + 0.873451 * (distance()) + 0.0215647) - (0.143954 * (distance()) + -1.23678) * (enclose() + -0.462833 * (distance()) + -0.0966173) * (enclose() + -0.462833 * (distance()) + -0.0966173)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0609113 * (1 - exp(-0.196429 * (distance() + 4.27171)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0447989 * (0.996675 - exp(-0.89877 * (enclose() + 4.21413) - -0.545801 * (enclose() + -2.31822) * (enclose() + -2.31822)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00631243 * (1 - exp(-1.29771 * (distance() + 0.108318)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00662185
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00166216 * (distance()) + 0.0291702) * (0.801985 - exp(-(-0.0354769 * (distance()) + 0.637576) * (enclose() + 0.129177 * (distance()) + -0.217018) - (0.00996139 * (distance()) + -0.133876) * (enclose() + -0.422119 * (distance()) + 0.464688) * (enclose() + -0.422119 * (distance()) + 0.464688)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00631243 * (1 - exp(-1.29771 * (distance() + 0.108318)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0105959 * (0.801985 - exp(-0.467287 * (enclose() + 0.403032) - -0.0860613 * (enclose() + -1.56148) * (enclose() + -1.56148)) + 0.000369479)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.97315 - 0.842001 * (distance())) + 0.00500667 / pow(distance() , 1.67608)) * 1.00465 * pow((width1() + width2()) / 2 , 0.00481393)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0239581 * (1 - exp(-0.698102 * (distance() + -0.0975162)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0244868
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00044103 * (distance()) + 0.0405595) * (1.01142 - exp(-(-0.0119288 * (distance()) + 0.161692) * (enclose() + 5.35768 * (distance()) + 0.917149) - (-0.0231352 * (distance()) + -0.0184724) * (enclose() + 0.0935002 * (distance()) + -4.46045) * (enclose() + 0.0935002 * (distance()) + -4.46045)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0239581 * (1 - exp(-0.698102 * (distance() + -0.0975162)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0213382 * (1.01142 - exp(-0.104434 * (enclose() + 26.634) - -0.129521 * (enclose() + -4.01165) * (enclose() + -4.01165)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0143704 * (1 - exp(-0.691964 * (distance() + -0.101362)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0146827
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00885252 * (distance()) + 0.0906848) * (0.813177 - exp(-(0.305555 * (distance()) + 0.180401) * (enclose() + 0.81451 * (distance()) + 0.0260074) - (0.00085253 * (distance()) + -0.0568914) * (enclose() + 2.28334 * (distance()) + -0.0697353) * (enclose() + 2.28334 * (distance()) + -0.0697353)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0143704 * (1 - exp(-0.691964 * (distance() + -0.101362)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0240964 * (0.813177 - exp(-1.64707 * (enclose() + 3.93566) - -0.0527993 * (enclose() + 10.8903) * (enclose() + 10.8903)) + 0.00127405)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.75747 - 1.68361 * (distance())) + 0.0039201 / pow(distance() , 1.92592)) * 1.41968 * pow((width1() + width2()) / 2 , 0.0332654)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmetcap INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0181041 * (1 - exp(-1.27128 * (distance() + -0.0904228)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.018825
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00977126 * (distance()) + 0.734317) * (0.0518677 - exp(-(0.145821 * (distance()) + 0.311359) * (enclose() + -3.27939 * (distance()) + 4.79708) - (0.00052319 * (distance()) + 0.00677298) * (enclose() + 5.59361 * (distance()) + 12.7619) * (enclose() + 5.59361 * (distance()) + 12.7619)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0181041 * (1 - exp(-1.27128 * (distance() + -0.0904228)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.34273 * (0.0518677 - exp(-1.04046 * (enclose() + -11.5999) - 0.00938893 * (enclose() + 40.73) * (enclose() + 40.73)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0705185 * (1 - exp(-1.54089 * (distance() + 0.135888)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0726179
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0130374 * (distance()) + 1.16213) * (0.113312 - exp(-(0.494082 * (distance()) + 1.55508) * (enclose() + -0.232655 * (distance()) + 1.58905) - (0.00018427 * (distance()) + -0.00037032) * (enclose() + 12.0648 * (distance()) + -18.3695) * (enclose() + 12.0648 * (distance()) + -18.3695)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0705185 * (1 - exp(-1.54089 * (distance() + 0.135888)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.613659 * (0.113312 - exp(-4.02549 * (enclose() + 0.425775) - 0.00055103 * (enclose() + 41.9545) * (enclose() + 41.9545)) + 0.000264524)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.76568 - 1.70131 * (distance())) + 0.00386718 / pow(distance() , 1.94235)) * 1.31881 * pow((width1() + width2()) / 2 , 0.0323577)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0898659 * (1 - exp(-1.62326 * (distance() + 0.263889)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0926525
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00447379 * (distance()) + 0.250108) * (0.64875 - exp(-(1.25232 * (distance()) + 1.90125) * (enclose() + -0.194398 * (distance()) + 0.366467) - (0.00740331 * (distance()) + 0.0273029) * (enclose() + 1.38489 * (distance()) + 2.7625) * (enclose() + 1.38489 * (distance()) + 2.7625)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0898659 * (1 - exp(-1.62326 * (distance() + 0.263889)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.136238 * (0.64875 - exp(-8.16285 * (enclose() + -0.605523) - 0.0643195 * (enclose() + 9.68695) * (enclose() + 9.68695)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0162503 * (1 - exp(-1.34478 * (distance() + -0.0975185)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0167741
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (6.00662e-06 * (distance()) + 0.0317018) * (1.0162 - exp(-(0.035901 * (distance()) + 1.21478) * (enclose() + -0.0434617 * (distance()) + 0.332566) - (0.067751 * (distance()) + -0.180593) * (enclose() + -0.603696 * (distance()) + 2.08303) * (enclose() + -0.603696 * (distance()) + 2.08303)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0162503 * (1 - exp(-1.34478 * (distance() + -0.0975185)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0158659 * (1.0162 - exp(-1.39428 * (enclose() + 0.115257) - 0.158162 * (enclose() + -0.93545) * (enclose() + -0.93545)) + 0.00023667)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.03625 - 1.51501 * (distance())) + 0.00437189 / pow(distance() , 1.59496)) * 0.770766 * pow((width1() + width2()) / 2 , 0.0186717)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0475845 * (1 - exp(-1.43129 * (distance() + 0.157712)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0501463
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00024913 * (distance()) + 0.0820756) * (1.11829 - exp(-(-0.0277546 * (distance()) + 0.988002) * (enclose() + 0.981023 * (distance()) + -0.0703056) - (0.133887 * (distance()) + -1.22201) * (enclose() + -0.462804 * (distance()) + -0.142359) * (enclose() + -0.462804 * (distance()) + -0.142359)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0475845 * (1 - exp(-1.43129 * (distance() + 0.157712)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0404399 * (1.11829 - exp(-0.85478 * (enclose() + 4.6386) - -0.579352 * (enclose() + -2.36382) * (enclose() + -2.36382)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00686476 * (1 - exp(-1.39551 * (distance() + 0.0810136)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00727147
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00110684 * (distance()) + 0.0265181) * (0.793762 - exp(-(-0.0480591 * (distance()) + 0.662652) * (enclose() + 0.325244 * (distance()) + -0.317011) - (0.0183091 * (distance()) + -0.188413) * (enclose() + -0.450024 * (distance()) + 0.0347611) * (enclose() + -0.450024 * (distance()) + 0.0347611)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00686476 * (1 - exp(-1.39551 * (distance() + 0.0810136)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106026 * (0.793762 - exp(-0.431968 * (enclose() + 1.24416) - -0.100529 * (enclose() + -2.12535) * (enclose() + -2.12535)) + 0.000309705)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingpoly2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.95543 - 0.917413 * (distance())) + 0.00425449 / pow(distance() , 1.54927)) * 1.04238 * pow((width1() + width2()) / 2 , 0.00470916)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0228858 * (1 - exp(-0.742877 * (distance() + -0.105699)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0234531
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00130781 * (distance()) + 0.0584472) * (0.874325 - exp(-(-0.0100824 * (distance()) + 0.446927) * (enclose() + 0.778819 * (distance()) + -0.19939) - (0.0157567 * (distance()) + -0.177454) * (enclose() + -0.559782 * (distance()) + 0.272972) * (enclose() + -0.559782 * (distance()) + 0.272972)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0228858 * (1 - exp(-0.742877 * (distance() + -0.105699)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0260849 * (0.874325 - exp(-0.398531 * (enclose() + 3.53894) - -0.101822 * (enclose() + -2.41398) * (enclose() + -2.41398)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingpoly2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153439 * (1 - exp(-0.739746 * (distance() + -0.111398)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157263
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00884118 * (distance()) + 0.0968215) * (0.631039 - exp(-(0.24854 * (distance()) + 0.273876) * (enclose() + 0.23272 * (distance()) + 0.757935) - (0.00383292 * (distance()) + -0.083917) * (enclose() + 1.20337 * (distance()) + 0.0273656) * (enclose() + 1.20337 * (distance()) + 0.0273656)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0153439 * (1 - exp(-0.739746 * (distance() + -0.111398)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0271919 * (0.631039 - exp(-1.46687 * (enclose() + 1.87499) - -0.065519 * (enclose() + 5.80354) * (enclose() + 5.80354)) + 0.00106106)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.48418 - 2.735 * (distance())) + 0.00155782 / pow(distance() , 2.05307)) * 1.57535 * pow((width1() + width2()) / 2 , 0.00573951)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0817022 * (1 - exp(-2.43708 * (distance() + 0.103025)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0838323
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00083555 * (distance()) + 0.137396) * (1.19402 - exp(-(3.0925 * (distance()) + 2.58141) * (enclose() + 0.031562 * (distance()) + 0.0794894) - (0.198608 * (distance()) + -2.74542) * (enclose() + 0.307428 * (distance()) + -0.0745661) * (enclose() + 0.307428 * (distance()) + -0.0745661)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0817022 * (1 - exp(-2.43708 * (distance() + 0.103025)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0666091 * (1.19402 - exp(-18.0439 * (enclose() + 0.237299) - -1.75238 * (enclose() + 1.46257) * (enclose() + 1.46257)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0312817 * (1 - exp(-2.20925 * (distance() + -0.125013)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0321065
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00334866 * (distance()) + 0.143107) * (0.477548 - exp(-(0.869332 * (distance()) + 1.25695) * (enclose() + -0.0629355 * (distance()) + 0.69781) - (-0.0609126 * (distance()) + -0.336894) * (enclose() + 0.11365 * (distance()) + 0.526248) * (enclose() + 0.11365 * (distance()) + 0.526248)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0312817 * (1 - exp(-2.20925 * (distance() + -0.125013)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0631819 * (0.477548 - exp(-5.60361 * (enclose() + 0.383132) - -0.641457 * (enclose() + 1.0945) * (enclose() + 1.0945)) + 9.00149e-05)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.16967 - 2.05122 * (distance())) + 0.00271828 / pow(distance() , 2.07158)) * 0.890237 * pow((width1() + width2()) / 2 , 0.00351817)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.056061 * (1 - exp(-0.104956 * (distance() + 9.55796)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0441347
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00140198 * (distance()) + 0.113165) * (0.745645 - exp(-(1.72229 * (distance()) + 2.64987) * (enclose() + -0.00634655 * (distance()) + 0.374256) - (-0.0503717 * (distance()) + -1.01367) * (enclose() + 0.1587 * (distance()) + 0.674966) * (enclose() + 0.1587 * (distance()) + 0.674966)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.056061 * (1 - exp(-0.104956 * (distance() + 9.55796)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0532177 * (0.745645 - exp(-10.9169 * (enclose() + 0.343793) - -1.25545 * (enclose() + 1.43673) * (enclose() + 1.43673)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.021998 * (1 - exp(-0.0364374 * (distance() + 13.0542)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0106447
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00047303 * (distance()) + 0.0322995) * (0.712764 - exp(-(-0.075383 * (distance()) + 0.815049) * (enclose() + 0.873174 * (distance()) + 0.0389332) - (0.0606903 * (distance()) + -0.50189) * (enclose() + -0.430364 * (distance()) + -0.377948) * (enclose() + -0.430364 * (distance()) + -0.377948)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.021998 * (1 - exp(-0.0364374 * (distance() + 13.0542)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0150145 * (0.712764 - exp(-0.453211 * (enclose() + 4.23017) - -0.210577 * (enclose() + -2.4437) * (enclose() + -2.4437)) + 9.63258e-05)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet1 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91154 - 1.16815 * (distance())) + 0.00300528 / pow(distance() , 1.78889)) * 1.01548 * pow((width1() + width2()) / 2 , 0.00891506)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0183391 * (1 - exp(-0.988019 * (distance() + -0.124628)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0188665
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00124733 * (distance()) + 0.046944) * (0.876104 - exp(-(-0.00452195 * (distance()) + 0.416831) * (enclose() + 1.14824 * (distance()) + -0.325544) - (0.0167696 * (distance()) + -0.200873) * (enclose() + -0.657465 * (distance()) + 0.0338454) * (enclose() + -0.657465 * (distance()) + 0.0338454)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0183391 * (1 - exp(-0.988019 * (distance() + -0.124628)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0204784 * (0.876104 - exp(-0.395126 * (enclose() + 5.18601) - -0.120379 * (enclose() + -3.12199) * (enclose() + -3.12199)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet1 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0205416 * (1 - exp(-0.990036 * (distance() + -0.123136)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0211301
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00567044 * (distance()) + 0.080386) * (0.80318 - exp(-(0.525065 * (distance()) + 0.201211) * (enclose() + 0.350557 * (distance()) + 0.163507) - (0.00634067 * (distance()) + -0.170261) * (enclose() + 1.30512 * (distance()) + -0.683637) * (enclose() + 1.30512 * (distance()) + -0.683637)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0205416 * (1 - exp(-0.990036 * (distance() + -0.123136)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0265839 * (0.80318 - exp(-2.72152 * (enclose() + 1.84618) - -0.139826 * (enclose() + 5.58094) * (enclose() + 5.58094)) + 0.000392069)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(10 - 18.6694 * (distance())) + 0.0201469 / pow(distance() , 2.03926)) * 0.0120778 * pow((width1() + width2()) / 2 , -0.0294473)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0242432 * (1 - exp(-0.0523622 * (distance() + 33.8752)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0211923
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-5.73947e-05 * (distance()) + 0.0508232) * (0.810634 - exp(-(-0.172106 * (distance()) + 2.66612) * (enclose() + 0.634865 * (distance()) + 0.796219) - (0.222978 * (distance()) + -2.18832) * (enclose() + -0.308973 * (distance()) + -0.834357) * (enclose() + -0.308973 * (distance()) + -0.834357)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0242432 * (1 - exp(-0.0523622 * (distance() + 33.8752)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0252739 * (0.810634 - exp(-1.84001 * (enclose() + 3.84357) - -1.11803 * (enclose() + -2.31743) * (enclose() + -2.31743)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0596554 * (1 - exp(-0.111532 * (distance() + 18.5066)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0560684
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-4.90299e-05 * (distance()) + 0.100416) * (1.08151 - exp(-(1.86608 * (distance()) + 13.5602) * (enclose() + -0.0454001 * (distance()) + 0.35786) - (-0.177024 * (distance()) + -0.6561) * (enclose() + -0.248132 * (distance()) + 2.44193) * (enclose() + -0.248132 * (distance()) + 2.44193)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0596554 * (1 - exp(-0.111532 * (distance() + 18.5066)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0500903 * (1.08151 - exp(-22.5174 * (enclose() + 0.13994) - -1.50582 * (enclose() + 1.2509) * (enclose() + 1.2509)) + 9.53321e-06)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF routingmet2 routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.46469 - 2.09265 * (distance())) + 0.00368983 / pow(distance() , 1.9575)) * 0.661224 * pow((width1() + width2()) / 2 , 0.00352792)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0111879 * (1 - exp(-0.0330001 * (distance() + 20.322)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0064347
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00023638 * (distance()) + 0.02246) * (0.552932 - exp(-(-0.0110271 * (distance()) + 1.43391) * (enclose() + 0.33451 * (distance()) + 0.0847265) - (0.00784832 * (distance()) + -0.0672397) * (enclose() + -1.69196 * (distance()) + 1.67115) * (enclose() + -1.69196 * (distance()) + 1.67115)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0111879 * (1 - exp(-0.0330001 * (distance() + 20.322)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106627 * (0.552932 - exp(-1.38098 * (enclose() + 1.69037) - -0.0295678 * (enclose() + -6.45026) * (enclose() + -6.45026)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet2 INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0810974 * (1 - exp(-0.137884 * (distance() + 12.5476)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0754161
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00110789 * (distance()) + 0.115652) * (1.18698 - exp(-(0.377412 * (distance()) + 2.53336) * (enclose() + 0.0542923 * (distance()) + 1.01044) - (0.00353864 * (distance()) + -1.61814) * (enclose() + -0.132496 * (distance()) + -1.10195) * (enclose() + -0.132496 * (distance()) + -1.10195)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0810974 * (1 - exp(-0.137884 * (distance() + 12.5476)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0604849 * (1.18698 - exp(-4.34494 * (enclose() + 1.27104) - -1.60115 * (enclose() + -1.73793) * (enclose() + -1.73793)) + 0.000114652)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmetcap routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.45948 - 2.41282 * (distance())) + 0.00188802 / pow(distance() , 2.038)) * 1.56241 * pow((width1() + width2()) / 2 , 0.00561782)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet4 INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0351623 * (1 - exp(-1.93514 * (distance() + -0.117144)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0359287
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (7.65541e-05 * (distance()) + 0.0738261) * (0.937481 - exp(-(0.562429 * (distance()) + 0.628404) * (enclose() + -0.0227463 * (distance()) + 0.205227) - (-0.0130949 * (distance()) + 0.0811742) * (enclose() + 0.808977 * (distance()) + 1.59597) * (enclose() + 0.808977 * (distance()) + 1.59597)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0351623 * (1 - exp(-1.93514 * (distance() + -0.117144)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0371044 * (0.937481 - exp(-3.44055 * (enclose() + 0.0914955) - 0.0156997 * (enclose() + 5.64086) * (enclose() + 5.64086)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmetcap INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.048307 * (1 - exp(-2.0479 * (distance() + -0.0625121)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0493629
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00295583 * (distance()) + 0.830098) * (0.116146 - exp(-(0.570149 * (distance()) + 0.930062) * (enclose() + -0.952716 * (distance()) + 1.83959) - (0.0018273 * (distance()) + 0.00976097) * (enclose() + 4.02217 * (distance()) + 6.95053) * (enclose() + 4.02217 * (distance()) + 6.95053)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.048307 * (1 - exp(-2.0479 * (distance() + -0.0625121)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.407659 * (0.116146 - exp(-3.78081 * (enclose() + -2.92399) - 0.0188975 * (enclose() + 27.0614) * (enclose() + 27.0614)) + 0.000111444)
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE NEARBODY routingpoly routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = length() * (0.0463868 * exp(-1.18834 * (distance()) - (1.04602 * (distance())) / (distance()))) / pow(distance() , -0.0583098)
]
CAPACITANCE NEARBODY routingpoly2 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = length() * (0.0569265 * exp(-1.36516 * (distance()) - (1.11407 * (distance())) / (distance()))) / pow(distance() , -0.075332)
]
CAPACITANCE NEARBODY routingmet1 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = length() * (0.0669153 * exp(-2.3145 * (distance()) - (0.913254 * (distance())) / (distance()))) / pow(distance() , -0.115467)
]
CAPACITANCE NEARBODY routingmet2 routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = length() * (0.0245109 * exp(-4.56464 * (distance()) - (0.639957 * (distance())) / (distance()))) / pow(distance() , 0.474463)
]
CAPACITANCE NEARBODY routingmetcap routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.00315997 * exp(-1.1903 * (distance()) - (2.1736 * (distance())) / (distance()))) / pow(distance() , 0.98886)
]
CAPACITANCE NEARBODY routingmetcap routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.041968 * exp(-1.56178 * (distance()) - (0.176979 * (distance())) / (distance()))) / pow(distance() , -0.0714506)
]
CAPACITANCE CROSSOVER PLATE routingmetcap pdiff  MASK
[
    PROPERTY C
    C = 0.0124303 * area()
]
CAPACITANCE CROSSOVER FRINGE routingmetcap pdiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348639 * (1 - exp(-0.202137 * (distance() + 0.503041)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0370247
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.50032 - 0.306956 * (distance())) + 0.0320333 / pow(distance() , 0.632668)) * 0.799532 * pow((width1() + width2()) / 2 , 0.137594)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.16948 - 1.46925 * (distance())) + 0.00529227 / pow(distance() , 1.5981)) * 1.0354 * pow((width1() + width2()) / 2 , 0.138586)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmetcap INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00838435
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00064516 * (distance()) + 0.0196773) * (0.940018 - exp(-(0.0498317 * (distance()) + 0.45828) * (enclose() + 0.534151 * (distance()) + -0.326029) - (0.00493154 * (distance()) + -0.0635957) * (enclose() + -1.3065 * (distance()) + 1.08337) * (enclose() + -1.3065 * (distance()) + 1.08337)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00822575 * (0.940018 - exp(-0.707439 * (enclose() + 2.34473) - -0.038938 * (enclose() + -5.44913) * (enclose() + -5.44913)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0458599 * (1 - exp(-1.50391 * (distance() + 0.0782329)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0483778
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.04794 - 1.24381 * (distance())) + 0.00417245 / pow(distance() , 1.60601)) * 1.02486 * pow((width1() + width2()) / 2 , 0.0825399)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmetcap INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0113161
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00086538 * (distance()) + 0.0294173) * (0.859768 - exp(-(0.0140524 * (distance()) + 0.403244) * (enclose() + 0.983466 * (distance()) + -0.487953) - (0.00711743 * (distance()) + -0.0960181) * (enclose() + -1.05311 * (distance()) + 0.290928) * (enclose() + -1.05311 * (distance()) + 0.290928)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125452 * (0.859768 - exp(-0.473506 * (enclose() + 4.42938) - -0.0604309 * (enclose() + -4.97462) * (enclose() + -4.97462)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0320318 * (1 - exp(-1.10842 * (distance() + 0.0044356)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0334332
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.74426 - 1.16706 * (distance())) + 0.00577739 / pow(distance() , 1.75265)) * 1.43892 * pow((width1() + width2()) / 2 , 0.0295963)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmetcap INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0256771
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00160737 * (distance()) + 0.0993621) * (0.454987 - exp(-(-0.0496403 * (distance()) + 0.0308965) * (enclose() + 6.54606 * (distance()) + 4.77843) - (0.00158747 * (distance()) + 0.0608077) * (enclose() + 1.84423 * (distance()) + 2.50816) * (enclose() + 1.84423 * (distance()) + 2.50816)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0536995 * (0.454987 - exp(0.217305 * (enclose() + 37.5087) - 0.0687451 * (enclose() + 11.7293) * (enclose() + 11.7293)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0304295 * (1 - exp(-0.835018 * (distance() + -0.0699359)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0306969
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.02322 - 1.33945 * (distance())) + 0.00582213 / pow(distance() , 1.79978)) * 1.30648 * pow((width1() + width2()) / 2 , 0.0598264)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0971571
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00508102 * (distance()) + 0.203942) * (0.801395 - exp(-(0.898776 * (distance()) + 1.62184) * (enclose() + -0.224452 * (distance()) + 0.0995137) - (0.00671556 * (distance()) + 0.0926532) * (enclose() + 0.997434 * (distance()) + 2.51245) * (enclose() + 0.997434 * (distance()) + 2.51245)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.114674 * (0.801395 - exp(-6.11572 * (enclose() + -1.02275) - 0.126231 * (enclose() + 7.49962) * (enclose() + 7.49962)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0114176 * (1 - exp(-1.11944 * (distance() + -0.0561774)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0118811
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.28718 - 1.09435 * (distance())) + 0.00774122 / pow(distance() , 1.67388)) * 0.710539 * pow((width1() + width2()) / 2 , 0.0103477)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0533118
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00017335 * (distance()) + 0.103584) * (0.962186 - exp(-(1.20734 * (distance()) + 1.65767) * (enclose() + 0.0859913 * (distance()) + 0.283289) - (-0.00212998 * (distance()) + -0.630102) * (enclose() + 0.458405 * (distance()) + 0.393214) * (enclose() + 0.458405 * (distance()) + 0.393214)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.051376 * (0.962186 - exp(-7.4529 * (enclose() + 0.696047) - -0.640326 * (enclose() + 2.59356) * (enclose() + 2.59356)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0139532 * (1 - exp(-0.0466974 * (distance() + 6.38408)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.00558447
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF pdiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.00439 - 0.772828 * (distance())) + 0.00628635 / pow(distance() , 1.46294)) * 1.00986 * pow((width1() + width2()) / 2 , 0.00345354)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0263932
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0033127 * (distance()) + 0.104541) * (0.418485 - exp(-(0.33105 * (distance()) + 0.472719) * (enclose() + 5.3218e-05 * (distance()) + 1.73153) - (-0.0182584 * (distance()) + -0.0294399) * (enclose() + 0.329794 * (distance()) + 2.59543) * (enclose() + 0.329794 * (distance()) + 2.59543)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.060221 * (0.418485 - exp(-2.06176 * (enclose() + 1.73179) - -0.11708 * (enclose() + 4.17844) * (enclose() + 4.17844)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap pdiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0125763 * (1 - exp(-0.621617 * (distance() + -0.090366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.012779
    }
]
CAPACITANCE CROSSOVER PLATE routingmetcap ndiff  MASK
[
    PROPERTY C
    C = 0.0124303 * area()
]
CAPACITANCE CROSSOVER FRINGE routingmetcap ndiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348639 * (1 - exp(-0.202137 * (distance() + 0.503041)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0370247
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.50032 - 0.306956 * (distance())) + 0.0320333 / pow(distance() , 0.632668)) * 0.799532 * pow((width1() + width2()) / 2 , 0.137594)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.16948 - 1.46925 * (distance())) + 0.00529227 / pow(distance() , 1.5981)) * 1.0354 * pow((width1() + width2()) / 2 , 0.138586)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmetcap INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00838435
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00064516 * (distance()) + 0.0196773) * (0.940018 - exp(-(0.0498317 * (distance()) + 0.45828) * (enclose() + 0.534151 * (distance()) + -0.326029) - (0.00493154 * (distance()) + -0.0635957) * (enclose() + -1.3065 * (distance()) + 1.08337) * (enclose() + -1.3065 * (distance()) + 1.08337)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0078392 * (1 - exp(-1.36547 * (distance() + 0.0343617)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00822575 * (0.940018 - exp(-0.707439 * (enclose() + 2.34473) - -0.038938 * (enclose() + -5.44913) * (enclose() + -5.44913)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0458599 * (1 - exp(-1.50391 * (distance() + 0.0782329)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0483778
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.04794 - 1.24381 * (distance())) + 0.00417245 / pow(distance() , 1.60601)) * 1.02486 * pow((width1() + width2()) / 2 , 0.0825399)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmetcap INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0113161
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00086538 * (distance()) + 0.0294173) * (0.859768 - exp(-(0.0140524 * (distance()) + 0.403244) * (enclose() + 0.983466 * (distance()) + -0.487953) - (0.00711743 * (distance()) + -0.0960181) * (enclose() + -1.05311 * (distance()) + 0.290928) * (enclose() + -1.05311 * (distance()) + 0.290928)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0107966 * (1 - exp(-1.06893 * (distance() + -0.00720489)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125452 * (0.859768 - exp(-0.473506 * (enclose() + 4.42938) - -0.0604309 * (enclose() + -4.97462) * (enclose() + -4.97462)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0320318 * (1 - exp(-1.10842 * (distance() + 0.0044356)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0334332
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.74426 - 1.16706 * (distance())) + 0.00577739 / pow(distance() , 1.75265)) * 1.43892 * pow((width1() + width2()) / 2 , 0.0295963)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmetcap INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0256771
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00160737 * (distance()) + 0.0993621) * (0.454987 - exp(-(-0.0496403 * (distance()) + 0.0308965) * (enclose() + 6.54606 * (distance()) + 4.77843) - (0.00158747 * (distance()) + 0.0608077) * (enclose() + 1.84423 * (distance()) + 2.50816) * (enclose() + 1.84423 * (distance()) + 2.50816)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0254655 * (1 - exp(-0.811495 * (distance() + -0.0766158)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0536995 * (0.454987 - exp(0.217305 * (enclose() + 37.5087) - 0.0687451 * (enclose() + 11.7293) * (enclose() + 11.7293)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0304295 * (1 - exp(-0.835018 * (distance() + -0.0699359)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0306969
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff routingmetcap MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.02322 - 1.33945 * (distance())) + 0.00582213 / pow(distance() , 1.79978)) * 1.30648 * pow((width1() + width2()) / 2 , 0.0598264)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmetcap INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0971571
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00508102 * (distance()) + 0.203942) * (0.801395 - exp(-(0.898776 * (distance()) + 1.62184) * (enclose() + -0.224452 * (distance()) + 0.0995137) - (0.00671556 * (distance()) + 0.0926532) * (enclose() + 0.997434 * (distance()) + 2.51245) * (enclose() + 0.997434 * (distance()) + 2.51245)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0936496 * (1 - exp(-1.3945 * (distance() + 0.345514)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.114674 * (0.801395 - exp(-6.11572 * (enclose() + -1.02275) - 0.126231 * (enclose() + 7.49962) * (enclose() + 7.49962)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff INSIDE OF routingmetcap MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0114176 * (1 - exp(-1.11944 * (distance() + -0.0561774)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0118811
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.28718 - 1.09435 * (distance())) + 0.00774122 / pow(distance() , 1.67388)) * 0.710539 * pow((width1() + width2()) / 2 , 0.0103477)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0533118
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00017335 * (distance()) + 0.103584) * (0.962186 - exp(-(1.20734 * (distance()) + 1.65767) * (enclose() + 0.0859913 * (distance()) + 0.283289) - (-0.00212998 * (distance()) + -0.630102) * (enclose() + 0.458405 * (distance()) + 0.393214) * (enclose() + 0.458405 * (distance()) + 0.393214)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0509479 * (1 - exp(-1.217 * (distance() + 0.219951)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.051376 * (0.962186 - exp(-7.4529 * (enclose() + 0.696047) - -0.640326 * (enclose() + 2.59356) * (enclose() + 2.59356)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0139532 * (1 - exp(-0.0466974 * (distance() + 6.38408)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.00558447
    }
]
CAPACITANCE NEARBODY routingmetcap INSIDE OF ndiff routingmet4 MASK
[
    PROPERTY C
    max_calwidth = 16 // For reference
    max_caldistance = 4.8 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.00439 - 0.772828 * (distance())) + 0.00628635 / pow(distance() , 1.46294)) * 1.00986 * pow((width1() + width2()) / 2 , 0.00345354)
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingmet4 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_calenclose = 4.8 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0263932
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0033127 * (distance()) + 0.104541) * (0.418485 - exp(-(0.33105 * (distance()) + 0.472719) * (enclose() + 5.3218e-05 * (distance()) + 1.73153) - (-0.0182584 * (distance()) + -0.0294399) * (enclose() + 0.329794 * (distance()) + 2.59543) * (enclose() + 0.329794 * (distance()) + 2.59543)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0259545 * (1 - exp(-0.627767 * (distance() + -0.084117)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.060221 * (0.418485 - exp(-2.06176 * (enclose() + 1.73179) - -0.11708 * (enclose() + 4.17844) * (enclose() + 4.17844)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap ndiff INSIDE OF routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0125763 * (1 - exp(-0.621617 * (distance() + -0.090366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.012779
    }
]
CAPACITANCE CROSSOVER PLATE routingmetcap routingnwell MASK 
[
    PROPERTY C
    C = 0.0124303 * area()
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0348639 * (1 - exp(-0.202137 * (distance() + 0.503041)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0370247
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmetcap MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0458599 * (1 - exp(-1.50391 * (distance() + 0.0782329)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0483778
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmetcap MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0320318 * (1 - exp(-1.10842 * (distance() + 0.0044356)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0334332
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmetcap MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0304295 * (1 - exp(-0.835018 * (distance() + -0.0699359)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0306969
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell INSIDE OF routingmetcap MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0114176 * (1 - exp(-1.11944 * (distance() + -0.0561774)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0118811
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0139532 * (1 - exp(-0.0466974 * (distance() + 6.38408)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.00558447
    }
]
CAPACITANCE CROSSOVER FRINGE routingmetcap routingnwell INSIDE OF routingmet4 MASK 
[
    PROPERTY C
    max_caldistance = 4.8 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0125763 * (1 - exp(-0.621617 * (distance() + -0.090366)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.012779
    }
]
//==========================================================================




#ELSE
//=============================================================================
//                             c35b3_worst
//=============================================================================
// Comments: use max thickness for connecting layer and worst (or min) oxid 
//=============================================================================


#IFDEF PEXSWITCH
CAPACITANCE ORDER nwdiode_shield routingnwell ndiff pdiff trans_shield 
                  routingpoly routingpoly_rblock routingpoly2 routingpoly2_rblock  routingmet1 routingmet1_rblock
                  routingmet2 routingmet2_rblock cmim_shield routingmetcap 
                  routingmet3 
#ELSE
CAPACITANCE ORDER nwdiode_shield routingnwell ndiff pdiff trans_shield routingpoly routingpoly2 routingmet1
                  routingmet2 cmim_shield routingmetcap routingmet3 MASK 
#ENDIF

//
// dummy statements for xrc transition : see MENTOR doc
//
// trans_shield not necessary because between 2 layers with capacitance statements ( app Note 0335 )
// nwdiode_shield is necessary
//
CAPACITANCE CROSSOVER PLATE trans_shield routingpoly MASK
[
    PROPERTY C
    C = 0
]
CAPACITANCE CROSSOVER PLATE nwdiode_shield routingnwell MASK
[
    PROPERTY C
    C = 0
]
CAPACITANCE CROSSOVER PLATE cmim_shield routingmet2 MASK
[
    PROPERTY C
    C = 0
]
//
//=========================================================================
// worst case 

// sheet resistances
//
// RMET_      = MET1 sheet resistance [mW/o]                           
// RMET_max   = 120                              
// RMET2_     = MET2 sheet resistance [mW/o]                            
// RMET2_max  = 120                               
// RMET3T_     = MET3 sheet resistance (top metal) [mW/o]                            
// RMET3T_max  = 100                               
// RPOLY_     = POLY1 sheet resistance [W/o]                           
// RPOLY_max  = 11                              
// RPOLY2_     = POLY2 sheet resistance [W/o]                           
// RPOLY2_max  = 60                              
//
RESISTANCE SHEET routingmet3 [ 0.1  0 ] MASK 
RESISTANCE SHEET routingmet2 [ 0.12  0 ] MASK 
RESISTANCE SHEET routingmet1 [ 0.12  0 ] MASK 
RESISTANCE SHEET routingpoly [ 11  0 ] MASK 
RESISTANCE SHEET routingpoly2 [ 60  0 ] MASK 
//
// resistance connection
//
// RVIA_      = VIA resistance 0.5x0.5m [W/via]
// RVIA_max   = 3
// RVIA2_     = VIA2 resistance 0.5x0.5m [W/via]
// RVIA2_max  = 3
// RVIA3_    = VIA3 resistance 0.5x0.5m [W/via]
// RVIA3_max = 3
// RCNTMP2_   = MET1-POLY2 cont. resistance 0.4x0.4m [W/cnt]
// RCNTMP2_max = 40
// RCNTMP_     = MET1-POLY1 cont. resistance 0.4x0.4m [W/cnt]
// RCNTMP_max  = 10
// RCNTMDP_    = MET1-PDIFF cont. resistance 0.4x0.4m [W/cnt]
// RCNTMDP_max = 150
// RCNTMDN_    = MET1-NDIFF cont. resistance 0.4x0.4m [W/cnt]
// RCNTMDN_max = 100

RESISTANCE CONNECTION routingmet3 routingmet2 [ 0.75 0 ] MASK 
RESISTANCE CONNECTION routingmet2 routingmet1 [ 0.75 0 ] MASK // 6/4
RESISTANCE CONNECTION routingmet1 routingpoly2 [ 6.4 0 ] MASK // 40/6.25 
RESISTANCE CONNECTION routingmet1 routingpoly [ 1.6 0 ] MASK   // 20/6.25 
//metal1-p+ cnt.res.1/1 = RCNTMDP =150*0.4^2
RESISTANCE CONNECTION routingmet1 pdiff [ 24 0 ] MASK
//metal1-n+ cnt.res.1/1 = RCNTMDN =100*0.4^2
RESISTANCE CONNECTION routingmet1 ndiff [ 16 0 ] MASK
//
//==========================================================================
//==========================================================================================
//
// Generated on Fri Jan  3 14:35:47 2003 by xCalibrate v9.3_1.1 Fri Dec 13 15:14:57 PST 2002
//
// Generated on Fri Jan  3 14:35:47 2003 by xCalibrate v9.3_1.1 Fri Dec 13 15:14:57 PST 2002
//
// Comments: 
//
// Technology name: c35b3_worst
// Precision: 1000
// DBU Size: 1e-09
// DB Magnification: 1
// Capacitance Units: ff
// Background Dielectric: 1
// Stacking Mode: Unconditional
//
// Following line(s) should be in your rulesfile
// UNIT CAPACITANCE ff
// Above line(s) should be in your rulesfile
//
// 
// Background dielectric = 1
// 
// Profile = field
// Layers =  (field_base field_base_diel routingpoly routingpoly_diel routingpoly2 routingpoly2_diel routingmet1 routingmet1_diel routingmet2 routingmet2_diel routingmet3 routingmet3_diel)
// 
//     Z-COORD              NAME TYPE THICKNESS   DIEL   WIDTH   SPACE  
//                                                                
//  --- 5.3390  ---------------------------------------------------
//  |           routingmet3_diel   D    1.0000   7.9000      
//  --- 4.3390  ---------------------------------------------------
//  |                routingmet3   C    1.0750           0.6000  0.6000 
//  --- 3.2640  ---------------------------------------------------
//  |           routingmet2_diel   D    0.4200   4.1000      
//  --- 2.8440  ---------------------------------------------------
//  |                routingmet2   C    0.7400           0.6000  0.5000 
//  --- 2.1040  ---------------------------------------------------
//  |           routingmet1_diel   D    0.4200   4.1000      
//  --- 1.6840  ---------------------------------------------------
//  |                routingmet1   C    0.7650           0.5000  0.4500 
//  --- 0.9190  ---------------------------------------------------
//  |           routingpoly2_diel   D    0.1070   4.0000      
//  --- 0.8120  ---------------------------------------------------
//  |               routingpoly2   C    0.2150           0.6500  0.5000 
//  --- 0.5970  ---------------------------------------------------
//  |           routingpoly_diel   D    0.0370   4.0000      
//  --- 0.5600  ---------------------------------------------------
//  |                routingpoly   C    0.3000           0.3500  0.4500 
//  --- 0.2600  ---------------------------------------------------
//  |            field_base_diel   D    0.2600   3.9000      
//  --- 0.0000  ---------------------------------------------------
//  |                 field_base   B    1.0000
//  --- -1.0000 ---------------------------------------------------
// 
// Background dielectric = 1
// 
// Profile = active
// Layers =  (active_base active_base_diel routingmet1 routingmet1_diel routingmet2 routingmet2_diel routingmet3 routingmet3_diel)
// 
//     Z-COORD              NAME TYPE THICKNESS   DIEL   WIDTH   SPACE  
//                                                                
//  --- 4.8240  ---------------------------------------------------
//  |           routingmet3_diel   D    1.0000   7.9000      
//  --- 3.8240  ---------------------------------------------------
//  |                routingmet3   C    1.0750           0.6000  0.6000 
//  --- 2.7490  ---------------------------------------------------
//  |           routingmet2_diel   D    0.4200   4.1000      
//  --- 2.3290  ---------------------------------------------------
//  |                routingmet2   C    0.7400           0.6000  0.5000 
//  --- 1.5890  ---------------------------------------------------
//  |           routingmet1_diel   D    0.4200   4.1000      
//  --- 1.1690  ---------------------------------------------------
//  |                routingmet1   C    0.7650           0.5000  0.4500 
//  --- 0.4040  ---------------------------------------------------
//  |           active_base_diel   D    0.4040   3.9000      
//  --- 0.0000  ---------------------------------------------------
//  |                active_base   B    1.0000
//  --- -1.0000 ---------------------------------------------------
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingpoly
//
CAPACITANCE INTRINSIC PLATE routingpoly MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE INTRINSIC PLATE routingpoly2 MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet1
//
CAPACITANCE INTRINSIC PLATE routingmet1 MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet2
//
CAPACITANCE INTRINSIC PLATE routingmet2 MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
//
//  model: 2  target: intrinsicp  profile: field  layers: field_base,routingmet3
//
CAPACITANCE INTRINSIC PLATE routingmet3 MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingpoly
//
CAPACITANCE INTRINSIC FRINGE routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0533182 * (1 - exp(-1.33893 * (distance() + 0.148442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565815
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingpoly
//
CAPACITANCE NEARBODY routingpoly WITH SHIELD routingpoly MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.92412 - 1.4484 * (distance())) + 0.0141984 / pow(distance() , 1.07281)) * 1.08223 * pow((width1() + width2()) / 2 , 0.218424)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0422798 * (1 - exp(-0.890278 * (distance() + 0.170706)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0455058
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingpoly2
//
CAPACITANCE NEARBODY routingpoly2 WITH SHIELD routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.83085 - 0.957379 * (distance())) + 0.0193739 / pow(distance() , 0.899715)) * 0.893019 * pow((width1() + width2()) / 2 , 0.24292)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0450494 * (1 - exp(-0.574688 * (distance() + 0.154681)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499344
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet1
//
CAPACITANCE NEARBODY routingmet1 WITH SHIELD routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.28188 - 0.742931 * (distance())) + 0.0240886 / pow(distance() , 0.937527)) * 1.65197 * pow((width1() + width2()) / 2 , 0.123818)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0357864 * (1 - exp(-0.295694 * (distance() + 0.624035)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0408262
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet2
//
CAPACITANCE NEARBODY routingmet2 WITH SHIELD routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.84301 - 0.276079 * (distance())) + 0.0307706 / pow(distance() , 0.893614)) * 1.34417 * pow((width1() + width2()) / 2 , 0.177463)
]
//
//  model: 34  target: intrinsic  profile: field  layers: field_base,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0693045 * (1 - exp(-0.0734097 * (distance() + 0.703101)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0410173
    }
]
//
//  model: 34  target: nearbody  profile: field  layers: field_base,routingmet3
//
CAPACITANCE NEARBODY routingmet3 WITH SHIELD routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.73959 - 0.360881 * (distance())) + 0.0495177 / pow(distance() , 0.942645)) * 1.93285 * pow((width1() + width2()) / 2 , 0.0655314)
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed
//CAPACITANCE CROSSOVER PLATE routingpoly routingpoly2 MASK
//[
//    PROPERTY C
//    C = 0.957189 * area()
//]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet1 MASK
[
    PROPERTY C
    C = 0.0986518 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet2 MASK
[
    PROPERTY C
    C = 0.0233756 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingpoly routingmet3 MASK
[
    PROPERTY C
    C = 0.0133808 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet1 MASK
[
    PROPERTY C
    C = 0.330991 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet2 MASK
[
    PROPERTY C
    C = 0.0280392 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet3 MASK
[
    PROPERTY C
    C = 0.0147887 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER PLATE routingmet1 routingmet2 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingmet1 routingmet3 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
//
//  model: 3  target: crossoverp  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER PLATE routingmet2 routingmet3 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03116 - 5.62857 * (distance())) + 0.00065198 / pow(distance() , 2.11905)) * 0.85003 * pow((width1() + width2()) / 2 , 0.0082893)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0700918
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00082073 * (distance()) + 0.113859) * (1.15836 - exp(-(-0.302079 * (distance()) + 6.32524) * (enclose() + 0.222872 * (distance()) + 0.333159) - (0.153973 * (distance()) + -1.71302) * (enclose() + -0.318607 * (distance()) + -0.997555) * (enclose() + -0.318607 * (distance()) + -0.997555)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0589813 * (1.15836 - exp(-4.81485 * (enclose() + 1.44752) - -0.943155 * (enclose() + -2.59059) * (enclose() + -2.59059)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.024662 * (1 - exp(-4.6047 * (distance() + -0.0706887)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0253567
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30725 - 3.5738 * (distance())) + 0.00091173 / pow(distance() , 1.79762)) * 1.05026 * pow((width1() + width2()) / 2 , 0.00833953)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0277421
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00123485 * (distance()) + 0.0916649) * (0.609678 - exp(-(1.28099 * (distance()) + 1.16696) * (enclose() + -0.0519127 * (distance()) + 0.516113) - (-0.205554 * (distance()) + 0.0351685) * (enclose() + 0.0612739 * (distance()) + 0.51121) * (enclose() + 0.0612739 * (distance()) + 0.51121)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0427453 * (0.609678 - exp(-7.57191 * (enclose() + 0.25655) - -0.992601 * (enclose() + 0.81758) * (enclose() + 0.81758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329537 * (1 - exp(-3.08699 * (distance() + -0.0859136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0340044
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.95108 - 1.78558 * (distance())) + 0.0035688 / pow(distance() , 1.73217)) * 1.04594 * pow((width1() + width2()) / 2 , 0.0987907)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114012
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00062599 * (distance()) + 0.0282508) * (0.851304 - exp(-(0.0196217 * (distance()) + 0.573508) * (enclose() + 1.02061 * (distance()) + -0.308989) - (0.0113928 * (distance()) + -0.131409) * (enclose() + -1.1941 * (distance()) + 0.303697) * (enclose() + -1.1941 * (distance()) + 0.303697)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125604 * (0.851304 - exp(-0.671617 * (enclose() + 4.79406) - -0.074445 * (enclose() + -5.6668) * (enclose() + -5.6668)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433723 * (1 - exp(-1.69309 * (distance() + 0.0311175)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454003
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.30687 - 1.39779 * (distance())) + 0.00607293 / pow(distance() , 1.51149)) * 1.08637 * pow((width1() + width2()) / 2 , 0.152221)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0005069 * (distance()) + 0.0177632) * (0.888417 - exp(-(0.0886848 * (distance()) + 0.297385) * (enclose() + 1.11303 * (distance()) + -0.535398) - (0.0001524 * (distance()) + -0.00994877) * (enclose() + -3.71732 * (distance()) + 0.933425) * (enclose() + -3.71732 * (distance()) + 0.933425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00761435 * (0.888417 - exp(-0.740809 * (enclose() + 5.02975) - -0.00918677 * (enclose() + -17.6532) * (enclose() + -17.6532)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0467338 * (1 - exp(-1.46353 * (distance() + 0.0909925)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498603
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88474 - 3.66829 * (distance())) + 0.00074724 / pow(distance() , 2.01141)) * 1.19906 * pow((width1() + width2()) / 2 , 0.0195047)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0512272
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00040395 * (distance()) + 0.129727) * (0.743425 - exp(-(2.38895 * (distance()) + 2.42197) * (enclose() + -0.0937475 * (distance()) + 0.322652) - (0.0142326 * (distance()) + -0.0141125) * (enclose() + 1.13864 * (distance()) + 1.91914) * (enclose() + 1.13864 * (distance()) + 1.91914)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0658734 * (0.743425 - exp(-14.3667 * (enclose() + -0.146085) - 0.0570505 * (enclose() + 7.61234) * (enclose() + 7.61234)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.014603 * (1 - exp(-3.14199 * (distance() + -0.0558199)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150683
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.9096 - 1.57037 * (distance())) + 0.00240179 / pow(distance() , 1.80043)) * 1.06914 * pow((width1() + width2()) / 2 , 0.0434304)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153765
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00069049 * (distance()) + 0.0385349) * (0.849839 - exp(-(-0.0177683 * (distance()) + 0.629259) * (enclose() + 1.02687 * (distance()) + -0.344208) - (0.0267238 * (distance()) + -0.254412) * (enclose() + -0.786803 * (distance()) + 0.143556) * (enclose() + -0.786803 * (distance()) + 0.143556)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0175412 * (0.849839 - exp(-0.540417 * (enclose() + 4.79014) - -0.120793 * (enclose() + -3.79046) * (enclose() + -3.79046)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284704 * (1 - exp(-1.34592 * (distance() + -0.0506559)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0293079
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.08031 - 1.1515 * (distance())) + 0.00522465 / pow(distance() , 1.52466)) * 0.98418 * pow((width1() + width2()) / 2 , 0.0993646)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0101113
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0006614 * (distance()) + 0.0250219) * (0.863763 - exp(-(0.04188 * (distance()) + 0.347655) * (enclose() + 0.981212 * (distance()) + -0.573018) - (0.00081489 * (distance()) + -0.0367646) * (enclose() + -1.48703 * (distance()) + 0.58009) * (enclose() + -1.48703 * (distance()) + 0.58009)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0108574 * (0.863763 - exp(-0.557055 * (enclose() + 4.33304) - -0.0326902 * (enclose() + -6.85506) * (enclose() + -6.85506)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0332074 * (1 - exp(-1.04429 * (distance() + 0.0278127)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0349126
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.68792 - 1.58027 * (distance())) + 0.00376651 / pow(distance() , 1.89827)) * 1.52971 * pow((width1() + width2()) / 2 , 0.0139757)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.043468
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0011939 * (distance()) + 0.147617) * (0.583048 - exp(-(0.728225 * (distance()) + 0.715094) * (enclose() + -0.0612145 * (distance()) + 0.918083) - (-0.0648728 * (distance()) + -0.0860002) * (enclose() + 0.117649 * (distance()) + 1.28228) * (enclose() + 0.117649 * (distance()) + 1.28228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0708238 * (0.583048 - exp(-4.35622 * (enclose() + 0.612011) - -0.410364 * (enclose() + 1.87053) * (enclose() + 1.87053)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245614 * (1 - exp(-1.14739 * (distance() + -0.101931)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0252163
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78384 - 1.05622 * (distance())) + 0.00733765 / pow(distance() , 1.65476)) * 1.38387 * pow((width1() + width2()) / 2 , 0.0382314)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222104
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00076785 * (distance()) + 0.0386978) * (0.983519 - exp(-(0.0442796 * (distance()) + 0.345236) * (enclose() + -0.419508 * (distance()) + 0.140541) - (0.00906205 * (distance()) + -0.00466239) * (enclose() + -0.194923 * (distance()) + 8.0244) * (enclose() + -0.194923 * (distance()) + 8.0244)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0212685 * (0.983519 - exp(-0.566634 * (enclose() + -1.957) - 0.0406479 * (enclose() + 7.04978) * (enclose() + 7.04978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324035 * (1 - exp(-0.753984 * (distance() + -0.0428812)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032845
    }
]
//
//  model: 36  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91041 - 1.14126 * (distance())) + 0.00720325 / pow(distance() , 1.67481)) * 1.38905 * pow((width1() + width2()) / 2 , 0.0442762)
]
//
//  model: 36  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495344
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0104668 * (distance()) + 0.366574) * (0.225389 - exp(-(-0.0771219 * (distance()) + -0.00327448) * (enclose() + 12.2531 * (distance()) + 15.212) - (0.00085829 * (distance()) + 0.0463663) * (enclose() + 3.94279 * (distance()) + 5.50309) * (enclose() + 3.94279 * (distance()) + 5.50309)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.209454 * (0.225389 - exp(0.388884 * (enclose() + 76.4775) - 0.0506578 * (enclose() + 25.217) * (enclose() + 25.217)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 36  target: intrinsic  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE INTRINSIC FRINGE routingmet2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0147012 * (1 - exp(-0.838423 * (distance() + -0.0628417)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151563
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-5.05761 - 1.4308 * (distance())) + 0.011139 / pow(distance() , 1.03589)) * 0.935494 * pow((width1() + width2()) / 2 , 0.408604)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.089228 * (1 - exp(-1.65306 * (distance() + 0.51561)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0980721
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00643653 * (distance()) + 0.128673) * (1.10668 - exp(-(-0.667145 * (distance()) + 5.55403) * (enclose() + -0.0593734 * (distance()) + 0.682695) - (0.00254233 * (distance()) + -0.516839) * (enclose() + 0.31739 * (distance()) + -2.50623) * (enclose() + 0.31739 * (distance()) + -2.50623)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.089228 * (1 - exp(-1.65306 * (distance() + 0.51561)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0804278 * (1.10668 - exp(-2.2183 * (enclose() + 0.385828) - -0.504127 * (enclose() + -0.91928) * (enclose() + -0.91928)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.46593 - 1.06044 * (distance())) + 0.0163701 / pow(distance() , 1.02641)) * 2.02409 * pow((width1() + width2()) / 2 , 0.135459)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0603977 * (1 - exp(-0.889051 * (distance() + 0.135608)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0683388
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.018001 * (distance()) + 0.26275) * (0.658307 - exp(-(0.627321 * (distance()) + 0.681343) * (enclose() + 0.304392 * (distance()) + 0.692432) - (0.00802083 * (distance()) + -0.219692) * (enclose() + 1.18719 * (distance()) + 0.618041) * (enclose() + 1.18719 * (distance()) + 0.618041)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0603977 * (1 - exp(-0.889051 * (distance() + 0.135608)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0863725 * (0.658307 - exp(-3.81795 * (enclose() + 2.21439) - -0.179588 * (enclose() + 6.55399) * (enclose() + 6.55399)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.98926 - 0.329588 * (distance())) + 0.0285095 / pow(distance() , 0.903777)) * 1.43274 * pow((width1() + width2()) / 2 , 0.175633)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.039615 * (1 - exp(-0.375563 * (distance() + 0.444163)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0474763
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0235055 * (distance()) + 0.267063) * (0.635061 - exp(-(0.188774 * (distance()) + 0.410235) * (enclose() + 0.520894 * (distance()) + 2.34422) - (0.00082759 * (distance()) + -0.0427644) * (enclose() + 1.78695 * (distance()) + 3.66142) * (enclose() + 1.78695 * (distance()) + 3.66142)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.039615 * (1 - exp(-0.375563 * (distance() + 0.444163)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0747677 * (0.635061 - exp(-1.35411 * (enclose() + 4.94869) - -0.0386264 * (enclose() + 12.5962) * (enclose() + 12.5962)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.63749 - 0.386198 * (distance())) + 0.0464568 / pow(distance() , 0.971076)) * 1.96003 * pow((width1() + width2()) / 2 , 0.0623213)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0673155 * (1 - exp(-0.0946637 * (distance() + 0.571622)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0455548
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00343034 * (distance()) + 0.0882435) * (1.04573 - exp(-(0.107188 * (distance()) + -0.0522678) * (enclose() + 0.229692 * (distance()) + -0.506545) - (0.00031696 * (distance()) + -0.024796) * (enclose() + 1.16602 * (distance()) + -2.44325) * (enclose() + 1.16602 * (distance()) + -2.44325)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0673155 * (1 - exp(-0.0946637 * (distance() + 0.571622)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.036232 * (1.04573 - exp(-0.440797 * (enclose() + 0.550038) - -0.023338 * (enclose() + 2.92044) * (enclose() + 2.92044)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.73852 - 1.25462 * (distance())) + 0.0128969 / pow(distance() , 1.08129)) * 2.20499 * pow((width1() + width2()) / 2 , 0.15587)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0843813 * (1 - exp(-1.14441 * (distance() + 0.2885)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0929775
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00774477 * (distance()) + 0.38156) * (0.451075 - exp(-(0.805703 * (distance()) + 2.61963) * (enclose() + 0.0257787 * (distance()) + 0.854123) - (0.0127077 * (distance()) + -0.57737) * (enclose() + 0.358106 * (distance()) + 1.42602) * (enclose() + 0.358106 * (distance()) + 1.42602)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0843813 * (1 - exp(-1.14441 * (distance() + 0.2885)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.171418 * (0.451075 - exp(-6.64814 * (enclose() + 0.983016) - -0.513831 * (enclose() + 3.21655) * (enclose() + 3.21655)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.99616 - 0.363535 * (distance())) + 0.0291852 / pow(distance() , 0.915161)) * 1.37131 * pow((width1() + width2()) / 2 , 0.177775)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.041887 * (1 - exp(-0.426451 * (distance() + 0.374841)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0500322
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00287469 * (distance()) + 0.155785) * (0.429744 - exp(-(0.164991 * (distance()) + 0.350982) * (enclose() + -0.231449 * (distance()) + 2.57814) - (-0.00922497 * (distance()) + -0.0159847) * (enclose() + -0.0423029 * (distance()) + 3.45431) * (enclose() + -0.0423029 * (distance()) + 3.45431)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.041887 * (1 - exp(-0.426451 * (distance() + 0.374841)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0850792 * (0.429744 - exp(-1.17594 * (enclose() + 1.4209) - -0.0621095 * (enclose() + 3.2428) * (enclose() + 3.2428)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.5811 - 0.405411 * (distance())) + 0.0465529 / pow(distance() , 0.980155)) * 1.91906 * pow((width1() + width2()) / 2 , 0.0624373)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.067421 * (1 - exp(-0.105659 * (distance() + 0.510574)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0475855
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0120018 * (distance()) + 0.0598651) * (0.460426 - exp(-(-0.0268316 * (distance()) + 0.0386692) * (enclose() + 4.42181 * (distance()) + 4.97305) - (0.00107322 * (distance()) + 0.0284893) * (enclose() + 1.35526 * (distance()) + 3.3755) * (enclose() + 1.35526 * (distance()) + 3.3755)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.067421 * (1 - exp(-0.105659 * (distance() + 0.510574)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0575367 * (0.460426 - exp(0.0847562 * (enclose() + 25.3134) - 0.0334261 * (enclose() + 9.6097) * (enclose() + 9.6097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.3409 - 0.460989 * (distance())) + 0.0251676 / pow(distance() , 1.01019)) * 1.37131 * pow((width1() + width2()) / 2 , 0.203318)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0594812 * (1 - exp(-0.771083 * (distance() + 0.244412)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0697282
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00562721 * (distance()) + 0.151064) * (0.61029 - exp(-(0.450388 * (distance()) + 0.478987) * (enclose() + -0.0452078 * (distance()) + 1.17355) - (-0.0346618 * (distance()) + -0.00911022) * (enclose() + 0.216465 * (distance()) + 1.90626) * (enclose() + 0.216465 * (distance()) + 1.90626)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0594812 * (1 - exp(-0.771083 * (distance() + 0.244412)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0896 * (0.61029 - exp(-2.73093 * (enclose() + 0.947511) - -0.182419 * (enclose() + 2.98859) * (enclose() + 2.98859)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.37558 - 0.455235 * (distance())) + 0.0407957 / pow(distance() , 1.0591)) * 1.93368 * pow((width1() + width2()) / 2 , 0.057268)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.066607 * (1 - exp(-0.178297 * (distance() + 0.30861)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0575788
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0341007 * (distance()) + 0.133527) * (0.257629 - exp(-(-0.0910222 * (distance()) + 0.147921) * (enclose() + 3.06324 * (distance()) + 4.61145) - (0.00096761 * (distance()) + 0.0312914) * (enclose() + 2.24685 * (distance()) + 3.43172) * (enclose() + 2.24685 * (distance()) + 3.43172)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.066607 * (1 - exp(-0.178297 * (distance() + 0.30861)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.145195 * (0.257629 - exp(0.270781 * (enclose() + 18.7024) - 0.0357424 * (enclose() + 13.7672) * (enclose() + 13.7672)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 37  target: nearbody  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet3 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.87602 - 0.632595 * (distance())) + 0.0315248 / pow(distance() , 1.2855)) * 1.71147 * pow((width1() + width2()) / 2 , 0.0622951)
]
//
//  model: 37  target: crossovere  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0922927 * (1 - exp(-0.458167 * (distance() + 0.165664)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0950653
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0266924 * (distance()) + 0.399596) * (0.619332 - exp(-(0.320187 * (distance()) + 0.45265) * (enclose() + 0.0609219 * (distance()) + 1.12404) - (0.0102528 * (distance()) + -0.163847) * (enclose() + 0.715453 * (distance()) + 0.633909) * (enclose() + 0.715453 * (distance()) + 0.633909)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0922927 * (1 - exp(-0.458167 * (distance() + 0.165664)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.138405 * (0.619332 - exp(-1.92551 * (enclose() + 1.40428) - -0.116684 * (enclose() + 3.92499) * (enclose() + 3.92499)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-0.313322 - 10.4847 * (distance())) + 0.00072934 / pow(distance() , 2.05805)) * 0.322106 * pow((width1() + width2()) / 2 , -0.0159822)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0356904 * (1 - exp(-0.0838661 * (distance() + 35.3468)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0349851
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (6.29221e-05 * (distance()) + 0.0795297) * (0.85409 - exp(-(-0.336118 * (distance()) + 5.88016) * (enclose() + 0.20198 * (distance()) + 0.249026) - (0.348842 * (distance()) + -3.39053) * (enclose() + -0.225709 * (distance()) + -0.470299) * (enclose() + -0.225709 * (distance()) + -0.470299)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0356904 * (1 - exp(-0.0838661 * (distance() + 35.3468)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0399222 * (0.85409 - exp(-4.19957 * (enclose() + 1.25893) - -1.64632 * (enclose() + -1.59884) * (enclose() + -1.59884)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet1
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet1 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0586765 * (1 - exp(-0.150542 * (distance() + 25.6142)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0592389
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.0001382 * (distance()) + 0.0983388) * (1.16385 - exp(-(0.0635773 * (distance()) + 6.01469) * (enclose() + 0.049411 * (distance()) + 0.886323) - (0.0360897 * (distance()) + -2.95511) * (enclose() + -0.0553108 * (distance()) + -1.26083) * (enclose() + -0.0553108 * (distance()) + -1.26083)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0586765 * (1 - exp(-0.150542 * (distance() + 25.6142)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0495149 * (1.16385 - exp(-6.33258 * (enclose() + 1.13338) - -2.77466 * (enclose() + -1.53738) * (enclose() + -1.53738)) + 8.61794e-06)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.29475 - 2.33465 * (distance())) + 0.00204334 / pow(distance() , 1.86382)) * 0.904294 * pow((width1() + width2()) / 2 , 0.0884736)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00744253 * (1 - exp(-2.28145 * (distance() + 0.0552395)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0078116
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00028786 * (distance()) + 0.0222797) * (0.686626 - exp(-(-0.00683002 * (distance()) + 1.21665) * (enclose() + 0.520386 * (distance()) + -0.0287455) - (0.0142896 * (distance()) + -0.127225) * (enclose() + -1.36349 * (distance()) + 0.73226) * (enclose() + -1.36349 * (distance()) + 0.73226)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00744253 * (1 - exp(-2.28145 * (distance() + 0.0552395)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0104202 * (0.686626 - exp(-1.1825 * (enclose() + 2.57318) - -0.055777 * (enclose() + -6.08519) * (enclose() + -6.08519)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet2
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet2 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0775909 * (1 - exp(-2.43493 * (distance() + 0.263289)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0807837
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00161167 * (distance()) + 0.125242) * (1.15772 - exp(-(0.299615 * (distance()) + 2.48247) * (enclose() + -0.0164797 * (distance()) + 1.03497) - (0.0651388 * (distance()) + -1.81623) * (enclose() + -0.0891747 * (distance()) + -1.05266) * (enclose() + -0.0891747 * (distance()) + -1.05266)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0775909 * (1 - exp(-2.43493 * (distance() + 0.263289)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0666502 * (1.15772 - exp(-3.98055 * (enclose() + 0.952571) - -1.49054 * (enclose() + -1.49853) * (enclose() + -1.49853)) + 8.88566e-05)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.45129 - 1.51237 * (distance())) + 0.0060268 / pow(distance() , 1.59569)) * 0.641754 * pow((width1() + width2()) / 2 , 0.197463)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0044147 * (1 - exp(-1.74433 * (distance() + 0.166551)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00474069
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00498331 * (distance()) + 0.0726894) * (0.917264 - exp(-(-0.0161987 * (distance()) + 0.171626) * (enclose() + 0.421824 * (distance()) + 0.3211) - (0.00319001 * (distance()) + -0.0235089) * (enclose() + 0.166562 * (distance()) + 1.21775) * (enclose() + 0.166562 * (distance()) + 1.21775)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0044147 * (1 - exp(-1.74433 * (distance() + 0.166551)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0238864 * (0.917264 - exp(-0.0906325 * (enclose() + 2.43022) - -0.00755885 * (enclose() + 2.05056) * (enclose() + 2.05056)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingpoly2,routingmet3
//
//
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly2 routingpoly INSIDE OF routingmet3 MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.082099 * (1 - exp(-1.873 * (distance() + 0.418883)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0865059
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00365876 * (distance()) + 0.126153) * (1.15008 - exp(-(0.0748729 * (distance()) + 3.34778) * (enclose() + -0.109709 * (distance()) + 0.74431) - (0.417083 * (distance()) + -2.46617) * (enclose() + 0.00482642 * (distance()) + -0.89875) * (enclose() + 0.00482642 * (distance()) + -0.89875)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.082099 * (1 - exp(-1.873 * (distance() + 0.418883)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0722234 * (1.15008 - exp(-3.72214 * (enclose() + 0.195765) - -0.380755 * (enclose() + -0.874618) * (enclose() + -0.874618)) + 0.000282095)
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.50143 - 2.14119 * (distance())) + 0.00236636 / pow(distance() , 1.989)) * 1.57038 * pow((width1() + width2()) / 2 , 0.00451179)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0371337 * (1 - exp(-1.66 * (distance() + -0.0992319)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.038089
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0027265 * (distance()) + 0.661332) * (0.112277 - exp(-(-0.18018 * (distance()) + 0.0199993) * (enclose() + 9.33479 * (distance()) + 12.6902) - (0.00148117 * (distance()) + 0.0655434) * (enclose() + 4.47035 * (distance()) + 5.16814) * (enclose() + 4.47035 * (distance()) + 5.16814)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0371337 * (1 - exp(-1.66 * (distance() + -0.0992319)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.32385 * (0.112277 - exp(0.880901 * (enclose() + 59.3641) - 0.0729493 * (enclose() + 27.5199) * (enclose() + 27.5199)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0399039 * (1 - exp(-1.71613 * (distance() + -0.0904838)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0409072
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00605138 * (distance()) + 0.120826) * (0.866639 - exp(-(2.92639 * (distance()) + 1.33886) * (enclose() + 1.28793 * (distance()) + 0.190073) - (0.00250977 * (distance()) + -0.428052) * (enclose() + 3.05359 * (distance()) + 0.651103) * (enclose() + 3.05359 * (distance()) + 0.651103)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0399039 * (1 - exp(-1.71613 * (distance() + -0.0904838)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0452845 * (0.866639 - exp(-15.9708 * (enclose() + 6.62972) - -0.415503 * (enclose() + 15.9191) * (enclose() + 15.9191)) + 0.000153702)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.83618 - 1.32203 * (distance())) + 0.00577541 / pow(distance() , 1.74409)) * 1.46165 * pow((width1() + width2()) / 2 , 0.0392005)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0177063 * (1 - exp(-0.940658 * (distance() + -0.0706445)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0183886
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00128875 * (distance()) + 0.0447987) * (0.890541 - exp(-(0.0377778 * (distance()) + 0.384631) * (enclose() + 0.900093 * (distance()) + -0.233807) - (0.00293545 * (distance()) + -0.115884) * (enclose() + -0.832662 * (distance()) + 0.424157) * (enclose() + -0.832662 * (distance()) + 0.424157)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0177063 * (1 - exp(-0.940658 * (distance() + -0.0706445)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0191775 * (0.890541 - exp(-0.57352 * (enclose() + 4.26666) - -0.101207 * (enclose() + -3.73915) * (enclose() + -3.73915)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0482279 * (1 - exp(-1.12241 * (distance() + 0.00104051)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0500319
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0143181 * (distance()) + 0.224996) * (0.620075 - exp(-(0.957946 * (distance()) + 0.959791) * (enclose() + 0.375973 * (distance()) + 0.601461) - (0.0086031 * (distance()) + -0.304717) * (enclose() + 1.2967 * (distance()) + 0.679731) * (enclose() + 1.2967 * (distance()) + 0.679731)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0482279 * (1 - exp(-1.12241 * (distance() + 0.00104051)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0767028 * (0.620075 - exp(-5.74952 * (enclose() + 2.48133) - -0.261702 * (enclose() + 7.16323) * (enclose() + 7.16323)) + 0.000608433)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.84774 - 1.29137 * (distance())) + 0.0052313 / pow(distance() , 1.80056)) * 1.48553 * pow((width1() + width2()) / 2 , 0.0288413)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingpoly MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0456345 * (1 - exp(-1.08946 * (distance() + -0.0199025)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0470196
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00050382 * (distance()) + 0.0845469) * (1.02915 - exp(-(-0.0138328 * (distance()) + 0.255336) * (enclose() + 4.5251 * (distance()) + 1.08977) - (-0.0624652 * (distance()) + -0.0476726) * (enclose() + -0.0580897 * (distance()) + -2.83009) * (enclose() + -0.0580897 * (distance()) + -2.83009)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0456345 * (1 - exp(-1.08946 * (distance() + -0.0199025)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.043533 * (1.02915 - exp(-0.186172 * (enclose() + 23.7153) - -0.359999 * (enclose() + -3.12054) * (enclose() + -3.12054)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0181668 * (1 - exp(-0.951612 * (distance() + -0.0934645)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.018716
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00393173 * (distance()) + 0.0939826) * (0.492804 - exp(-(0.258084 * (distance()) + 0.390722) * (enclose() + -0.14739 * (distance()) + 1.69471) - (-0.0165681 * (distance()) + -0.0193582) * (enclose() + 0.0210237 * (distance()) + 2.6526) * (enclose() + 0.0210237 * (distance()) + 2.6526)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0181668 * (1 - exp(-0.951612 * (distance() + -0.0934645)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.037162 * (0.492804 - exp(-1.68114 * (enclose() + 0.95776) - -0.102199 * (enclose() + 2.75772) * (enclose() + 2.75772)) + 0.00055545)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.45655 - 2.53057 * (distance())) + 0.0018378 / pow(distance() , 2.06861)) * 1.53855 * pow((width1() + width2()) / 2 , 0.00452062)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0329716 * (1 - exp(-1.98368 * (distance() + -0.106914)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.033819
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00328885 * (distance()) + 0.102826) * (0.749816 - exp(-(3.73628 * (distance()) + 1.54694) * (enclose() + 1.23972 * (distance()) + 0.148758) - (0.0034859 * (distance()) + -0.566592) * (enclose() + 2.95073 * (distance()) + 0.469865) * (enclose() + 2.95073 * (distance()) + 0.469865)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0329716 * (1 - exp(-1.98368 * (distance() + -0.106914)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0431909 * (0.749816 - exp(-20.2283 * (enclose() + 6.34736) - -0.549162 * (enclose() + 15.2235) * (enclose() + 15.2235)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet2
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0634106 * (1 - exp(-2.1735 * (distance() + 0.02863)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0649243
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00303802 * (distance()) + 0.147084) * (0.924505 - exp(-(1.2261 * (distance()) + 3.6472) * (enclose() + -0.012824 * (distance()) + 0.348076) - (0.0167269 * (distance()) + -1.20901) * (enclose() + 0.11133 * (distance()) + 0.828771) * (enclose() + 0.11133 * (distance()) + 0.828771)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0634106 * (1 - exp(-2.1735 * (distance() + 0.02863)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0659469 * (0.924505 - exp(-9.7777 * (enclose() + 0.283956) - -1.12538 * (enclose() + 1.38542) * (enclose() + 1.38542)) + 0.000101381)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 INSIDE OF routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.85924 - 1.50378 * (distance())) + 0.00510298 / pow(distance() , 1.8217)) * 1.38381 * pow((width1() + width2()) / 2 , 0.0454609)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0151429 * (1 - exp(-1.14133 * (distance() + -0.072536)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157565
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00107064 * (distance()) + 0.0411762) * (0.85056 - exp(-(0.00478416 * (distance()) + 0.421888) * (enclose() + 1.29343 * (distance()) + -0.437721) - (0.0110212 * (distance()) + -0.155559) * (enclose() + -0.819368 * (distance()) + 0.0728264) * (enclose() + -0.819368 * (distance()) + 0.0728264)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0151429 * (1 - exp(-1.14133 * (distance() + -0.072536)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0179115 * (0.85056 - exp(-0.445809 * (enclose() + 6.02943) - -0.100453 * (enclose() + -4.02401) * (enclose() + -4.02401)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet1,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet1 routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0725338 * (1 - exp(-1.42796 * (distance() + 0.163941)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0749145
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00598206 * (distance()) + 0.214348) * (0.749455 - exp(-(0.970365 * (distance()) + 2.1402) * (enclose() + -0.00051702 * (distance()) + 0.408788) - (0.0288903 * (distance()) + -0.837926) * (enclose() + 0.227679 * (distance()) + 0.590551) * (enclose() + 0.227679 * (distance()) + 0.590551)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0725338 * (1 - exp(-1.42796 * (distance() + 0.163941)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0922189 * (0.749455 - exp(-6.99202 * (enclose() + 0.406203) - -0.693474 * (enclose() + 1.72895) * (enclose() + 1.72895)) + 0.00040638)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.76247 - 1.39287 * (distance())) + 0.00428758 / pow(distance() , 1.89092)) * 1.48737 * pow((width1() + width2()) / 2 , 0.0237707)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0441212 * (1 - exp(-1.15628 * (distance() + -0.0385882)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0450805
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00097709 * (distance()) + 0.0937264) * (0.994198 - exp(-(-0.00695186 * (distance()) + 0.27246) * (enclose() + 3.25308 * (distance()) + -0.311881) - (0.0521823 * (distance()) + -0.539818) * (enclose() + -0.571721 * (distance()) + -0.270483) * (enclose() + -0.571721 * (distance()) + -0.270483)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0441212 * (1 - exp(-1.15628 * (distance() + -0.0385882)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0444205 * (0.994198 - exp(-0.237701 * (enclose() + 15.9535) - -0.278907 * (enclose() + -3.12909) * (enclose() + -3.12909)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingpoly2,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.020293 * (1 - exp(-1.03159 * (distance() + -0.108279)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0207367
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0031813 * (distance()) + 0.102787) * (0.461848 - exp(-(0.352105 * (distance()) + 0.365763) * (enclose() + -0.127491 * (distance()) + 1.68868) - (-0.0235494 * (distance()) + -0.00389139) * (enclose() + 0.0382752 * (distance()) + 3.02213) * (enclose() + 0.0382752 * (distance()) + 3.02213)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.020293 * (1 - exp(-1.03159 * (distance() + -0.108279)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0434402 * (0.461848 - exp(-2.12629 * (enclose() + 1.05123) - -0.121638 * (enclose() + 3.21351) * (enclose() + 3.21351)) + 0.000388041)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: nearbody  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 INSIDE OF routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.51281 - 2.07644 * (distance())) + 0.00247853 / pow(distance() , 1.98576)) * 1.52272 * pow((width1() + width2()) / 2 , 0.00318716)
]
//
//  model: 33  target: crossovere  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0373375 * (1 - exp(-1.62244 * (distance() + -0.0937498)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0382195
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00010558 * (distance()) + 0.292818) * (0.251962 - exp(-(-0.139991 * (distance()) + 0.0217118) * (enclose() + 8.29882 * (distance()) + 6.77747) - (0.00298832 * (distance()) + 0.0905765) * (enclose() + 2.98088 * (distance()) + 3.35638) * (enclose() + 2.98088 * (distance()) + 3.35638)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0373375 * (1 - exp(-1.62244 * (distance() + -0.0937498)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.146145 * (0.251962 - exp(0.678243 * (enclose() + 48.2716) - 0.105518 * (enclose() + 18.2608) * (enclose() + 18.2608)))
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 33  target: intrinsice  profile: field  layers: field_base,routingmet1,routingmet2,routingmet3
//
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0372477 * (1 - exp(-1.65299 * (distance() + -0.100335)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0382504
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00312798 * (distance()) + 0.138507) * (0.588239 - exp(-(0.74771 * (distance()) + 0.882108) * (enclose() + -0.0592571 * (distance()) + 0.781581) - (-0.0602176 * (distance()) + -0.157435) * (enclose() + 0.128616 * (distance()) + 0.922655) * (enclose() + 0.128616 * (distance()) + 0.922655)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0372477 * (1 - exp(-1.65299 * (distance() + -0.100335)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0614335 * (0.588239 - exp(-4.62066 * (enclose() + 0.485295) - -0.458523 * (enclose() + 1.56574) * (enclose() + 1.56574)) + 0.000158029)
    }
    if (C < 0.0) {
        C = 0
    }
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingpoly2
//
CAPACITANCE NEARBODY routingpoly routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0236172 * exp(-13.6766 * (distance()) - (0.701023 * (distance())) / (distance()))) / pow(distance() , 0.483912)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet1
//
CAPACITANCE NEARBODY routingpoly routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0224903 * exp(-4.90216 * (distance()) - (0.574146 * (distance())) / (distance()))) / pow(distance() , 0.126245)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet2
//
CAPACITANCE NEARBODY routingpoly routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0683403 * exp(-1.67053 * (distance()) - (1.55332 * (distance())) / (distance()))) / pow(distance() , -0.0415413)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly,routingmet3
//
CAPACITANCE NEARBODY routingpoly routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0644281 * exp(-0.971172 * (distance()) - (1.60512 * (distance())) / (distance()))) / pow(distance() , -0.0301716)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet1
//
CAPACITANCE NEARBODY routingpoly2 routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.00359727 * exp(-7.46938 * (distance()) - (1.97621 * (distance())) / (distance()))) / pow(distance() , 1.02489)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet2
//
CAPACITANCE NEARBODY routingpoly2 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.0494949 * exp(-2.29653 * (distance()) - (0.857948 * (distance())) / (distance()))) / pow(distance() , -0.100149)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingpoly2,routingmet3
//
CAPACITANCE NEARBODY routingpoly2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0483051 * exp(-1.14639 * (distance()) - (1.09678 * (distance())) / (distance()))) / pow(distance() , -0.0511173)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet1,routingmet2
//
CAPACITANCE NEARBODY routingmet1 routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = length() * (0.027919 * exp(-6.37276 * (distance()) - (-0.613087 * (distance())) / (distance()))) / pow(distance() , -0.177068)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet1,routingmet3
//
CAPACITANCE NEARBODY routingmet1 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0797182 * exp(-1.64764 * (distance()) - (1.56667 * (distance())) / (distance()))) / pow(distance() , -0.0507227)
]
//
//  model: 14  target: nearbody2  profile: field  layers: field_base,routingmet2,routingmet3
//
CAPACITANCE NEARBODY routingmet2 routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = length() * (0.0780694 * exp(-6.68807 * (distance()) - (-0.203098 * (distance())) / (distance()))) / pow(distance() , -0.277764)
]
//
// Done by Ahmed Gharieb (ahmed_gharieb@mentor.com)
//
CAPACITANCE CROSSOVER PLATE routingpoly pdiff  MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 pdiff  MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 pdiff  MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 pdiff  MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 pdiff  MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0533182 * (1 - exp(-1.33893 * (distance() + 0.148442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565815
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.92412 - 1.4484 * (distance())) + 0.0141984 / pow(distance() , 1.07281)) * 1.08223 * pow((width1() + width2()) / 2 , 0.218424)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0422798 * (1 - exp(-0.890278 * (distance() + 0.170706)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0455058
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.83085 - 0.957379 * (distance())) + 0.0193739 / pow(distance() , 0.899715)) * 0.893019 * pow((width1() + width2()) / 2 , 0.24292)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0450494 * (1 - exp(-0.574688 * (distance() + 0.154681)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499344
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.28188 - 0.742931 * (distance())) + 0.0240886 / pow(distance() , 0.937527)) * 1.65197 * pow((width1() + width2()) / 2 , 0.123818)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0357864 * (1 - exp(-0.295694 * (distance() + 0.624035)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0408262
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.84301 - 0.276079 * (distance())) + 0.0307706 / pow(distance() , 0.893614)) * 1.34417 * pow((width1() + width2()) / 2 , 0.177463)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 pdiff MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0693045 * (1 - exp(-0.0734097 * (distance() + 0.703101)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0410173
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.73959 - 0.360881 * (distance())) + 0.0495177 / pow(distance() , 0.942645)) * 1.93285 * pow((width1() + width2()) / 2 , 0.0655314)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03116 - 5.62857 * (distance())) + 0.00065198 / pow(distance() , 2.11905)) * 0.85003 * pow((width1() + width2()) / 2 , 0.0082893)
]
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF pdiff MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0700918
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00082073 * (distance()) + 0.113859) * (1.15836 - exp(-(-0.302079 * (distance()) + 6.32524) * (enclose() + 0.222872 * (distance()) + 0.333159) - (0.153973 * (distance()) + -1.71302) * (enclose() + -0.318607 * (distance()) + -0.997555) * (enclose() + -0.318607 * (distance()) + -0.997555)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0589813 * (1.15836 - exp(-4.81485 * (enclose() + 1.44752) - -0.943155 * (enclose() + -2.59059) * (enclose() + -2.59059)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.024662 * (1 - exp(-4.6047 * (distance() + -0.0706887)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0253567
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30725 - 3.5738 * (distance())) + 0.00091173 / pow(distance() , 1.79762)) * 1.05026 * pow((width1() + width2()) / 2 , 0.00833953)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0277421
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00123485 * (distance()) + 0.0916649) * (0.609678 - exp(-(1.28099 * (distance()) + 1.16696) * (enclose() + -0.0519127 * (distance()) + 0.516113) - (-0.205554 * (distance()) + 0.0351685) * (enclose() + 0.0612739 * (distance()) + 0.51121) * (enclose() + 0.0612739 * (distance()) + 0.51121)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0427453 * (0.609678 - exp(-7.57191 * (enclose() + 0.25655) - -0.992601 * (enclose() + 0.81758) * (enclose() + 0.81758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329537 * (1 - exp(-3.08699 * (distance() + -0.0859136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0340044
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.95108 - 1.78558 * (distance())) + 0.0035688 / pow(distance() , 1.73217)) * 1.04594 * pow((width1() + width2()) / 2 , 0.0987907)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114012
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00062599 * (distance()) + 0.0282508) * (0.851304 - exp(-(0.0196217 * (distance()) + 0.573508) * (enclose() + 1.02061 * (distance()) + -0.308989) - (0.0113928 * (distance()) + -0.131409) * (enclose() + -1.1941 * (distance()) + 0.303697) * (enclose() + -1.1941 * (distance()) + 0.303697)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125604 * (0.851304 - exp(-0.671617 * (enclose() + 4.79406) - -0.074445 * (enclose() + -5.6668) * (enclose() + -5.6668)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433723 * (1 - exp(-1.69309 * (distance() + 0.0311175)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454003
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.30687 - 1.39779 * (distance())) + 0.00607293 / pow(distance() , 1.51149)) * 1.08637 * pow((width1() + width2()) / 2 , 0.152221)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0005069 * (distance()) + 0.0177632) * (0.888417 - exp(-(0.0886848 * (distance()) + 0.297385) * (enclose() + 1.11303 * (distance()) + -0.535398) - (0.0001524 * (distance()) + -0.00994877) * (enclose() + -3.71732 * (distance()) + 0.933425) * (enclose() + -3.71732 * (distance()) + 0.933425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00761435 * (0.888417 - exp(-0.740809 * (enclose() + 5.02975) - -0.00918677 * (enclose() + -17.6532) * (enclose() + -17.6532)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0467338 * (1 - exp(-1.46353 * (distance() + 0.0909925)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498603
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88474 - 3.66829 * (distance())) + 0.00074724 / pow(distance() , 2.01141)) * 1.19906 * pow((width1() + width2()) / 2 , 0.0195047)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0512272
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00040395 * (distance()) + 0.129727) * (0.743425 - exp(-(2.38895 * (distance()) + 2.42197) * (enclose() + -0.0937475 * (distance()) + 0.322652) - (0.0142326 * (distance()) + -0.0141125) * (enclose() + 1.13864 * (distance()) + 1.91914) * (enclose() + 1.13864 * (distance()) + 1.91914)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0658734 * (0.743425 - exp(-14.3667 * (enclose() + -0.146085) - 0.0570505 * (enclose() + 7.61234) * (enclose() + 7.61234)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.014603 * (1 - exp(-3.14199 * (distance() + -0.0558199)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150683
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.9096 - 1.57037 * (distance())) + 0.00240179 / pow(distance() , 1.80043)) * 1.06914 * pow((width1() + width2()) / 2 , 0.0434304)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153765
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00069049 * (distance()) + 0.0385349) * (0.849839 - exp(-(-0.0177683 * (distance()) + 0.629259) * (enclose() + 1.02687 * (distance()) + -0.344208) - (0.0267238 * (distance()) + -0.254412) * (enclose() + -0.786803 * (distance()) + 0.143556) * (enclose() + -0.786803 * (distance()) + 0.143556)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0175412 * (0.849839 - exp(-0.540417 * (enclose() + 4.79014) - -0.120793 * (enclose() + -3.79046) * (enclose() + -3.79046)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284704 * (1 - exp(-1.34592 * (distance() + -0.0506559)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0293079
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.08031 - 1.1515 * (distance())) + 0.00522465 / pow(distance() , 1.52466)) * 0.98418 * pow((width1() + width2()) / 2 , 0.0993646)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0101113
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0006614 * (distance()) + 0.0250219) * (0.863763 - exp(-(0.04188 * (distance()) + 0.347655) * (enclose() + 0.981212 * (distance()) + -0.573018) - (0.00081489 * (distance()) + -0.0367646) * (enclose() + -1.48703 * (distance()) + 0.58009) * (enclose() + -1.48703 * (distance()) + 0.58009)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0108574 * (0.863763 - exp(-0.557055 * (enclose() + 4.33304) - -0.0326902 * (enclose() + -6.85506) * (enclose() + -6.85506)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0332074 * (1 - exp(-1.04429 * (distance() + 0.0278127)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0349126
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.68792 - 1.58027 * (distance())) + 0.00376651 / pow(distance() , 1.89827)) * 1.52971 * pow((width1() + width2()) / 2 , 0.0139757)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.043468
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0011939 * (distance()) + 0.147617) * (0.583048 - exp(-(0.728225 * (distance()) + 0.715094) * (enclose() + -0.0612145 * (distance()) + 0.918083) - (-0.0648728 * (distance()) + -0.0860002) * (enclose() + 0.117649 * (distance()) + 1.28228) * (enclose() + 0.117649 * (distance()) + 1.28228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0708238 * (0.583048 - exp(-4.35622 * (enclose() + 0.612011) - -0.410364 * (enclose() + 1.87053) * (enclose() + 1.87053)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245614 * (1 - exp(-1.14739 * (distance() + -0.101931)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0252163
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78384 - 1.05622 * (distance())) + 0.00733765 / pow(distance() , 1.65476)) * 1.38387 * pow((width1() + width2()) / 2 , 0.0382314)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222104
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00076785 * (distance()) + 0.0386978) * (0.983519 - exp(-(0.0442796 * (distance()) + 0.345236) * (enclose() + -0.419508 * (distance()) + 0.140541) - (0.00906205 * (distance()) + -0.00466239) * (enclose() + -0.194923 * (distance()) + 8.0244) * (enclose() + -0.194923 * (distance()) + 8.0244)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0212685 * (0.983519 - exp(-0.566634 * (enclose() + -1.957) - 0.0406479 * (enclose() + 7.04978) * (enclose() + 7.04978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324035 * (1 - exp(-0.753984 * (distance() + -0.0428812)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032845
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF pdiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91041 - 1.14126 * (distance())) + 0.00720325 / pow(distance() , 1.67481)) * 1.38905 * pow((width1() + width2()) / 2 , 0.0442762)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF pdiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495344
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0104668 * (distance()) + 0.366574) * (0.225389 - exp(-(-0.0771219 * (distance()) + -0.00327448) * (enclose() + 12.2531 * (distance()) + 15.212) - (0.00085829 * (distance()) + 0.0463663) * (enclose() + 3.94279 * (distance()) + 5.50309) * (enclose() + 3.94279 * (distance()) + 5.50309)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.209454 * (0.225389 - exp(0.388884 * (enclose() + 76.4775) - 0.0506578 * (enclose() + 25.217) * (enclose() + 25.217)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 pdiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0147012 * (1 - exp(-0.838423 * (distance() + -0.0628417)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151563
    }
]
CAPACITANCE CROSSOVER PLATE routingpoly ndiff  MASK
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 ndiff  MASK
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 ndiff  MASK
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 ndiff  MASK
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 ndiff  MASK
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0533182 * (1 - exp(-1.33893 * (distance() + 0.148442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565815
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.92412 - 1.4484 * (distance())) + 0.0141984 / pow(distance() , 1.07281)) * 1.08223 * pow((width1() + width2()) / 2 , 0.218424)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0422798 * (1 - exp(-0.890278 * (distance() + 0.170706)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0455058
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.83085 - 0.957379 * (distance())) + 0.0193739 / pow(distance() , 0.899715)) * 0.893019 * pow((width1() + width2()) / 2 , 0.24292)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0450494 * (1 - exp(-0.574688 * (distance() + 0.154681)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499344
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-4.28188 - 0.742931 * (distance())) + 0.0240886 / pow(distance() , 0.937527)) * 1.65197 * pow((width1() + width2()) / 2 , 0.123818)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0357864 * (1 - exp(-0.295694 * (distance() + 0.624035)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0408262
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.84301 - 0.276079 * (distance())) + 0.0307706 / pow(distance() , 0.893614)) * 1.34417 * pow((width1() + width2()) / 2 , 0.177463)
]
CAPACITANCE CROSSOVER FRINGE routingmet3 ndiff MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0693045 * (1 - exp(-0.0734097 * (distance() + 0.703101)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0410173
    }
]
CAPACITANCE NEARBODY routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 4.6 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.73959 - 0.360881 * (distance())) + 0.0495177 / pow(distance() , 0.942645)) * 1.93285 * pow((width1() + width2()) / 2 , 0.0655314)
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingpoly2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.03116 - 5.62857 * (distance())) + 0.00065198 / pow(distance() , 2.11905)) * 0.85003 * pow((width1() + width2()) / 2 , 0.0082893)
]
// removed
//CAPACITANCE CROSSOVER FRINGE routingpoly routingpoly2 INSIDE OF ndiff MASK
//[
//    PROPERTY C
//    max_caldistance = 5 // For reference
//    max_calenclose = 5 // For reference
//    max_distance = 3
//    max_enclose = 3
//    C = 0.0
//    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
//        C = length() * 0.0700918
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
//        C = length() * 0.5 * (0.00082073 * (distance()) + 0.113859) * (1.15836 - exp(-(-0.302079 * (distance()) + 6.32524) * (enclose() + 0.222872 * (distance()) + 0.333159) - (0.153973 * (distance()) + -1.71302) * (enclose() + -0.318607 * (distance()) + -0.997555) * (enclose() + -0.318607 * (distance()) + -0.997555)))
//    }
//    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
//        C = length() * 0.0682434 * (1 - exp(-4.79883 * (distance() + 0.0428661)))
//    }
//    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
//        C = length() * 0.0589813 * (1.15836 - exp(-4.81485 * (enclose() + 1.44752) - -0.943155 * (enclose() + -2.59059) * (enclose() + -2.59059)))
//    }
//    if (C < 0.0) {
//        C = 0
//    }
//]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingpoly2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.024662 * (1 - exp(-4.6047 * (distance() + -0.0706887)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0253567
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.30725 - 3.5738 * (distance())) + 0.00091173 / pow(distance() , 1.79762)) * 1.05026 * pow((width1() + width2()) / 2 , 0.00833953)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0277421
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00123485 * (distance()) + 0.0916649) * (0.609678 - exp(-(1.28099 * (distance()) + 1.16696) * (enclose() + -0.0519127 * (distance()) + 0.516113) - (-0.205554 * (distance()) + 0.0351685) * (enclose() + 0.0612739 * (distance()) + 0.51121) * (enclose() + 0.0612739 * (distance()) + 0.51121)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0268571 * (1 - exp(-3.03161 * (distance() + -0.0980045)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0427453 * (0.609678 - exp(-7.57191 * (enclose() + 0.25655) - -0.992601 * (enclose() + 0.81758) * (enclose() + 0.81758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329537 * (1 - exp(-3.08699 * (distance() + -0.0859136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0340044
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.95108 - 1.78558 * (distance())) + 0.0035688 / pow(distance() , 1.73217)) * 1.04594 * pow((width1() + width2()) / 2 , 0.0987907)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114012
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00062599 * (distance()) + 0.0282508) * (0.851304 - exp(-(0.0196217 * (distance()) + 0.573508) * (enclose() + 1.02061 * (distance()) + -0.308989) - (0.0113928 * (distance()) + -0.131409) * (enclose() + -1.1941 * (distance()) + 0.303697) * (enclose() + -1.1941 * (distance()) + 0.303697)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125604 * (0.851304 - exp(-0.671617 * (enclose() + 4.79406) - -0.074445 * (enclose() + -5.6668) * (enclose() + -5.6668)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433723 * (1 - exp(-1.69309 * (distance() + 0.0311175)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454003
    }
]
CAPACITANCE NEARBODY routingpoly INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 1.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.30687 - 1.39779 * (distance())) + 0.00607293 / pow(distance() , 1.51149)) * 1.08637 * pow((width1() + width2()) / 2 , 0.152221)
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0005069 * (distance()) + 0.0177632) * (0.888417 - exp(-(0.0886848 * (distance()) + 0.297385) * (enclose() + 1.11303 * (distance()) + -0.535398) - (0.0001524 * (distance()) + -0.00994877) * (enclose() + -3.71732 * (distance()) + 0.933425) * (enclose() + -3.71732 * (distance()) + 0.933425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00761435 * (0.888417 - exp(-0.740809 * (enclose() + 5.02975) - -0.00918677 * (enclose() + -17.6532) * (enclose() + -17.6532)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0467338 * (1 - exp(-1.46353 * (distance() + 0.0909925)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498603
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet1 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.88474 - 3.66829 * (distance())) + 0.00074724 / pow(distance() , 2.01141)) * 1.19906 * pow((width1() + width2()) / 2 , 0.0195047)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet1 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0512272
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00040395 * (distance()) + 0.129727) * (0.743425 - exp(-(2.38895 * (distance()) + 2.42197) * (enclose() + -0.0937475 * (distance()) + 0.322652) - (0.0142326 * (distance()) + -0.0141125) * (enclose() + 1.13864 * (distance()) + 1.91914) * (enclose() + 1.13864 * (distance()) + 1.91914)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0497494 * (1 - exp(-3.29881 * (distance() + 0.0193869)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0658734 * (0.743425 - exp(-14.3667 * (enclose() + -0.146085) - 0.0570505 * (enclose() + 7.61234) * (enclose() + 7.61234)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet1 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.014603 * (1 - exp(-3.14199 * (distance() + -0.0558199)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150683
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.9096 - 1.57037 * (distance())) + 0.00240179 / pow(distance() , 1.80043)) * 1.06914 * pow((width1() + width2()) / 2 , 0.0434304)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153765
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00069049 * (distance()) + 0.0385349) * (0.849839 - exp(-(-0.0177683 * (distance()) + 0.629259) * (enclose() + 1.02687 * (distance()) + -0.344208) - (0.0267238 * (distance()) + -0.254412) * (enclose() + -0.786803 * (distance()) + 0.143556) * (enclose() + -0.786803 * (distance()) + 0.143556)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0175412 * (0.849839 - exp(-0.540417 * (enclose() + 4.79014) - -0.120793 * (enclose() + -3.79046) * (enclose() + -3.79046)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284704 * (1 - exp(-1.34592 * (distance() + -0.0506559)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0293079
    }
]
CAPACITANCE NEARBODY routingpoly2 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.6 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-3.08031 - 1.1515 * (distance())) + 0.00522465 / pow(distance() , 1.52466)) * 0.98418 * pow((width1() + width2()) / 2 , 0.0993646)
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0101113
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0006614 * (distance()) + 0.0250219) * (0.863763 - exp(-(0.04188 * (distance()) + 0.347655) * (enclose() + 0.981212 * (distance()) + -0.573018) - (0.00081489 * (distance()) + -0.0367646) * (enclose() + -1.48703 * (distance()) + 0.58009) * (enclose() + -1.48703 * (distance()) + 0.58009)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0108574 * (0.863763 - exp(-0.557055 * (enclose() + 4.33304) - -0.0326902 * (enclose() + -6.85506) * (enclose() + -6.85506)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0332074 * (1 - exp(-1.04429 * (distance() + 0.0278127)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0349126
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmet2 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.68792 - 1.58027 * (distance())) + 0.00376651 / pow(distance() , 1.89827)) * 1.52971 * pow((width1() + width2()) / 2 , 0.0139757)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.043468
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0011939 * (distance()) + 0.147617) * (0.583048 - exp(-(0.728225 * (distance()) + 0.715094) * (enclose() + -0.0612145 * (distance()) + 0.918083) - (-0.0648728 * (distance()) + -0.0860002) * (enclose() + 0.117649 * (distance()) + 1.28228) * (enclose() + 0.117649 * (distance()) + 1.28228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0708238 * (0.583048 - exp(-4.35622 * (enclose() + 0.612011) - -0.410364 * (enclose() + 1.87053) * (enclose() + 1.87053)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245614 * (1 - exp(-1.14739 * (distance() + -0.101931)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0252163
    }
]
CAPACITANCE NEARBODY routingmet1 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.78384 - 1.05622 * (distance())) + 0.00733765 / pow(distance() , 1.65476)) * 1.38387 * pow((width1() + width2()) / 2 , 0.0382314)
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222104
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00076785 * (distance()) + 0.0386978) * (0.983519 - exp(-(0.0442796 * (distance()) + 0.345236) * (enclose() + -0.419508 * (distance()) + 0.140541) - (0.00906205 * (distance()) + -0.00466239) * (enclose() + -0.194923 * (distance()) + 8.0244) * (enclose() + -0.194923 * (distance()) + 8.0244)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0212685 * (0.983519 - exp(-0.566634 * (enclose() + -1.957) - 0.0406479 * (enclose() + 7.04978) * (enclose() + 7.04978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324035 * (1 - exp(-0.753984 * (distance() + -0.0428812)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032845
    }
]
CAPACITANCE NEARBODY routingmet2 INSIDE OF ndiff routingmet3 MASK
[
    PROPERTY C
    max_calwidth = 2.4 // For reference
    max_caldistance = 5 // For reference
    max_width = 3
    max_distance = 3
    C = length() * (exp(-2.91041 - 1.14126 * (distance())) + 0.00720325 / pow(distance() , 1.67481)) * 1.38905 * pow((width1() + width2()) / 2 , 0.0442762)
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 INSIDE OF ndiff MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495344
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0104668 * (distance()) + 0.366574) * (0.225389 - exp(-(-0.0771219 * (distance()) + -0.00327448) * (enclose() + 12.2531 * (distance()) + 15.212) - (0.00085829 * (distance()) + 0.0463663) * (enclose() + 3.94279 * (distance()) + 5.50309) * (enclose() + 3.94279 * (distance()) + 5.50309)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.209454 * (0.225389 - exp(0.388884 * (enclose() + 76.4775) - 0.0506578 * (enclose() + 25.217) * (enclose() + 25.217)))
    }
    if (C < 0.0) {
        C = 0
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 ndiff INSIDE OF routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0147012 * (1 - exp(-0.838423 * (distance() + -0.0628417)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151563
    }
]
CAPACITANCE CROSSOVER PLATE routingpoly routingnwell MASK 
[
    PROPERTY C
    C = 0.13281 * area()
]
CAPACITANCE CROSSOVER PLATE routingpoly2 routingnwell MASK 
[
    PROPERTY C
    C = 0.0586684 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet1 routingnwell MASK 
[
    PROPERTY C
    C = 0.0382602 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet2 routingnwell MASK 
[
    PROPERTY C
    C = 0.0170127 * area()
]
CAPACITANCE CROSSOVER PLATE routingmet3 routingnwell MASK 
[
    PROPERTY C
    C = 0.0110212 * area()
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0533182 * (1 - exp(-1.33893 * (distance() + 0.148442)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0565815
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0422798 * (1 - exp(-0.890278 * (distance() + 0.170706)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0455058
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0450494 * (1 - exp(-0.574688 * (distance() + 0.154681)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0499344
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0357864 * (1 - exp(-0.295694 * (distance() + 0.624035)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0408262
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet3 routingnwell MASK 
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0693045 * (1 - exp(-0.0734097 * (distance() + 0.703101)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0410173
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingpoly2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.024662 * (1 - exp(-4.6047 * (distance() + -0.0706887)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0253567
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet1 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0329537 * (1 - exp(-3.08699 * (distance() + -0.0859136)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0340044
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0433723 * (1 - exp(-1.69309 * (distance() + 0.0311175)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0454003
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0467338 * (1 - exp(-1.46353 * (distance() + 0.0909925)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0498603
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet1 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.014603 * (1 - exp(-3.14199 * (distance() + -0.0558199)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0150683
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0284704 * (1 - exp(-1.34592 * (distance() + -0.0506559)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0293079
    }
]
CAPACITANCE CROSSOVER FRINGE routingpoly2 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0332074 * (1 - exp(-1.04429 * (distance() + 0.0278127)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0349126
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmet2 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0245614 * (1 - exp(-1.14739 * (distance() + -0.101931)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0252163
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet1 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0324035 * (1 - exp(-0.753984 * (distance() + -0.0428812)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.032845
    }
]
CAPACITANCE CROSSOVER FRINGE routingmet2 routingnwell INSIDE OF routingmet3 MASK 
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_distance = 3
    C = 0.0
    if (distance() > 0.0) {
        C = length() * 0.0147012 * (1 - exp(-0.838423 * (distance() + -0.0628417)))
    }
    if (distance() <= 0.0) {
        C = length() * 0.0151563
    }
]

//---------------------------------------------------------------------
// n-well over base layer area and perimeter (CJNW,CJSWNW) //ghe

CAPACITANCE INTRINSIC PLATE routingnwell
 [ PROPERTY C
   C = 0.11 * AREA()
 ] MASK
CAPACITANCE INTRINSIC FRINGE routingnwell
 [ PROPERTY C
   C = 0.53 * LENGTH()
 ] MASK
#ENDIF

///////////////////////////////////////////////////////////////////////
//
//   end of XCALIBRE technology file    end of XCALIBRE technology file
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//  start of CALIBRE XRC technology file   start of CALIBRE XRC technology file
//
///////////////////////////////////////////////////////////////////////
//==========================================================================
//                             c35b4_worst
//==========================================================================
//
// all interactions between layer crossing rf device and layers blocked for res
// extraction
// 20-Jul-05  aob     created
//
///////////////////////////////////////////////////////////////////////
//
// since met2/met3/met4 is not cut by rblock we do not need this
// to get node to node caps from metal crossing device
// examples
// met2 is rblock in cvar 
//
// met2/met3/met4 over nmosrf/pmosrf
//CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet4 MASK
//
// metal over cpolyrf
//CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet4 MASK
// met2 over bipolar , mosrf
//CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet4 MASK
//
// met3/4 over cvar
//CAPACITANCE CROSSOVER PLATE routingmet2_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER PLATE routingmet2_rblock routingmet4 MASK
//
//
// following layer are used

//CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet4 MASK
//CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet4 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet2 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet4 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet2_rblock routingmet3 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet2_rblock routingmet4 MASK
//CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly2_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet1_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2_rblock MASK
//CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet2_rblock MASK


#IFDEF PEXSWITCH
#IFDEF fourmetal
// NR:449 CAPACITANCE CROSSOVER PLATE routingpoly routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0233756 * area()
]
// NR:453 end 
// NR:457 CAPACITANCE CROSSOVER PLATE routingpoly routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0133808 * area()
]
// NR:461 end 
// NR:465 CAPACITANCE CROSSOVER PLATE routingpoly routingmet4 MASK
CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet4 MASK
[
    PROPERTY C
    C = 0.00937307 * area()
]
// NR:469 end 
// NR:477 end 
// NR:481 CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0280392 * area()
]
// NR:485 end 
// NR:489 CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0147887 * area()
]
// NR:493 end 
// NR:497 CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet4 MASK
CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet4 MASK
[
    PROPERTY C
    C = 0.0100428 * area()
]
// NR:501 end 
// NR:505 CAPACITANCE CROSSOVER PLATE routingmet1 routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
// NR:509 end 
// NR:513 CAPACITANCE CROSSOVER PLATE routingmet1 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
// NR:517 end 
// NR:521 CAPACITANCE CROSSOVER PLATE routingmet1 routingmet4 MASK
CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet4 MASK
[
    PROPERTY C
    C = 0.0132487 * area()
]
// NR:525 end 
// NR:529 CAPACITANCE CROSSOVER PLATE routingmet2 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingmet2_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
// NR:533 end 
// NR:537 CAPACITANCE CROSSOVER PLATE routingmet2 routingmet4 MASK
CAPACITANCE CROSSOVER PLATE routingmet2_rblock routingmet4 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
// NR:541 end 
// NR:682 CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00059321 * (distance()) + 0.0273051) * (0.87914 - exp(-(0.0246106 * (distance()) + 0.716701) * (enclose() + 0.590434 * (distance()) + -0.181639) - (0.0126597 * (distance()) + -0.130102) * (enclose() + -1.12924 * (distance()) + 0.857723) * (enclose() + -1.12924 * (distance()) + 0.857723)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108031 * (1 - exp(-1.55182 * (distance() + -0.0156131)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0121695 * (0.87914 - exp(-0.839754 * (enclose() + 2.77053) - -0.0668035 * (enclose() + -4.78848) * (enclose() + -4.78848)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:708 end 
// NR:740 CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751819
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00056907 * (distance()) + 0.0175334) * (0.928289 - exp(-(0.0588486 * (distance()) + 0.340669) * (enclose() + 0.813125 * (distance()) + -0.508852) - (0.0013806 * (distance()) + -0.0300689) * (enclose() + -1.88705 * (distance()) + 0.97368) * (enclose() + -1.88705 * (distance()) + 0.97368)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00695145 * (1 - exp(-1.3182 * (distance() + 0.0489911)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00734403 * (0.928289 - exp(-0.634912 * (enclose() + 3.55677) - -0.0231659 * (enclose() + -8.46157) * (enclose() + -8.46157)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:766 end 
// NR:798 CAPACITANCE CROSSOVER FRINGE routingpoly routingmet4 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00564609
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00044717 * (distance()) + 0.0169127) * (0.714796 - exp(-(-0.0229817 * (distance()) + 0.320382) * (enclose() + 2.48319 * (distance()) + -1.43302) - (-0.00996399 * (distance()) + 0.0096513) * (enclose() + 0.341381 * (distance()) + -7.59785) * (enclose() + 0.341381 * (distance()) + -7.59785)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00511447 * (1 - exp(-1.25587 * (distance() + 0.0801342)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00733842 * (0.714796 - exp(-0.205474 * (enclose() + 10.9829) - -0.0401687 * (enclose() + -5.89095) * (enclose() + -5.89095)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:882 end 
// NR:914 CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153166
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00067108 * (distance()) + 0.0382259) * (0.854775 - exp(-(-0.0195501 * (distance()) + 0.670691) * (enclose() + 0.921985 * (distance()) + -0.324567) - (0.0268178 * (distance()) + -0.25127) * (enclose() + -0.787422 * (distance()) + 0.228141) * (enclose() + -0.787422 * (distance()) + 0.228141)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0148912 * (1 - exp(-1.3198 * (distance() + -0.0644451)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0174352 * (0.854775 - exp(-0.572941 * (enclose() + 4.28536) - -0.117181 * (enclose() + -3.70897) * (enclose() + -3.70897)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:940 end 
// NR:972 CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0100895
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00078214 * (distance()) + 0.0252269) * (0.887579 - exp(-(0.0294899 * (distance()) + 0.346855) * (enclose() + 0.955562 * (distance()) + -0.617052) - (0.00264508 * (distance()) + -0.0546774) * (enclose() + -1.26235 * (distance()) + 0.475899) * (enclose() + -1.26235 * (distance()) + 0.475899)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00956331 * (1 - exp(-1.00726 * (distance() + 0.0144495)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0106581 * (0.887579 - exp(-0.494305 * (enclose() + 4.16076) - -0.041452 * (enclose() + -5.83585) * (enclose() + -5.83585)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:998 end 
// NR:1030 CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet4 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00762268
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00032315 * (distance()) + 0.0236557) * (0.657312 - exp(-(-0.0281134 * (distance()) + 0.327877) * (enclose() + 2.83039 * (distance()) + -1.63104) - (-0.00915175 * (distance()) + 0.00847617) * (enclose() + 0.494566 * (distance()) + -8.6338) * (enclose() + 0.494566 * (distance()) + -8.6338)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0070558 * (1 - exp(-0.909108 * (distance() + 0.0701291)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.01102 * (0.657312 - exp(-0.18731 * (enclose() + 12.5209) - -0.0372826 * (enclose() + -6.16097) * (enclose() + -6.16097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1056 end 
// NR:1088 CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0434111
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0004589 * (distance()) + 0.132663) * (0.637158 - exp(-(0.750364 * (distance()) + 0.407317) * (enclose() + -0.0731466 * (distance()) + 0.931012) - (-0.0871715 * (distance()) + 0.023843) * (enclose() + 0.0751287 * (distance()) + 1.34571) * (enclose() + 0.0751287 * (distance()) + 1.34571)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423257 * (1 - exp(-1.26788 * (distance() + -0.056364)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0651842 * (0.637158 - exp(-4.15914 * (enclose() + 0.565279) - -0.412015 * (enclose() + 1.72135) * (enclose() + 1.72135)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1114 end 
// NR:1146 CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222844
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00141089 * (distance()) + 0.0436567) * (1.17942 - exp(-(0.0440702 * (distance()) + 0.934807) * (enclose() + -0.0309741 * (distance()) + 0.590978) - (0.00783802 * (distance()) + -0.126844) * (enclose() + -0.39932 * (distance()) + 2.68549) * (enclose() + -0.39932 * (distance()) + 2.68549)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219711 * (1 - exp(-0.710446 * (distance() + -0.0480437)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0183011 * (1.17942 - exp(-1.15516 * (enclose() + 0.436107) - -0.0876539 * (enclose() + 0.68889) * (enclose() + 0.68889)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1172 end 
// NR:1204 CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet4 MASK
CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0157949
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00224679 * (distance()) + 0.0443502) * (0.904313 - exp(-(0.0180779 * (distance()) + 0.115945) * (enclose() + 1.872 * (distance()) + -0.368864) - (-0.013945 * (distance()) + -0.00230186) * (enclose() + -0.381288 * (distance()) + -1.95374) * (enclose() + -0.381288 * (distance()) + -1.95374)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0155111 * (1 - exp(-0.563081 * (distance() + 0.0248286)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0165581 * (0.904313 - exp(-0.206335 * (enclose() + 8.99114) - -0.0720269 * (enclose() + -3.86018) * (enclose() + -3.86018)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1230 end 
// NR:1262 CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495976
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00709514 * (distance()) + 0.201546) * (0.564903 - exp(-(1.17783 * (distance()) + 1.0172) * (enclose() + 0.455213 * (distance()) + 0.648814) - (0.00625353 * (distance()) + -0.32588) * (enclose() + 1.454 * (distance()) + 0.737585) * (enclose() + 1.454 * (distance()) + 0.737585)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479281 * (1 - exp(-0.987942 * (distance() + 0.0131512)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0830352 * (0.564903 - exp(-6.90635 * (enclose() + 2.92488) - -0.294612 * (enclose() + 8.00758) * (enclose() + 8.00758)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1288 end 
// NR:1320 CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet4 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2_rblock routingmet4 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0273849
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00568176 * (distance()) + 0.0911377) * (0.429515 - exp(-(0.305497 * (distance()) + 0.319373) * (enclose() + 0.244579 * (distance()) + 2.38465) - (-0.00772209 * (distance()) + -0.00354054) * (enclose() + 0.796568 * (distance()) + 6.93653) * (enclose() + 0.796568 * (distance()) + 6.93653)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0275113 * (1 - exp(-0.513916 * (distance() + 0.0142984)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0597732 * (0.429515 - exp(-1.84686 * (enclose() + 3.60755) - -0.042151 * (enclose() + 10.9194) * (enclose() + 10.9194)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1346 end 
// NR:1521 CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0387844 * (1 - exp(-0.421096 * (distance() + 0.282879)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.045958
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0204367 * (distance()) + 0.233086) * (0.715292 - exp(-(0.246235 * (distance()) + 0.407593) * (enclose() + 0.838261 * (distance()) + 2.05812) - (0.00048205 * (distance()) + -0.0426606) * (enclose() + 2.38684 * (distance()) + 3.65792) * (enclose() + 2.38684 * (distance()) + 3.65792)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0387844 * (1 - exp(-0.421096 * (distance() + 0.282879)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0654512 * (0.715292 - exp(-1.63877 * (enclose() + 6.24943) - -0.0402503 * (enclose() + 15.5921) * (enclose() + 15.5921)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1547 end 
// NR:1563 CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0326632 * (1 - exp(-0.254861 * (distance() + 0.808996)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0401856
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00193543 * (distance()) + 0.072975) * (0.643839 - exp(-(0.103213 * (distance()) + 0.120972) * (enclose() + -0.19606 * (distance()) + 2.44602) - (-0.00524952 * (distance()) + 0.00053777) * (enclose() + -0.0542608 * (distance()) + 4.26425) * (enclose() + -0.0542608 * (distance()) + 4.26425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0326632 * (1 - exp(-0.254861 * (distance() + 0.808996)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0413261 * (0.643839 - exp(-0.637037 * (enclose() + 1.46572) - -0.0257098 * (enclose() + 3.99295) * (enclose() + 3.99295)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1589 end 
// NR:1605 CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly MASK
CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0665166 * (1 - exp(-0.0645997 * (distance() + 0.840154)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.039857
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00632068 * (distance()) + 0.0117873) * (0.88357 - exp(-(0.265222 * (distance()) + 0.144155) * (enclose() + -0.881917 * (distance()) + 0.0632331) - (0.0110067 * (distance()) + -0.00540432) * (enclose() + -0.897645 * (distance()) + -7.09166) * (enclose() + -0.897645 * (distance()) + -7.09166)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0665166 * (1 - exp(-0.0645997 * (distance() + 0.840154)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0204312 * (0.88357 - exp(-1.36418 * (enclose() + -3.99359) - 0.0452265 * (enclose() + -11.2208) * (enclose() + -11.2208)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1673 end 
// NR:1689 CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0410339 * (1 - exp(-0.475403 * (distance() + 0.22715)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.048127
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0338137 * (distance()) + 0.404305) * (0.349708 - exp(-(0.197217 * (distance()) + 0.59642) * (enclose() + 0.16461 * (distance()) + 2.79409) - (0.00280315 * (distance()) + -0.0703893) * (enclose() + 1.15095 * (distance()) + 3.16371) * (enclose() + 1.15095 * (distance()) + 3.16371)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0410339 * (1 - exp(-0.475403 * (distance() + 0.22715)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.117618 * (0.349708 - exp(-1.5825 * (enclose() + 3.61714) - -0.0563736 * (enclose() + 8.91846) * (enclose() + 8.91846)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1715 end 
// NR:1731 CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0339294 * (1 - exp(-0.272355 * (distance() + 0.742199)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0412897
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00680582 * (distance()) + 0.118765) * (0.313718 - exp(-(0.0491694 * (distance()) + 0.130942) * (enclose() + -1.76148 * (distance()) + 5.19701) - (0.00014352 * (distance()) + 0.00237084) * (enclose() + 3.70423 * (distance()) + 10.9017) * (enclose() + 3.70423 * (distance()) + 10.9017)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0339294 * (1 - exp(-0.272355 * (distance() + 0.742199)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.076397 * (0.313718 - exp(-0.376789 * (enclose() + -3.61039) - 0.00308844 * (enclose() + 29.4228) * (enclose() + 29.4228)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1757 end 
// NR:1773 CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet4 routingpoly2_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0685101 * (1 - exp(-0.0670931 * (distance() + 0.794408)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0409605
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00411421 * (distance()) + 0.0222994) * (0.982613 - exp(-(0.124256 * (distance()) + 0.0964609) * (enclose() + -0.686012 * (distance()) + 0.487762) - (0.00219139 * (distance()) + -0.0021316) * (enclose() + -0.983822 * (distance()) + -11.1014) * (enclose() + -0.983822 * (distance()) + -11.1014)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0685101 * (1 - exp(-0.0670931 * (distance() + 0.794408)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0206124 * (0.982613 - exp(-0.668038 * (enclose() + -2.66789) - 0.00794879 * (enclose() + -15.627) * (enclose() + -15.627)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1799 end 
// NR:1815 CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0584152 * (1 - exp(-0.836219 * (distance() + 0.142758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0668232
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0186823 * (distance()) + 0.36092) * (0.407099 - exp(-(0.517936 * (distance()) + 0.802604) * (enclose() + 0.155015 * (distance()) + 1.23135) - (0.0112802 * (distance()) + -0.228748) * (enclose() + 0.951289 * (distance()) + 0.829262) * (enclose() + 0.951289 * (distance()) + 0.829262)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0584152 * (1 - exp(-0.836219 * (distance() + 0.142758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.133754 * (0.407099 - exp(-3.39228 * (enclose() + 2.00643) - -0.172347 * (enclose() + 5.58571) * (enclose() + 5.58571)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1841 end 
// NR:1857 CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1 MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0393187 * (1 - exp(-0.376361 * (distance() + 0.452214)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479303
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0156531 * (distance()) + 0.126281) * (0.301231 - exp(-(-0.0808611 * (distance()) + 0.124944) * (enclose() + 3.07081 * (distance()) + 4.56842) - (0.0008519 * (distance()) + 0.0323541) * (enclose() + 2.1363 * (distance()) + 3.27874) * (enclose() + 2.1363 * (distance()) + 3.27874)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0393187 * (1 - exp(-0.376361 * (distance() + 0.452214)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.102273 * (0.301231 - exp(0.279362 * (enclose() + 19.9225) - 0.0366136 * (enclose() + 13.9602) * (enclose() + 13.9602)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1883 end 
// NR:1899 CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet1 MASK
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet1_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0692095 * (1 - exp(-0.0900198 * (distance() + 0.611794)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0464775
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00576489 * (distance()) + 0.125275) * (1.01771 - exp(-(0.0123402 * (distance()) + 0.14025) * (enclose() + 0.0705468 * (distance()) + 0.379771) - (-0.00126363 * (distance()) + -0.0143742) * (enclose() + -0.660481 * (distance()) + 3.01228) * (enclose() + -0.660481 * (distance()) + 3.01228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0692095 * (1 - exp(-0.0900198 * (distance() + 0.611794)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0493783 * (1.01771 - exp(-0.197015 * (enclose() + 0.704286) - -0.0201869 * (enclose() + -0.0259326) * (enclose() + -0.0259326)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1925 end 
// NR:1941 CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.059503 * (1 - exp(-0.769384 * (distance() + 0.248254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0699591
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00113668 * (distance()) + 0.269841) * (0.391614 - exp(-(0.398024 * (distance()) + 0.852515) * (enclose() + -0.0535901 * (distance()) + 1.40373) - (-0.00038229 * (distance()) + -0.175474) * (enclose() + 0.38665 * (distance()) + 1.18296) * (enclose() + 0.38665 * (distance()) + 1.18296)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.059503 * (1 - exp(-0.769384 * (distance() + 0.248254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.137762 * (0.391614 - exp(-2.84264 * (enclose() + 1.13578) - -0.177385 * (enclose() + 3.11621) * (enclose() + 3.11621)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:1967 end 
// NR:1983 CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet4 routingmet2_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0671841 * (1 - exp(-0.175369 * (distance() + 0.32051)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.058199
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0318234 * (distance()) + 0.633796) * (0.226662 - exp(-(0.0797746 * (distance()) + 0.476108) * (enclose() + -0.101113 * (distance()) + 4.35349) - (0.00237161 * (distance()) + -0.049964) * (enclose() + 0.551418 * (distance()) + 3.66128) * (enclose() + 0.551418 * (distance()) + 3.66128)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0671841 * (1 - exp(-0.175369 * (distance() + 0.32051)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.243704 * (0.226662 - exp(-0.843071 * (enclose() + 3.88837) - -0.0390546 * (enclose() + 6.1978) * (enclose() + 6.1978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:2009 end 
#ELSE
// NR:6123 CAPACITANCE CROSSOVER PLATE routingpoly routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0233756 * area()
]
// NR:6127 end 
// NR:6131 CAPACITANCE CROSSOVER PLATE routingpoly routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingpoly_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0133808 * area()
]
// NR:6135 end 
// NR:6147 CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0280392 * area()
]
// NR:6151 end 
// NR:6155 CAPACITANCE CROSSOVER PLATE routingpoly2 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingpoly2_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0147887 * area()
]
// NR:6159 end 
// NR:6163 CAPACITANCE CROSSOVER PLATE routingmet1 routingmet2 MASK
CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet2 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
// NR:6167 end 
// NR:6171 CAPACITANCE CROSSOVER PLATE routingmet1 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingmet1_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0229756 * area()
]
// NR:6175 end 
// NR:6179 CAPACITANCE CROSSOVER PLATE routingmet2 routingmet3 MASK
CAPACITANCE CROSSOVER PLATE routingmet2_rblock routingmet3 MASK
[
    PROPERTY C
    C = 0.0864321 * area()
]
// NR:6183 end 
// NR:6316 CAPACITANCE CROSSOVER FRINGE routingpoly routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0114012
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00062599 * (distance()) + 0.0282508) * (0.851304 - exp(-(0.0196217 * (distance()) + 0.573508) * (enclose() + 1.02061 * (distance()) + -0.308989) - (0.0113928 * (distance()) + -0.131409) * (enclose() + -1.1941 * (distance()) + 0.303697) * (enclose() + -1.1941 * (distance()) + 0.303697)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0108036 * (1 - exp(-1.55108 * (distance() + -0.0159402)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0125604 * (0.851304 - exp(-0.671617 * (enclose() + 4.79406) - -0.074445 * (enclose() + -5.6668) * (enclose() + -5.6668)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6342 end 
// NR:6374 CAPACITANCE CROSSOVER FRINGE routingpoly routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00751821
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0005069 * (distance()) + 0.0177632) * (0.888417 - exp(-(0.0886848 * (distance()) + 0.297385) * (enclose() + 1.11303 * (distance()) + -0.535398) - (0.0001524 * (distance()) + -0.00994877) * (enclose() + -3.71732 * (distance()) + 0.933425) * (enclose() + -3.71732 * (distance()) + 0.933425)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00694919 * (1 - exp(-1.32087 * (distance() + 0.0473094)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.00761435 * (0.888417 - exp(-0.740809 * (enclose() + 5.02975) - -0.00918677 * (enclose() + -17.6532) * (enclose() + -17.6532)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6400 end 
// NR:6490 CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0153765
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00069049 * (distance()) + 0.0385349) * (0.849839 - exp(-(-0.0177683 * (distance()) + 0.629259) * (enclose() + 1.02687 * (distance()) + -0.344208) - (0.0267238 * (distance()) + -0.254412) * (enclose() + -0.786803 * (distance()) + 0.143556) * (enclose() + -0.786803 * (distance()) + 0.143556)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0149072 * (1 - exp(-1.31303 * (distance() + -0.0621)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0175412 * (0.849839 - exp(-0.540417 * (enclose() + 4.79014) - -0.120793 * (enclose() + -3.79046) * (enclose() + -3.79046)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6516 end 
// NR:6548 CAPACITANCE CROSSOVER FRINGE routingpoly2 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingpoly2_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0101113
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0006614 * (distance()) + 0.0250219) * (0.863763 - exp(-(0.04188 * (distance()) + 0.347655) * (enclose() + 0.981212 * (distance()) + -0.573018) - (0.00081489 * (distance()) + -0.0367646) * (enclose() + -1.48703 * (distance()) + 0.58009) * (enclose() + -1.48703 * (distance()) + 0.58009)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.00957253 * (1 - exp(-1.004 * (distance() + 0.0161804)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0108574 * (0.863763 - exp(-0.557055 * (enclose() + 4.33304) - -0.0326902 * (enclose() + -6.85506) * (enclose() + -6.85506)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6574 end 
// NR:6606 CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet2 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.043468
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0011939 * (distance()) + 0.147617) * (0.583048 - exp(-(0.728225 * (distance()) + 0.715094) * (enclose() + -0.0612145 * (distance()) + 0.918083) - (-0.0648728 * (distance()) + -0.0860002) * (enclose() + 0.117649 * (distance()) + 1.28228) * (enclose() + 0.117649 * (distance()) + 1.28228)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0423396 * (1 - exp(-1.26449 * (distance() + -0.0546928)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0708238 * (0.583048 - exp(-4.35622 * (enclose() + 0.612011) - -0.410364 * (enclose() + 1.87053) * (enclose() + 1.87053)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6632 end 
// NR:6664 CAPACITANCE CROSSOVER FRINGE routingmet1 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingmet1_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0222104
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00076785 * (distance()) + 0.0386978) * (0.983519 - exp(-(0.0442796 * (distance()) + 0.345236) * (enclose() + -0.419508 * (distance()) + 0.140541) - (0.00906205 * (distance()) + -0.00466239) * (enclose() + -0.194923 * (distance()) + 8.0244) * (enclose() + -0.194923 * (distance()) + 8.0244)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0219547 * (1 - exp(-0.715456 * (distance() + -0.0540254)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0212685 * (0.983519 - exp(-0.566634 * (enclose() + -1.957) - 0.0406479 * (enclose() + 7.04978) * (enclose() + 7.04978)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6690 end 
// NR:6722 CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet3 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2_rblock routingmet3 MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0495344
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0104668 * (distance()) + 0.366574) * (0.225389 - exp(-(-0.0771219 * (distance()) + -0.00327448) * (enclose() + 12.2531 * (distance()) + 15.212) - (0.00085829 * (distance()) + 0.0463663) * (enclose() + 3.94279 * (distance()) + 5.50309) * (enclose() + 3.94279 * (distance()) + 5.50309)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0479386 * (1 - exp(-0.985465 * (distance() + 0.0152758)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.209454 * (0.225389 - exp(0.388884 * (enclose() + 76.4775) - 0.0506578 * (enclose() + 25.217) * (enclose() + 25.217)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6748 end 
// NR:6865 CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.039615 * (1 - exp(-0.375563 * (distance() + 0.444163)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0474763
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0235055 * (distance()) + 0.267063) * (0.635061 - exp(-(0.188774 * (distance()) + 0.410235) * (enclose() + 0.520894 * (distance()) + 2.34422) - (0.00082759 * (distance()) + -0.0427644) * (enclose() + 1.78695 * (distance()) + 3.66142) * (enclose() + 1.78695 * (distance()) + 3.66142)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.039615 * (1 - exp(-0.375563 * (distance() + 0.444163)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0747677 * (0.635061 - exp(-1.35411 * (enclose() + 4.94869) - -0.0386264 * (enclose() + 12.5962) * (enclose() + 12.5962)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6891 end 
// NR:6907 CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0673155 * (1 - exp(-0.0946637 * (distance() + 0.571622)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0455548
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.00343034 * (distance()) + 0.0882435) * (1.04573 - exp(-(0.107188 * (distance()) + -0.0522678) * (enclose() + 0.229692 * (distance()) + -0.506545) - (0.00031696 * (distance()) + -0.024796) * (enclose() + 1.16602 * (distance()) + -2.44325) * (enclose() + 1.16602 * (distance()) + -2.44325)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0673155 * (1 - exp(-0.0946637 * (distance() + 0.571622)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.036232 * (1.04573 - exp(-0.440797 * (enclose() + 0.550038) - -0.023338 * (enclose() + 2.92044) * (enclose() + 2.92044)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:6975 end 
// NR:6991 CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingpoly2_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.041887 * (1 - exp(-0.426451 * (distance() + 0.374841)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0500322
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00287469 * (distance()) + 0.155785) * (0.429744 - exp(-(0.164991 * (distance()) + 0.350982) * (enclose() + -0.231449 * (distance()) + 2.57814) - (-0.00922497 * (distance()) + -0.0159847) * (enclose() + -0.0423029 * (distance()) + 3.45431) * (enclose() + -0.0423029 * (distance()) + 3.45431)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.041887 * (1 - exp(-0.426451 * (distance() + 0.374841)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0850792 * (0.429744 - exp(-1.17594 * (enclose() + 1.4209) - -0.0621095 * (enclose() + 3.2428) * (enclose() + 3.2428)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:7017 end 
// NR:7033 CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2 MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingpoly2_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.067421 * (1 - exp(-0.105659 * (distance() + 0.510574)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0475855
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0120018 * (distance()) + 0.0598651) * (0.460426 - exp(-(-0.0268316 * (distance()) + 0.0386692) * (enclose() + 4.42181 * (distance()) + 4.97305) - (0.00107322 * (distance()) + 0.0284893) * (enclose() + 1.35526 * (distance()) + 3.3755) * (enclose() + 1.35526 * (distance()) + 3.3755)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.067421 * (1 - exp(-0.105659 * (distance() + 0.510574)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0575367 * (0.460426 - exp(0.0847562 * (enclose() + 25.3134) - 0.0334261 * (enclose() + 9.6097) * (enclose() + 9.6097)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:7059 end 
// NR:7075 CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1 MASK
CAPACITANCE CROSSOVER FRINGE routingmet2 routingmet1_rblock MASK
[
    PROPERTY C
    max_caldistance = 5 // For reference
    max_calenclose = 5 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0594812 * (1 - exp(-0.771083 * (distance() + 0.244412)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0697282
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.00562721 * (distance()) + 0.151064) * (0.61029 - exp(-(0.450388 * (distance()) + 0.478987) * (enclose() + -0.0452078 * (distance()) + 1.17355) - (-0.0346618 * (distance()) + -0.00911022) * (enclose() + 0.216465 * (distance()) + 1.90626) * (enclose() + 0.216465 * (distance()) + 1.90626)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0594812 * (1 - exp(-0.771083 * (distance() + 0.244412)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.0896 * (0.61029 - exp(-2.73093 * (enclose() + 0.947511) - -0.182419 * (enclose() + 2.98859) * (enclose() + 2.98859)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:7101 end 
// NR:7117 CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1 MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet1_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.066607 * (1 - exp(-0.178297 * (distance() + 0.30861)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0575788
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (0.0341007 * (distance()) + 0.133527) * (0.257629 - exp(-(-0.0910222 * (distance()) + 0.147921) * (enclose() + 3.06324 * (distance()) + 4.61145) - (0.00096761 * (distance()) + 0.0312914) * (enclose() + 2.24685 * (distance()) + 3.43172) * (enclose() + 2.24685 * (distance()) + 3.43172)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.066607 * (1 - exp(-0.178297 * (distance() + 0.30861)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.145195 * (0.257629 - exp(0.270781 * (enclose() + 18.7024) - 0.0357424 * (enclose() + 13.7672) * (enclose() + 13.7672)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:7143 end 
// NR:7159 CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2_rblock MASK
CAPACITANCE CROSSOVER FRINGE routingmet3 routingmet2_rblock MASK
[
    PROPERTY C
    max_caldistance = 4.6 // For reference
    max_calenclose = 4.6 // For reference
    max_distance = 3
    max_enclose = 3
    C = 0.0
    if ((distance() > 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0922927 * (1 - exp(-0.458167 * (distance() + 0.165664)))
    }
    if ((distance() <= 0.0) && (enclose() >= max_enclose)) {
        C = length() * 0.0950653
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() < distance())) {
        C = length() * 0.5 * (-0.0266924 * (distance()) + 0.399596) * (0.619332 - exp(-(0.320187 * (distance()) + 0.45265) * (enclose() + 0.0609219 * (distance()) + 1.12404) - (0.0102528 * (distance()) + -0.163847) * (enclose() + 0.715453 * (distance()) + 0.633909) * (enclose() + 0.715453 * (distance()) + 0.633909)))
    }
    if ((distance() > 0.0) && (enclose() < max_enclose) && (enclose() >= distance())) {
        C = length() * 0.0922927 * (1 - exp(-0.458167 * (distance() + 0.165664)))
    }
    if ((distance() <= 0.0) && (enclose() < max_enclose)) {
        C = length() * 0.138405 * (0.619332 - exp(-1.92551 * (enclose() + 1.40428) - -0.116684 * (enclose() + 3.92499) * (enclose() + 3.92499)))
    }
    if (C < 0.0) {
        C = 0
    }
]
// NR:7185 end 
#ENDIF // 3met
#ENDIF // pexswitch
///////////////////////////////////////////////////////////////////////
//
//  end of CALIBRE XRC technology file   end of CALIBRE XRC technology file
//
///////////////////////////////////////////////////////////////////////
